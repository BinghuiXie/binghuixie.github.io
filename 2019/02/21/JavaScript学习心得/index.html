<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark"  type="image/x-icon"  href="/img/favicon.ico"/>
	<link rel="shortcut icon" href="/img/favicon.ico">
	
			    <title>
    不会拉小提琴的左脚
    </title>
    <meta charset="utf-8" />
    <meta name="baidu-site-verification" content="cwuaQdioe5" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    <meta name="keywords" content="html css" />
    
    	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	 
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>
    <style type="text/css">
        body:before {
             content: ' ';
             position: fixed;
             top: 0;
             background: url('/img/bg.jpg') center 0 no-repeat;
             right: 0;
             bottom: 0;
             left: 0;
             background-size: cover;
         }
    </style>

			    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script async type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<link rel="stylesheet" href="/css/prism-twilight.css" type="text/css"></head>
    
		
<!-- Layouts -->



<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_coy.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">home page</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow">home page</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <!-- archives  归档   --> 
	        
	        <li class="active">
	            <a href="#s1">categories</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="archive-link" href="/archives/2019/02/">February 2019</a></li><li><a class="archive-link" href="/archives/2018/11/">November 2018</a></li><li><a class="archive-link" href="/archives/2018/10/">October 2018</a></li><li><a class="archive-link" href="/archives/2018/08/">August 2018</a>
	                    </ul>
	        </li>
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/gallery/" title="images">
		                images
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tag/" title="tages">
		                tages
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
                    
                    <li>
                        <a title="github" href="https://github.com/BinghuiXie/binghuixie.github.io.git" target="_blank" rel="noopener">
                            <i class="icon fa fa-github"></i>
                        </a>
                    </li>
                    
			</ul>
</nav>

        <div id="main" >
            <div class ="post_page_title_img" style="height: 25rem;background-image: url(https://i.imgur.com/SiEQ9UY.jpg);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;" >
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2 >JavaScript学习心得</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
                <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这段时间一直在看JavaScript的闭包，原型，原型链这些问题，结果越看越多，一个接着一个，一大堆东西进到了脑子里，为了不让自己忘记，所以写这篇文章来整理一下，包括JavaScript的<strong>原型（prototype）</strong>，<strong>原型链（Prototype Chain）</strong>，<strong>词法作用域（静态作用域（lexical context））</strong>，<strong>执行环境</strong>(<strong>执行上下文</strong>(<strong>execution context</strong>))，<strong>变量对象(variable object)</strong>，<strong>活动对象（Active Object）</strong>，<strong>作用域链（scope chain）</strong>，<strong>闭包（Closure）</strong>，<i>this</i>这些。这些东西看似独立，实际上都是一环扣一环，理解了一个才能辅助理解下一个，都看得差不多了，闭包也不再是什么问题了。</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>1.<a href="#link1">JavaScript的原型</a><br>2.<a href="">JavaScript的原型链</a><br>3.<a href="#link2">JavaScript的词法作用域(静态作用域)</a><br>4.<a href="#link3">JavaScript的执行环境</a><br>5.<a href="#link4">JavaScript的变量对象与活动对象</a><br>6.<a href="#link5">JavaScript的作用域链</a><br>7.<a href="#link6">JavaScript的this指针</a><br>8.<a href="#link7">JavaScript的闭包</a></p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><a name="link1"></a></p>
<h3 id="JavaScript的原型"><a href="#JavaScript的原型" class="headerlink" title="JavaScript的原型"></a>JavaScript的原型</h3><p>在JavaScript中，每一个函数都有一个属性叫做<i>prototype</i>属性，<i>JavaScript</i>高级程序设计是这么样去解释该属性的。</p>
<blockquote>
<p>这个属性是一个指针，指向一个对象，这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。如果按照字面意思来理解，那么 <i>prototype</i>就是通过调用构造函数而创建的那个对象实例的原型对象。</p>
</blockquote>
<p>这句话在没有真正理解原型和<i>prototype</i>之前是不好理解的，不过先不着急，先把这句话放着，看完这一小节在回来看这句话就会理解了。</p>
<p>至于原型的作用，MDN中给出一句话</p>
<blockquote>
<p>对象以其原型为模板、从原型继承方法和属性。</p>
</blockquote>
<p>这句话仔细读的话是能看出很多东西的，想要理解这句话的含义，我们就要深入去理解<i>prototype</i>，首先从一段代码开始：</p>
<pre><code>    // 构造函数
    function Person() {

    }

    // prototype 是函数才会有的属性
    Person.prototype.name = &quot;Tiki-Taka&quot;;

    // 实例化
    let person1 = new Person();
    let person2 = new Person();

    console.log(person1.name); // Tiki-Taka
    console.log(person2.name); // Tiki-Taka
</code></pre><p>在这段代码里面，<i>Person</i>是一个简单的构造函数，此时构造函数里面没有任何属性和方法，现在通过<i>prototype</i>给构造函数添加一个<i>name</i>属性，然后创建两个实例，<i>person1</i>和<i>person2</i>，通过实例来对<i>name</i>属性进行调用，发现打印出来的都是通过<i>prototype</i>定义的<i>Tiki-Taka</i>，这说明我们通过构造函数的<i>prototype</i>来定义的属性是可以继承到实例上并且被实例所引用的，同样再来看看通过<i>prototype</i>定义方法</p>
<pre><code>    // 构造函数
    function Person() {

    }

    // prototype 是函数才会有的属性
    Person.prototype.showName = function () {
        console.log(this.name);
    }

    // 实例化
    let person1 = new Person();
    let person2 = new Person();

    person1.showName(); // Tiki-Taka
    person2.showName(); // Tiki-Taka
</code></pre><p>同样，实例中也会得到在原型中定义的方法<br>通过这两个例子就可以更好的理解上面的那句话了：<strong>对象以其原型为模板、从原型继承方法和属性。</strong>，也就是说，当我们通过原型定义了方法和属性的时候，实例化的对象就可以继承到这些属性和方法。<br>我们现在已经知道原型和实例之间有一定的关系，那原型，实例，构造函数三者之间有什么相互的关系呢？<br>从上例的代码来说，构造函数即为<i>Person()</i>，原型也就是<i>Person.prototype</i>，它是一个对象，这二者之间可以说是通过<i>prototype</i>这个属性联系起来的，他们之间的关系可以用下图来表示<br><img src="https://i.imgur.com/8vgV78Y.jpg" alt=""><br>从上面的例子中我们知道实例可以从原型<i>Object.prototype</i>中继承属性和方法，那么从实例到原型之间又有什么关系呢？我们需要了解另一个属性<i> <strong>proto</strong> </i>，通过该属性可以将原型和实例联系起来<br>还是先看一下高程的说法(我可真是喜欢引用高程的话啊)，其实已经说得很明白了</p>
<blockquote>
<p>。当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象。ECMA-262 第 5 版中管这个指针叫<i>[[Prototype]]</i>。虽然在脚本中<br>没有标准的方式访问<i>[[Prototype]]</i>，但<i>Firefox</i>、<i>Safari</i> 和<i>Chrome</i>在每个对象上都支持一个属性<br><i><strong>proto</strong></i>；而在其他实现中，这个属性对脚本则是完全不可见的。不过，要明确的真正重要的一点就<br>是，这个连接存在于<strong>实例</strong>与<strong>构造函数的原型对象</strong>之间，而不是存在于实例与构造函数之间</p>
</blockquote>
<p>在<i>JavaScript</i>中提供了一个方法<i>isPrototypeOf</i>，可以通过该方法来确定对象之间是否存在这种关系。从本质上讲，如果<i><strong>proto</strong></i>指向调用 <i>isPrototypeOf()</i>方法的对象<i>（Person.prototype）</i>，那么这个方法就返回 true，</p>
<pre><code>console.log(Person.prototype.isPrototypeOf(person1)); // true 
</code></pre><p>说了半天，总结一下，就是实例上有一个属性<i><strong>proto</strong></i>指向了该实例的原型(对象)<br>用一张图来表示关系：<br><img src="https://i.imgur.com/fXb1Cwu.jpg" alt=""><br>用代码也可以啃清晰地看出这种关系</p>
<pre><code>// 构造函数
    function Person() {

    }

    // 实例化
    let person1 = new Person();

    console.log(person1.__proto__ === Person.prototype); // true

    // 打印出来为 true ，说明了实例(对象)可以通过 __proto__ 指向原型
</code></pre><p>当我们在浏览器里面打印原型的时候，会看到其中还有一个<i>constructor</i>属性，通过打印<i>Person.prototype.constructor</i>，可以发现得到的结果是<i>Person () {}</i>，这说明了原型中的<i>constructor</i>属性是指向构造函数的，代码也帮我们证明了这一点</p>
<pre><code>console.log(Person.prototype.constructo === Person); // true
</code></pre><p>这样我们就可以进一步完善三者的关系图<br><img src="https://i.imgur.com/2hjhEXM.jpg" alt=""><br>这边要注意一点，实例本身是不具有constructor属性的，当你在控制台中输入<i>person.constructor</i>的时候<br>到此为止，三者之间的关系就还算清楚了，但是这还是不够，我们接着往下看<br>在前两个例子中，我们看到实例从原型那里继承过来的属性和方法是一模一样的，就像是复制了一遍，但你仔细看一看代码，我在创建了实例以后是直接去使用了<i>person1.name</i>的，但是你去打印一下<i>person1</i>，发现里面并没有<i>name</i>属性，那怎么还会能得到结果呢？<br><i>person1</i>的打印结果<br><img src="https://i.imgur.com/azoE5Bt.jpg" alt=""></p>
<p>当解释器读到一个对象的某一个属性/方法的时候，它会去执行一次搜索，去找这个属性/方法。搜索首先是从实例开始的，如果在实例中找到了目标（属性/方法），就返回该属性的值，同时停止搜索。如果没找到，则会去该实例对应的原型里面去找，如果在原型对象中找到了这个属性，则返回该属性的值。如果还没找到，就再去上一级找（这个上一级是啥我们一会再说），再找不到，就返回<i>undefined</i>，如果找到了就返回这个属性的值。所以我们才会在多个实例里面都得到同样的结果，因为他们都是搜索到同一个原型后返回的值。当然我们在不同的实例之间想让他们的同一个属性之间拥有不同的值，那么我们就需要通过实例来更改特定属性的值，比如说：</p>
<pre><code>    var person1 = new Person(); 
    var person2 = new Person(); 
    person1.name = &quot;Greg&quot;; 
    console.log(person1.name); // Greg
    console.log(person2.name); // Tiki-Taka
</code></pre><p>这是不是说<i>person1</i>更改了原型中的<i>name</i>属性的值呢？其实不是的，因为我们打印的<i>person2</i>的<i>name</i>的值还是Tiki-Taka，这就说明，通过实例修改对应属性的值，起到的作用只是<strong>覆盖</strong>原型中同名属性的值，而不是修改原型中同名属性的值，因为解释器在搜索的时候已经在第一次搜索就在实例中拿到了结果，所以搜索停止，不会再向上找了，同时，<i>JavaScript</i>里面提供了<i>hasOwnProperty()</i>方法（从<i>Object</i>继承来的），该方法可以检测一个属性是存在于实例中，还是存在于原型中，只有在给定属性存在于<strong>对象实例</strong>中时，才会返回<i>true</i>。<br>还是通过看例子比较清楚：</p>
<pre><code>    function Person () {}
    Person.prototype.name = &#39;Tiki-Taka&#39;

    var person1 = new Person()

    console.log(person1.hasOwnProperty(&#39;name&#39;)); // false （说明来自原型(对象)）

    person1.name = &#39;Greg&#39;

    console.log(person1.hasOwnProperty(&#39;name&#39;)); // true （说明来自实例）
</code></pre><p>到此为止，原型的东西就说的差不多了，最开头引用的高程的话应该也明白了，这里再总结一下：<br>每一个函数都有一个<i>prototype</i>属性，这个属性是一个指针，指向一个对象，这个对象我们一般叫做原型（对象），因为它可以让所有通过调用对应的构造函数而创建的实例去共享它所含有的属性和方法，在实例中有一个<i><strong>proto</strong></i>属性（JavaScript中万物皆对象，所有都含有这个<strong>proto</strong>属性），它是指向原型（对象）的，原型（对象）本身还含有一个<i>constructor</i>属性，可以通过该属性访问到对应的构造函数。但是在实例中是不存在<i>constructor</i>属性的，在控制台打印<i>person</i>，可以看到的是里面没有<i>constructor</i>属性，只有一个<i><strong>proto</strong></i>属性，但是打印<i>person.constructor</i>会得到<i>Person () {}</i>，这是因为当读取不到<i>person.constructor</i>时，会从它的原型里面去找<i>constructor</i>属性，而原型的<i>constructor</i>属性正好是指向构造函数的，所以才会有<i>Person () {}</i>的结果。<br><a name="link2"></a></p>
<h3 id="JavaScript的原型链"><a href="#JavaScript的原型链" class="headerlink" title="JavaScript的原型链"></a>JavaScript的原型链</h3><p>在明白了JavaScript原型之后，原型链的理解就变得简单一些了，先看一张图<br><img src="https://i.imgur.com/Cj46wiA.jpg" alt=""><br>在OO语言中，继承是一个令人津津乐道的概念，OO语言实现继承通过两种方式：接口继承和实现继承（这里不讨论），但是在ECMAScript标准中，不支持上述的继承方式，所以在JavaScript中实现继承靠的就是原型链。关于原型链我看了很多资料，网上的说的是<i><strong>proto</strong></i>属性的连线，这当然是没有问题的，但是看JavaScript高级程序设计中说</p>
<blockquote>
<p>每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型<br>对象的内部指针。那么，假如我们让<strong>原型对象等于另一个类型的实例</strong>，结果会怎么样呢？显然，此时的<br>原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数<br>的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实<br>例与原型的链条。这就是所谓原型链的基本概念</p>
</blockquote>
<p>注意上面的引用中的重点就是：<strong>原型对象等于另一个类型的实例</strong>，这一开始读起来会有一种感觉和网上说的不一样（反正我是有这种感觉），但是仔细思考一下，发现其实是一样的叙述。<br>先按照高程中的说法来捋一下，按照高程的说法，原型作为另一个构造函数的实例，这样一层一层下去就构成了原型链，我们通过代码可以看得更清楚：</p>
<pre><code>    /* 第一代闪电侠 */
    function JayGarric() {
        this.disc = &#39;first generation of Flash&#39;;
        this.experience = 100;
        this.speed = &#39;one mile in a second&#39;;
        this.JayAge = 60
    }
    JayGarric.prototype.getJayAge = function () {
        return this.JayAge
    }
    console.log(JayGarric.prototype);

    function BarryAllen() {
        this.disc = &#39;second generation of Flash&#39;;
        this.experience = 80;
        this.speed = &#39;one point five mile in a second&#39;;
        this.BarryAge = 25
    }
    BarryAllen.prototype.getBarryAge = function () {
        return this.BarryAge
    }

    /* 二代闪电侠继承一代闪电侠 */
    /* 实现原型链的代码： 将 BarryAllen 的原型作为 JayGarric 的 实例 */
    BarryAllen.prototype = new JayGarric();
    BarryAllen.prototype.increaseExperience = function () {
        return this.experience * 2;
    }
    console.log(BarryAllen.prototype);

    var red_streak = new BarryAllen();
    console.log(red_streak);
    console.log(red_streak.getJayAge()); // 60
    console.log(red_streak.increaseExperience()); // 160
</code></pre><p>在DC宇宙世界中，第一代闪电侠是<i> Jay Garric </i>，第二代闪电侠是更为人所熟知的<i> Barry Allen </i>，为了看起来不那么枯燥，我让二代闪电侠继承一代闪电侠，从技术层面来讲就是<i> BarryAllen </i>继承了<i> JayGarric </i>，这个继承时通过创建<i> JayGarric </i>的实例，并将它赋值给<i> BarryAllen </i>的原型(<i>BarryAllen.prototype</i>)。<br>下图是二者的实例以及构造函数和原型之间的关系<br><img src="https://i.imgur.com/MCJLKEi.jpg" alt=""><br>从图中我们可以看出，在<i> BarryAllen </i>继承了<i> JayGarric </i>之后，其原型中已经有了所有在<i> JayGarric </i>中定义的属性和方法（注意不是在<i> JayGarric </i>的原型中定义的，而是在构造函数中定义的属性和方法都继承到了<i> BarryAllen.prototype </i>中）,且因为将<i> BarryAllen </i>的原型作为了<i> JayGarric </i>的实例，所以在<i> BarryAllen </i>的原型中会有一个<i><strong>proto</strong></i>指针指向<i> JayGarric </i>的原型也就是<i>JayGarric.prototype</i>，而通过<i> BarryAllen </i>创建的实例<i>red_streak</i>中同样会有一个<i><strong>proto</strong></i>指针指向<i> BarryAllen.prototype </i>，这样通过<i><strong>proto</strong></i>指针连起来的这一条链就是原型链，在本例的原型链中，<i>red_streak</i>是链头，而链尾不是<i>JayGarric.prototype</i>，上层还有一个<i>Object.prototype</i>(因为<i>JayGarric</i>本身也是从<i>Object</i>中继承过来的)，最终原型链往上延伸直到<i>null</i>，更新一张原型链图如下：<br><img src="https://i.imgur.com/rxOUzsJ.jpg" alt=""><br>总结一下，原型链其实就是通过<i><strong>proto</strong></i>指针将具有继承关系的原型连接起来，最终到<i>null</i>的一个链条，原型链的作用，本质上是扩展了前面提到过的搜索机制，举个例子：当我去调用<i>red_streak.getJayAge()</i>的时候，会经历以下步骤：</p>
<ol>
<li><strong>1.在实例中搜索</strong></li>
<li><strong>2.搜索<i>BarryAllen.prototype</i></strong></li>
<li><strong>3. 搜索<i>JayGarric.prototype</i></strong></li>
</ol>
<p>最后一步，在<i>JayGarric.prototype</i>找到该方法，并返回对应的值。<br><a name="link3"></a></p>
<h3 id="JavaScript的词法作用域-静态作用域"><a href="#JavaScript的词法作用域-静态作用域" class="headerlink" title="JavaScript的词法作用域(静态作用域)"></a>JavaScript的词法作用域(静态作用域)</h3><p>作用域共有两种主要的工作模型，第一种是比较普遍的，被大多数编程语言所采用的的静态作用域（词法作用域（lexical Scope））另一种叫做动态作用域（Dynamic Scope），在去深入词法作用域之前，先深入一下作用域的概念</p>
<ul>
<li><p>作用域</p>
<ul>
<li><blockquote>
<p>引擎的另一位好朋友，负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。</p>
</blockquote>
<p>  在你所不知道的JavaScript中的这段话可以说是通过一句话交代明白了什么是作用域和作用域的作用了，即作用域首先是辅助引擎的，其次，他规定了如何去根据名称在与当前执行代码相关的作用域中去<strong>查找</strong>变量（标识符），说白了就是如何查找变量的一套规则，看下面这段代码</p>
<pre><code>  var global = &#39;global&#39;;
  console.log(global); // global
</code></pre><p>  这段代码实在是简单的不能再简单了，打印出global肯定没问题，但我想通过这两行代码说明一下作用域的查找到底是怎么一个意思。我们看，当遇到了var global，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为 global，然后，该赋值的时候，引擎会在当前作用域中<strong>查找</strong>名为global的变量，找到了，赋值2，打印，结束了。<br>  再看一段代码：</p>
<pre><code>  var global = &#39;global&#39;;
  function foo() {
      console.log(global); // global
  }
  foo();
</code></pre><p>  我们跳过编译器那段，直接从引擎开始，当调用<i>foo()</i>函数的时候，要去打印<i>global</i>这个变量，然后引擎就问作用域说你给我在<i>foo()</i>这个作用域（函数作用域）中找一下这个<i>global</i>这个变量，作用域说没有，引擎就到外面（全局作用域）去找，这回找到了，所以能打印出来global。<br>  说了这些，意在帮助理解作用域这个<strong>查找</strong>的概念，这个理解之后，词法作用域也就不是那么难理解了</p>
</li>
</ul>
</li>
<li>词法作用域<ul>
<li>上面花了很多篇幅去解释查找的意思，其实词法作用域和动态作用域的区别就在于查找的路径不一样，词法作用域是当你写代码的时候，这块代码的作用域就确定了，动态作用域是你调用代码的时候才确定的，因为这个的区别，导致查找的起点，路径也有做不同，同样是看一个例子<pre><code>var global = &#39;global&#39;;
function global_context_01() {
  console.log(global);
}
function global_context_02() {
  var global = &#39;fake global&#39;;
  global_context_01();
}
global_context_02(); // global
</code></pre>这段代码从词法作用域的角度分析：调用<i>global_context_02()</i>，进入该函数，调用<i>global_context_01()</i>，需要打印<i>global</i>，那么引擎就去找该变量，在<i>global_context_01()</i>内部没有找到，此时因为是词法作用域，所以会从<i>global_context_01()</i>被书写的位置向上开始找，这样就进入到了全局作用域里面找到了对应的变量并打印出来了它的值。<br>如果是动态作用域，当在<i>global_context_01()</i>内部没有找到时，会从调用该函数的地方去找，也就是到了<i>global_context_02()</i>这个函数作用域里面，找到了<i>global</i>的值是<i>fake global</i>，会打印<i>fake global</i>。</li>
</ul>
</li>
</ul>
<p><a name="link4"></a></p>
<h3 id="JavaScript的执行环境-执行上下文"><a href="#JavaScript的执行环境-执行上下文" class="headerlink" title="JavaScript的执行环境(执行上下文)"></a>JavaScript的执行环境(执行上下文)</h3><p><a name="link5"></a></p>
<h3 id="JavaScript的变量对象与活动对象"><a href="#JavaScript的变量对象与活动对象" class="headerlink" title="JavaScript的变量对象与活动对象"></a>JavaScript的变量对象与活动对象</h3><p><a name="link6"></a></p>
<h3 id="JavaScript的作用域链"><a href="#JavaScript的作用域链" class="headerlink" title="JavaScript的作用域链"></a>JavaScript的作用域链</h3><p><a name="link7"></a></p>
<h3 id="JavaScript的this指针"><a href="#JavaScript的this指针" class="headerlink" title="JavaScript的this指针"></a>JavaScript的this指针</h3><p><a name="link8"></a></p>
<h3 id="JavaScript的闭包"><a href="#JavaScript的闭包" class="headerlink" title="JavaScript的闭包"></a>JavaScript的闭包</h3>
            </div>

            <!-- Post Comments -->
            
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #7EC0EE;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load" id="disqus_bt"> 
    <button class="disqus_click_btn">点击查看评论</button>
</div>

<!--
<script type="text/javascript">
$('.btn_click_load').click(function() {
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'http-miccall-tech'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    document.getElementById('disqus_bt').style.display = "none";
});
</script>
-->
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://yoursite.com/2019/02/21/JavaScript学习心得/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'http://yoursite.com/2019/02/21/JavaScript学习心得/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/javascript">
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//http-miccall-tech.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <!--<ul>-->
                <!--<li>&copy;Powered By <a href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>-->
                <!--<li>Design: <a href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>-->
            <!--</ul>-->
            
            	<span id="busuanzi_container_site_pv">2019总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
