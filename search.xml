<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CSS布局--position篇]]></title>
    <url>%2F2018%2F10%2F27%2FCSS%E5%B8%83%E5%B1%80-position%E7%AF%87%2F</url>
    <content type="text"></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS布局--display:inline-block篇]]></title>
    <url>%2F2018%2F10%2F27%2FCSS%E5%B8%83%E5%B1%80-display-inline-block%E7%AF%87%2F</url>
    <content type="text"><![CDATA[前言最近因为要讲一些CSS布局的课，所以专门讲CSS的几种布局方法总结整理出来写到了博客上，本篇文章是CSS布局(一)–display:inline-block篇，后面还有CSS布局–float篇，CSS布局–position篇以及CSS布局–flex篇，至于table布局，主要是自己用的也不多，就不在这里班门弄斧了。 目录1.块级元素和行内元素2.CSS display属性3.display:inline-block布局4.幽灵空白节点5.总结 块级元素和内联元素因为display”inline-block涉及到了inline和block，那么块级元素和内联元素我们就不得不来说一下了。我们先说，常见的块级元素有div，li，table，p，ul，ol等，常见的内联元素有span，em，i，我们先从一个例子入手，看一下两种元素的区别html代码: &lt;div class=&quot;parent&quot;&gt; &lt;div&gt;常见块级元素--div&lt;/div&gt; &lt;p&gt;常见块级元素--p&lt;/p&gt; &lt;h1&gt;常见块级元素--h1(h1~h6)&lt;/h1&gt; &lt;ul&gt; &lt;li style=&quot;width: 150px;height: 150px&quot;&gt;块级元素可以设置宽高 &lt;br&gt;width:150px height:150px&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;parent&quot;&gt; &lt;a href=&quot;&quot;&gt;常见的内联元素--a&lt;/a&gt; &lt;span&gt;常见的内联元素--span&lt;/span&gt; &lt;em&gt;常见的内联元素--em&lt;/em&gt; &lt;i style=&quot;width: 200px;height: 250px&quot;&gt;内联元素不可以设置宽高 width: 200px;height: 250px&lt;/i&gt; &lt;/div&gt; css代码： .parent{ width: 100%; height: 400px; border: 2px solid #000; box-sizing: border-box; margin: 15px 0; } .parent:nth-of-type(1) div{ background-color: #856404; margin-left: 15px; margin-bottom: 15px; margin-right: 15px; margin-top: 15px; padding-left: 15px; padding-bottom: 15px; padding-right: 15px; padding-top: 15px; } .parent:nth-of-type(1) p{ background-color: #00A000; } .parent:nth-of-type(1) h1{ background-color: #c10802; } .parent:nth-of-type(1) li{ background-color: #3b5998; } .parent:nth-of-type(2) a{ background-color: #856404; } .parent:nth-of-type(2) span{ background-color: #00A000; margin-left: 15px; margin-bottom: 15px; margin-right: 15px; margin-top: 15px; padding-left: 15px; padding-bottom: 15px; padding-right: 15px; padding-top: 15px; } .parent:nth-of-type(2) em{ background-color: #c10802; } .parent:nth-of-type(2) i{ background-color: #3b5998; } 效果图如下：块级元素：行内元素我们可以看出，块级元素默认会占满父元素的宽度（在本例中因为设置了父元素的宽度为100%也就是浏览器的宽度，所以子元素会占满浏览器一整行的宽度），而且与内容的宽度无关，也就是说，就算块级元素内容的宽度不足浏览器一整行的宽度，块级元素仍然会占满浏览器一整行的宽度，除此之外，我们看到块级元素还可以设置宽度和高度，此时内容如果在容器宽度内一行放不下的时候会换行，我们还可以看到对行内元素设置margin和padding，四个方向left，eight，bottom，top都会起作用。内联元素，从例子中我们可以看出，内联元素的宽度是内容的宽度，而且不会默认占满父容器的一整行，而且当给内联元素设置宽度个高度时不会有效果，还有我们可以发现，给内联元素设置边距margin和padding的时候，对于margin，只有margin-left和margin-right起到了作用，而margin-top和margin-bottom没有起到作用，padding在四个方向均有效果。所以总结一下块级元素和内联元素的区别 块级元素会独占一行，在内容不满父元素宽度的情况下，块级元素的宽度默认会是父级元素的宽度 内联元素默认情况下的宽度就是内容的宽度，每一个内联元素会首先在一行内排列，直到内容的宽度超过父容器的宽度时才会换行 块级元素可以设置宽高 内联元素不可以设置宽高 块级元素的margin和padding在四个方向上都会起作用 内联元素的margin在上下两个方向无效，padding在四个方向上都会起作用（IE,Chrome，Firefox下均成立）CSS display属性 display:inline-block布局 幽灵空白节点 总结]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS布局--float篇]]></title>
    <url>%2F2018%2F10%2F27%2FCSS%E5%B8%83%E5%B1%80-float%E7%AF%87%2F</url>
    <content type="text"><![CDATA[前言CSS中的难点之一就是CSS布局了，常见的CSS布局有几种，无非就是通过float属性，display:inline-block属性，position属性，flex布局以及通过table元素来进行布局等，这其中，table布局相对较为古老，而且有许多问题，比如说我们通过table元素的布局是在html中进行的，相对来说与CSS关系不大，这样读起来很让人抓狂。float浮动布局和position属性的布局又存在很多问题，如果对属性的理解不够深入，在使用这些属性进行布局的时候就会经常出现一些莫名其妙的效果让人云里雾里。至于flex布局，是近几年新出的一个CSS布局的方法，相对来说简单易行一些，当然对我们前端开发者来讲，起码的几种CSS布局都最好要掌握一些，所以这篇博文主要讲一下float这个属性，即如何用float来对网页内的元素进行布局，其余的position属性以及flex属性，在我的另外两篇博文中会有详细介绍。 目录1.一个概念2.什么是CSS布局3.用float实现一些简单的布局4.出bug了…5.float的前生6.float的特点7.揭开float的真面目8.遏制浮动–清除浮动9.浮动实现CSS常见布局0110.浮动实现CSS常见布局0211.浮动实现CSS常见布局03本篇博客是看过了许多大牛们的博客之后自己总结出来的，为了深入理解float自己也写了不少demo，所有的代码都可以在我的github上找到，下面附上我的github地址以及一些大牛们对float的回答(1)张鑫旭 CSS float浮动的深入研究、详解及拓展(一)(2)张鑫旭 CSS float浮动的深入研究、详解及拓展(二)(3)我的github地址 1.一个概念在正式说float属性之前，我们先来看一个概念，理解了这个概念以后，对后文的float属性的理解也会有所帮助。 文档流什么是文档流？ 2.什么是CSS布局 3.用float实现一些简单的布局 4.出bug了… 5.float的前生 5.float的特点 6.揭开float的真面目 7.遏制浮动–清除浮动 8.浮动实现CSS常见布局01 9.浮动实现CSS常见布局02 10.浮动实现CSS常见布局03]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS flex布局学习]]></title>
    <url>%2F2018%2F10%2F13%2FCSS-flex%E5%B8%83%E5%B1%80%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[前言flex的出现使css的布局大大简化，例如两栏自适应等常见CSS布局通过使用flex布局能非常方便的达到，然而在网上常见的flex布局的教程中，许多属性的深层意思都没有提及，例如flex-grow与flex-shrink属性，正好这段时间我也开始在学flex布局，而且我这个人一向的习惯就是新学的东西一定要有笔记，以前用那些办公软件记笔记，结果有一次都丢了，自那以后搭建起了博客，一些笔记就都放在了博客上面，所以今天传上来这个flex布局的笔记，希望大家看过后能有所收货。ps：以下所有内容是我在看完菜鸟教程以及阮一峰老师的博客后所写，链接给大家。 目录1.什么是flex布局2.flex布局中一些相关的概念3.指定flex布局4.容器属性：flex-direction5.容器属性：flex-wrap6.容器属性：flex-flow7.容器属性：justify-content8.容器属性：align-items9.容器属性：align-content10.项目属性：order11.项目属性：flex-grow12.项目属性：flex-shrink13.项目属性：flex-basis14.项目属性：flex15.项目属性：align-self内容比较多，我自己一次也写不完，慢慢来吧~ 1.什么是flex布局我们都知道，CSS的布局是一个难点，先不说flex，常见的CSS布局比如说有两栏自适应，两翼齐飞布局什么的，其实说白了只要涉及到元素的位置的安排，都算是布局，那在flex之前我们常用的手段有float，position，table等，但是这些属性本身不是为布局而生的，就比如说float，它本质就是实现一个文字环绕效果，但是用这些属性吧，你要是理解的不够深入，还会出现各种各样的坑，比如说一会脱离文档流啦（float，position的absolute和fixed），position的定位原点什么的，会导致网页布局乱七八糟。那么flex布局，flex是flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。目前，flex布局已经得到所有浏览器的支持，这意味着，现在可以放心的使用这项技术 2.flex布局中一些相关的概念这节介绍一些flex布局中的一些定义，一些概念性的东西我们把设置为flex布局的容器叫做flex容器，简称“容器”，该容器的所有的子元素会自动成为该容器的成员，称为flex项目，简称“项目”。容器默认存在两根轴，一个是水平的主轴（main axis）（如图），还有一个是垂直的交叉轴（cross axis）。主轴开始的位置叫做main start，结束位置叫做main end；交叉轴开始的位置叫做cross start，结束的位置叫做cross end。容器的子元素也就是项目默认沿着主轴排列，单个项目占据的主轴空间叫做main size，占据的交叉空间叫做cross size。 3.指定flex布局上面说过，设置了flex布局的容器叫做flex容器，我们可以通过display属性将该容器声明为一个flex布局的容器: .container{ display:flex; } 行内元素也可以设置flex布局 .container{ display:inline-flex; } 注意一个问题，容器设置为flex布局以后，其子元素的float，clear以及vertical-align都会失效 4.容器属性：flex-direction注：从下面开始，凡是标注了“容器属性”后面的所有属性都是设置在容器也就是父元素身上的。标注了“项目属性”的所有属性都是设置在子元素上面的flex-direction决定主轴（水平）的方向（即项目(子元素)的排列方向）flex-direction有四种取值(1)row（默认值）：主轴在水平方向，起点在左端(2)row-reverse：主轴在水平方向，起点在右端(3)column：主轴在垂直方向，起点在上端(4)column-reverse：主轴在垂直方向，起点在下端从例子中能更好的学习理解，所以我做了下面的demo效果如下： 5.容器属性：flex-wrap默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。分情况讨论，当flex-direction的值为row时，如果不设置flex-wrap属性，即取默认值的时候，所有项目会默认从左到右排列在一行，如果所有项目的宽度加起来超过父容器的宽度，则会压缩项目的宽度。如图所示在代码中我默认设置了每一个项目的宽度都是150px，然而可以发现，12个150px加起来12×150=1800px已经超过了父容器的宽度，然而此时并没有换行，而是压缩了子元素的宽度，使其不足150px设置flex-wrap:wrap时，在父容器放不下所有项目时，会换到下一行排列，多余的不足一个项目宽度的地方会空出来，不会填满设置flex-wrap:wrap-reverse的时候，会从最下面开始排列，排列不下了在往上一行放，以此类推当flex-direction的值设置为column时，如果flex-wrap取默认值也就是no-wrap，则会按顺序以一列的形式从上到下排列，如果flex-wrap设置了wrap，则会现在一列里面排列，如果高度超出父容器的高度，则会换到第二列，以此类推，直到排列完（不会被父容器宽度所限制）例如： flex-direcrtion:column,flex-wrap:wrap flex-direcrtion:column,flex-wrap:wrap-reverse其余flex-direction的值与此相似 6.容器属性：flex-flowflex-flow是flex-direction属性和flex-wrap属性的简写，格式如下：flex-flow: ||具体内容见上面，这里不详细介绍 7.容器属性：justify-contentjustify-content属性定义了项目在主轴上的对齐方式。justify-content有六种取值(1)justify-content:flex-start(左对齐)(2)justify-content:flex-end(右对齐)(3)justify-content:center(水平居中)(4)justify-content:space-around（每个项目两侧的间隔相等，这样项目之间的间隔比项目与边框的间隔大一倍)(5)justify-content:space-between(两端对齐)(6)justify-content:space-evenly（项目与项目，项目与边界的间隔都相等 ）注：以上所有排列都是在父容器设置了flex-direction:row的前提下，其余的自己可以动手试一下 8.容器属性：align-itemsalign-items属性定义项目在交叉轴（竖直方向）上如何对齐。align-items有5种取值(1)align-items:flex-startalign-items:flex-start定义项目从交叉轴的起点开始对齐(2)align-items:flex-endalign-items:flex-end定义项目从交叉轴的末端开始对齐(3)align-items:centeralign-items:center定义从交叉线的中点开始对齐（垂直居中）(4)align-items:baselinealign-items:baseline定义从第一行文字的基线开始对齐(5)align-items:stretchalign-items:stretch定义：如果项目未设置高度或设为auto，将占满整个容器的高度 9.容器属性：align-contentalign-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。那怎么样才能有多个轴线呢？其实，只需要让项目换行显示就可以，所以我们需要设置flex-direction属性的值为wrap或者wrap-reverse（例子中使用的是wrap），也就是当所有项目一行放不下的时候，项目会换行显示，这样子就会有多个轴线了。该属性有7个取值(1)align-content:flex-startalign-content:flex-start定义项目与交叉轴的起点对齐(2)align-content:flex-endalign-content:flex-end定义项目与交叉轴的终点对齐(3)align-content:centeralign-content:center定义项目与交叉轴的中点对齐(4)align-content:space-betweenalign-content:space-between定义项目与交叉轴两端对齐，轴线之间的间隔平均分布。(5)align-content:space-aroundalign-content:space-around定义项目之间每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。(6)align-content:space-evenlyalign-content:space-evenly定义所有间距都相等(7)align-content:stretchalign-content:stretch定义轴线占满整个交叉轴，项目不设置高度或者高度为auto 10.项目属性：order注：以下所有属性都是设置在子元素上面的order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 11.项目属性：flex-growflex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大关于这个属性以及下面的flex-shrink属性，在菜鸟教程和阮一峰老师的博客中并没有详细的对此进行解释，只是有上面的一句话，所以我把我自己的理解以及计算方式整理在下面，以供参考首先，flex-grow属性决定了在所有项目的排列方向上还有剩余的空间时，如何分配这些剩余的空间，其值为一个权重，默认是0，也就是不扩张，父元素剩余的空间会按照这个权重来进行分配。先来看一个demo父容器的宽度设置为1000px，5个项目（子元素）的宽高均为40px。现在是我们没有设置flex-grow熟悉的时候，也就是该属性的值默认为0的时候，此时所有项目默认不扩张，按照自身的宽高进行排列，可以看出，父元素上还有如下几个属性，使项目能垂直居中排列 display: flex; flex-wrap: wrap; align-items: center; justify-content: center; 我们现在给标号为1的项目加上属性flex-grow:1，先看看是什么效果可以看出，标号为1的项目占满了剩下的所有宽度，把其余几个项目都挤到了右边再来看几个例子①给标号为1的项目设置flex-grow:1，给标号为2的项目设置flex-grow:2可以看出，2项目的宽度接近1项目宽度的两倍，父元素排列方向上的宽度被占满②给5个项目的flex-grow属性分别设置为1到5 .items1{ flex-grow: 1; } .items2{ flex-grow: 2; } .items3{ flex-grow: 3; } .items4{ flex-grow: 4; } .items5{ flex-grow: 5; } 可以看出，5个项目的宽度相对于第一个项目的宽度依次扩大了其序号所对应的倍数上面两个例子对应的所有项目的flex-grow属性之和都大于1，我们来看一个不大于1的例子③所有项目的flex-grow属性对应的值之和小于1 .items1{ flex-grow: 0.1; } .items2{ flex-grow: .1; } .items3{ flex-grow: .05; } .items4{ flex-grow: .2; } .items5{ flex-grow: .15; } 可以看出，扩大后他们并没有占满父元素所有的剩余空间 总结从上面的例子中，我们可以看出，flex-grow属性之和大于1和小于1显示的效果是不一样的，那么我们分开来讨论一下他的计算方式Ⅰ.当flex-grow属性之和大于1时，五个项目的宽度都是40px，那么剩余空间为1000-5*40 = 800px。五个项目的flex-grow属性为1,2,3,4,5，合起来是sum = 15，所以5个项目分配到的多余的空间为 800 * 1 / 15 = 53.3333333px 800 * 2 / 15 = 106.66666667px 800 * 3 / 15 = 160px 800 * 4 / 15 = 213.333333px 800 * 5 / 15 = 266.666667px 那么这5个项目最终扩张以后的宽度为93.33333333px，146.6666667px，200px，253.333333px，306.6666667px（在40px的基础上加上扩展的宽度）看一下项目的宽度和我们计算的所差无几，说明这样算是正确的我们还可以发现一点，flex-grow属性值为2的项目最终的宽度并不是flex-grow属性值为1的项目的最终宽度的2倍，而是扩展的（变化的）宽度为2倍！！！！！！Ⅱ.当flex-grow属性之和小于1时，五个项目的宽度都是40px，同样剩余空间为1000-5*40 = 800px。五个项目的flex-grow属性值为0.1，0.05,0.2，0.15,0.3，合起来是sum = 0.8 &lt; 1。同样，剩余800px的空间当所有元素的flex-grow属性之和小于1的时候，上面式子中的sum将会使用 1 来参与计算，而不论它们的和是多少，也就是说，这个 0.8 没有什么作用，此时的sum默认按照 1 来计算。那么五个项目扩展的宽度为 800 * 0.1 / 1 = 80px 800 * 0.05 / 1 = 40px 800 * 0.2 / 1 = 160px 800 * 0.15 / 1 = 120px 800 * 0.3 / 1 = 240px 所以最终 5 个项目的宽度分别为 120px，80px，200px，160px，280px可以发现，800px - 80px - 40px - 160px - 120px - 240px = 160px，也就是说，还剩下160px的宽度没有被占满同样我们可以在浏览器里面查看各个项目的宽度与我们计算的一毛一样，完美~ 12.项目属性：flex-shrink上面的flex-grow属性会在父元素有多余的空间的使用通过子元素的扩张来占满这些剩余空间，那么同样就会有在父容器空间不够时将子元素收缩以来适应父元素的空间的属性了，也就是flex-shrink属性flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。那么就像上面flex-grow属性一样，flex-shrink属性也有自己的计算方式，以此来计算子元素该如何收缩。同样，我们先来看flex-grow属性值适合大于1的情况①flex-grow属性值之和大于1我们设父容器的宽度为1000px，5个项目的宽度均为300px，这样多出来的宽度就是300 5 - 1000 = 500px,5个项目flex-shrink属性的值依次为1,2,3,4,5。那么这多出的500px将会由5个项目分别收缩一定的比例来消化。项目收缩的计算公式：超出的总宽度 收缩因子 / 收缩权重 项目宽度收缩因子即为flex-shrink属性的值收缩权重的计算公式：项目宽度 对应的收缩因子所以本例中的权重为：300 1 + 300 2 + 300 3 + 300 4 + 300 * 5 = 4500px所以我们计算每个项目的收缩量如下： 500 1 / 4500 300 = 33.3333333px 500 2 / 4500 300 = 66.6666667px 500 3 / 4500 300 = 100px 500 4 / 4500 300 = 133.333333px 500 5 / 4500 300 = 166.666667px 收缩后每个项目的宽度为 266.66667px，233.33333px，200px，166.666667px，133.333333px我们看一下浏览器显示的宽度以验证我们的结果②flex-grow属性值之和小于1当flex-grow属性值之和小于1时，并不会完美的收缩到正好占满所有的空间而没有溢出，就像flex-grow属性的所有值之和小于1一样，也会按照和sum为1来进行收缩现在设flex-grow属性值分别为0.05,0.1,0.15,0.2,0.25,权重为：300 (0.05 + 0.1 + 0.15 + 0.2 + 0.25) = 225px那么 5 个项目收缩的总和是(0.05 + 0.1 + 0.15 + 0.2 + 0.25) 500px 也就是375px，也就是说，最终收缩完，项目综合还是会超出父容器125px的宽度每个项目收缩的空间为 300 0.05 375 / 225 = 25px 300 0.1 375 / 225 = 50px 300 0.15 375 / 225 = 75px 300 0.2 375 / 225 = 100px 300 0.25 375 / 225 = 125px 所以收缩后的每个项目的宽度为 275px，250px，225px，200px，175px收缩后的宽度之和为：275 + 250 + 225 + 200 + 175 = 1125px，正好多出125px。浏览器里面显示如下：可以看出，最终所有项目的和的宽度还是超过父元素的宽度的 13.项目属性：flex-basisflex-basis属性用于设置或检索弹性盒伸缩基准值。什么意思，就是说flex-basis属性用于设置项目的基准宽度（width），与width属性有异曲同工之妙，但是与width属性又有很大不同。我们都知道，如果没有给一个容器设置宽度的话，那么容器的宽度就是内容（content）的宽度，而flex-basis属性设置后的宽度会覆盖width属性所设置的宽度，也就是说，三者的优先级是这样的 content &lt; width &lt; flex-basis 总的来说就是 如果没有设置flex-basis属性，那么flex-basis的大小就是项目的width属性大小 如果没有设置width属性，那么flex-basis的大小就是项目的内容（content）宽度大小 下面我们来看一些生动的例子我们将容器的宽度设置为1000px，为了方便查看我们令其局中显示(margin: 0 auto;) .wrapper{ width: 1000px; border: 1px solid #000; box-sizing: border-box; margin: 0 auto; background-color: #CCCCCC; height: 400px; display: flex; flex-direction: row; flex-wrap: nowrap; } 给容器下面的每一个项目都设置宽度(width)为100px，flex-basis的值为150px，然后查看浏览器宽度为150px，①说明flex-basis属性会覆盖width属性的取值flex-basis属性也会被max-width属性与min-width属性所限制，我们看例子 .items{ width: 100px; flex-basis: 150px; /*flex-grow: 1;*/ min-width: 250px; height: 250px; background-color: #00A000; border: 1px solid #000000; box-sizing: border-box; } 在上面的代码中，设置了项目的flex-basis属性值为150px，然而设置了min-width属性的值为250px，也就是说，如果min-width属性占了上风，四个项目会正好填满父容器，那是不是这样子呢？很明显，这次是min-width属性占了上风，那么同样，我们在设置了max-width属性后，同样会限制flex-basis属性，如果flex-basis属性的值超过了设定的max-width属性的之后，那么最终显示的会使max-width属性所设定的值。那么当我们设置的所有项目的flex-basis属性值之和大于父容器的宽度后，那么此时起作用的将会是flex-shrink属性了，同样，当项目flex-basis属性值之和达不到父容器的宽度时，我们也可以使用flex-grow属性使其扩展到占满父元素，有关这两个属性已经在上面有详解，这里就不再细说了。 14.项目属性：flexflex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。flex属性因为是三种属性的简写，而flex-grow与flex-shrink是起完全相反的作用的两个属性，所以当然要分情况讨论当这两个属性在不同的项目与容器宽度之比下起到的作用，举个栗子如果父容器的宽度小于项目宽度（此时的宽度使用到的flex-basis属性设置的）之和，那么flex-shrink属性就会起作用，具体计算方式见上如果父容器的宽度大于项目宽度（此时的宽度使用到的flex-basis属性设置的）之和，那么flex-grow属性就会起作用，具体计算方式见上 15.项目属性：align-selfalign-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretchalign-self属性的取值有auto，flex-start，flex-end，center，baseline，stretch，每一个值的意思就是上面所说到的意思我们可以通过看一个例子演示来形象的理解该属性的效果其中，在父容器中设置了justify-content:center与align-items:center使所有项目居中显示，然后给第二个项目设置了align-self:flex-start使其从顶端开始排列，给第三个项目设置了align-self:flex-end使其从底端开始排列，同时覆盖了原来的align-items的效果。]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bootstrap学习笔记]]></title>
    <url>%2F2018%2F08%2F29%2Fbootstrap%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言前几天为了写一个响应式开发的项目，于是学习了bootstrap这个框架，个人认为，bootstrap最强大的地方就在于它的布局，也就是栅格系统，所以在这里也贴出自己学习bootstrap时整理的笔记，着重会讲到bootstrap的栅格系统以及自己踩过的坑等等。注意，复制本文的代码并使用时，里面库的引入需要将路径改为自己的bootstrap路径 正文将要叙述的东西罗列了一下，大概有下面几点1.什么是响应式布局2.媒体查询3.bootstrap的下载与使用4.bootstrap基本模板5.bootstrap中container类–第1个类6.bootstrap中container-fluid类–第2个类7.bootstrap的栅格系统8.bootstrap响应式工具(响应式工具类)9.bootstrap导航条10.bootstrap的collapse(折叠)组件11.bootstrap轮播图12.bootstrap中的Affix(吸顶)组件13.总结：bootstrap常用类ps:上面只是介绍了bootstrap中很少的一部分，更多有关bootstrap内容请移步bootstrap官方中文文档 1.什么是响应式布局前面提到过，用到bootstrap的目的是用来做一个响应式的项目。那么，什么是响应式开发呢？百度百科给出的响应式布局的概念如下： 响应式布局是Ethan Marcotte在2010年5月份提出的一个概念，简而言之，就是一个网站能够兼容多个终端——而不是为每个终端做一个特定的版本。这个概念是为解决移动互联网浏览而诞生的。 响应式布局可以为不同终端的用户提供更加舒适的界面和更好的用户体验，而且随着目前大屏幕移动设备的普及，用“大势所趋”来形容也不为过。随着越来越多的设计师采用这个技术，我们不仅看到很多的创新，还看到了一些成形的模式。 不出意料，百科里面给出的定义不去仔细研读的话好像是不怎么看得懂，下面我给翻译一下：什么叫做一个网站能够兼容多个终端，我们来看两张图（给个面子，忽略排版问题）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们只看数字的部分，左面这张图是屏幕宽度1270px时候显示的样子，可以看出是一行有三个数字，右面这张是屏幕宽度为375px时候的显示效果，可以看出现在是一行一个数字，而不是一行三个数字了。所以，什么是一个网站能够兼容多个终端，我自己的理解是这样的：一个网站（网页），在不同浏览的屏幕宽度下显示的效果不同，达到了只需要写一个网站，就可以在电脑屏幕，平板屏幕，手机屏幕等多种设备（终端）上均能正常的浏览，而不是单独的针对电脑屏幕写一个网站，针对平板的屏幕大小再写一个网站，很大程度上简化了工作量。至于定义后面的针对移动互联网浏览而诞生的这点，涉及到了移动端的知识，后见会讲。好了，到这里应该会理解了什么是响应式，那么如何来实现响应式呢？这就用到了媒体查询。 2.媒体查询读到这里我们应该已经了解了什么是响应式开发，而媒体查询就是用来实现响应式开发的一种“工具”，下面我们来介绍通过css的media来实现媒体查询，具体的格式为 @media mediatype and|not|only (media feature) { CSS-Code; } 首先如同声明一个css动画一样，我们用@media声明一个媒体查询，其中mediatype表示媒体查询的类型，这里引用一下菜鸟教程对该参数的解释 值 描述 all 用于所有设备 aural 已废弃。用于语音和声音合成器 braille 已废弃。 应用于盲文触摸式反馈设备 embossed 已废弃。 用于打印的盲人印刷设备 handheld 已废弃。 用于掌上设备或更小的装置，如PDA和小型电话 print 用于打印机和打印预览 projection 已废弃。 用于投影设备 screen 用于电脑屏幕，平板电脑，智能手机等。 speech 应用于屏幕阅读器等发声设备 tty 已废弃。 用于固定的字符网格，如电报、终端设备和对字符有限制的便携设备 tv 已废弃。 用于电视和网络电视 注意对screen即屏幕的查询是我们的重点后面的and|not|only表示查询的条件，一般常用and，注意and后面有一个空格，后面在括号内写入媒体查询起作用时满足的条件，如果想有多个条件(css样式)，可以写成下面这个样子 @media mediatype and (condition1) and (condition2) ... { CSS-Code; } 在大括号内可以写入css代码，以实现媒体查询。在bootstrap官方文档中，将目前市面上主流的屏幕宽度分为四类，分界线为1200px，992px，768px，即1200px以上是大屏，也就是我们电脑或者显示器的屏幕，992px~1200px为中屏，一般是桌面显示器，768px~992px是小屏幕，一般是平板等，再往下小于768px的就是移动端也就是我们的手机了，所以，针对这四种设备写出来的媒体查询是这样子的 /*大屏设备 1200px以上*/ /*满足条件的时候会生效*/ @media screen and (min-width: 1200px){ } /*中屏设备 992px - 1200px*/ @media screen and (min-width: 992px) and (max-width: 1200px){ } /*小屏设备 768px - 992px*/ @media screen and (min-width: 768px) and (max-width: 992px){ } /*超小屏设备 768px以下*/ @media screen and (max-width: 768px){ } /*媒体查询*/ /* 关键字 查询的是screen屏幕 条件以and连接 and后面必须有空格 &quot;()&quot;里面放条件(css样式) @media screen and (min-width: 1200px){ 写css样式 } */ 以上就是媒体查询的基本内容了，下面给出一个实例代码，可以复制下来自己运行观察在不同的屏幕宽度下显示的效果(代码里meta标签里面对viewport的声明会在移动端专题里面讲到)示例代码： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;媒体查询&lt;/title&gt; &lt;style&gt; body{ margin: 0; padding: 0; } .container{ width: 1200px; height: 1200px; margin: 0 auto; background-color:black; } span.container1{ font-size: 50px; font-weight: bold; color: red; display: block; top: 50%; /*一种水平居中和垂直居中的方法*/ position: absolute; right: 50%; transform: translate(50%,50%); /*另一种水平居中的方法 display:block; margin: 0 auto; /**!*/ } /*大屏设备 1200px以上*/ /*满足条件的时候会生效*/ @media screen and (min-width: 1200px){ .container{ width: 1170px; background-color: yellow; } span.container1{ color: green; } } /*中屏设备 992px - 1200px*/ @media screen and (min-width: 992px) and (max-width: 1200px){ .container{ width: 970px; background-color: green; } span.container1{ color: black; } } /*小屏设备 768px - 992px*/ @media screen and (min-width: 768px) and (max-width: 992px){ .container{ width: 750px; background-color: blue; } span.container1{ color: maroon; } } /*超小屏设备 768px以下*/ @media screen and (max-width: 768px){ .container{ background-color: purple; width: 100%; } span.container1{ color: white; } } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;container&quot;&gt;&lt;/div&gt; &lt;span class=&quot;container1&quot;&gt;媒体查询&lt;/span&gt; &lt;/body&gt; &lt;/html&gt; 看完这段代码大家会不会有一个问题：如果每一种设备都需要写一次代码的话那四种设备不是要写四份代码吗？这样如何能体现减少了代码量的地方呢？这个问题，即将在下面的bootstrap使用中得到解决，接着学习第3节吧~ 3.bootstrap的下载与使用前言好了，到这里大家已经知道了什么是响应式布局以及如何利用媒体查询来实现响应式布局了，那么，上面我们也提出过问题：每一种设备（终端）都写一份代码并没有体现出代码量优化的特点。那么从这节开始我会写如何利用bootstrap来完成响应式布局，大大降低你的工作量。本节内容：bootstrap的下载与使用在官网给出的文档中我们可以看到，其给我们提供了三种下载方式，如下：我们需要的就是第一种也就是用于生产环境的bootstrap，点击下载bootstrap，解压，即可得到bootstrap的css，js和fonts字体文件。接下来就是使用bootstrap了 4.bootstrap基本模板想要bootstrap能正常运行，必须需要一个bootstrap的基本模板，说白了就是一个html文件，需要在其中引入特定的内容，否则bootstrap使用的时候不会有任何效果，下面是官方文档给出的bootstrap基本模板 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt; &lt;title&gt;Bootstrap 101 Template&lt;/title&gt; &lt;!-- Bootstrap --&gt; &lt;link href=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;!-- HTML5 shim 和 Respond.js 是为了让 IE8 支持 HTML5 元素和媒体查询（media queries）功能 --&gt; &lt;!-- 警告：通过 file:// 协议（就是直接将 html 页面拖拽到浏览器中）访问页面时 Respond.js 不起作用 --&gt; &lt;!--[if lt IE 9]&gt; &lt;script src=&quot;https://cdn.bootcss.com/html5shiv/3.7.3/html5shiv.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/respond.js/1.4.2/respond.min.js&quot;&gt;&lt;/script&gt; &lt;![endif]--&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;你好，世界！&lt;/h1&gt; &lt;!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) --&gt; &lt;script src=&quot;https://cdn.bootcss.com/jquery/1.12.4/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 --&gt; &lt;script src=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 下面对这段代码进行一下分析和解释 &lt;!--html5文档申明--&gt; &lt;!DOCTYPE html&gt; &lt;!--使用中文简体语言声明--&gt; &lt;html lang=&quot;zh-CN&quot;&gt; &lt;!--台湾--&gt; &lt;!--&lt;html lang=&quot;zh-tw&quot;&gt;--&gt; &lt;head&gt; &lt;!--当前文档的编码声明--&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;!--指明当前IE浏览器按最新的渲染引擎edge来渲染页面--&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;!--视口：视口的宽度和设备一致，默认缩放比是1.0，不允许用户自行缩放--&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, user-scalable = 0&quot;&gt; &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt; &lt;!--页面自上向下解析 优先告诉浏览器用最新的引擎来渲染，并且告诉浏览器这是一个移动端页面--&gt; &lt;title&gt;03 bootstrap基本模板&lt;/title&gt; &lt;!-- Bootstrap --&gt; &lt;!--引入bootstrap的核心样式库--&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../lib/bootstrap-3.3.7-dist/css/bootstrap.min.css&quot;&gt; &lt;!-- HTML5 shiv 和 Respond.js 是为了让 IE8 支持 HTML5 元素和媒体查询（media Queries）功能 --&gt; &lt;!--HTML5 shiv 解决标签兼容问题--&gt; &lt;!--Respond.js 解决媒体查询兼容问题--&gt; &lt;!-- 警告：通过 file:// 协议（就是直接将 html 页面拖拽到浏览器中）访问页面时 Respond.js 不起作用 --&gt; &lt;!--条件注释 IE9以下生效--&gt; &lt;!--[if lt IE 9]&gt; &lt;script src=&quot;../lib/html5shiv-master/dist/html5shiv.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../lib/Respond-master/dest/respond.min.js&quot;&gt;&lt;/script&gt; &lt;![endif]--&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;你好，世界！&lt;/h1&gt; &lt;!--bootstrap是基于jQuery进行开发的--&gt; &lt;!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) --&gt; &lt;script src=&quot;../lib/jQuery library/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; &lt;!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 --&gt; &lt;script src=&quot;../lib/bootstrap-3.3.7-dist/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 5.bootstrap中container类–第1个类在完成bootstrap的模板以后，我们就可以开始利用bootstrap来进行响应式网页的开发了，首先，我们来介绍bootstrap中的一个类–container，也是我们学习bootstrap的第一个类。首先来看一下container类的源代码 .container { padding-right: 15px; padding-left: 15px; margin-right: auto; margin-left: auto; } @media (min-width: 768px) { .container { width: 750px; } } @media (min-width: 992px) { .container { width: 970px; } } @media (min-width: 1200px) { .container { width: 1170px; } } 可以看出，通过媒体查询，以1200px，992px，768px三个分界点使container类在不同屏幕宽度的终端上面分为三种不同的宽度，而container类设置的margin: 0 auto;(等价于margin-right: auto;margin-left: auto;)意味着包含在container类里面的内容可以水平居中显示。注意container类还有左右内边距各15px宽度，这也意味着如果我们不消除内边距，container类里面的内容是不会充满整个屏幕的，下面我们通过媒体查询来使container类里面的内容在不同屏宽下面展示出不同的效果，代码如下： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, user-scalable = 0&quot;&gt; &lt;title&gt;03 bootstrap基本模板&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../lib/bootstrap-3.3.7-dist/css/bootstrap.min.css&quot;&gt; &lt;!--[if lt IE 9]&gt; &lt;script src=&quot;../lib/html5shiv-master/dist/html5shiv.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../lib/Respond-master/dest/respond.min.js&quot;&gt;&lt;/script&gt; &lt;![endif]--&gt; &lt;style&gt; .container{ height: 480px; } /*移动端设备 768px以下 */ @media (max-width: 767px) { .container { width: 480px; background-color: red; } } /*小屏（平板）设备 768px -- 991px */ @media (min-width: 768px) { .container { width: 750px; background-color: yellow; } } /*中屏设备（桌面显示器） 992px -- 1199px*/ @media (min-width: 992px) { .container { width: 970px; background-color: #2b542c; } } /*大屏设备（显示器） 1200px以上*/ @media (min-width: 1200px) { .container { width: 1170px; background-color: purple; } } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!--响应式容器--&gt; &lt;div class=&quot;container&quot;&gt; &lt;/div&gt; &lt;script src=&quot;../lib/jQuery library/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../lib/bootstrap-3.3.7-dist/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 注意默认情况下container类是没有高度的，所以必须为其设置高度或者利用子元素将其高度撑开才能使其可见下面是在不同屏幕宽度下显示的效果首先是大屏设备下(1200px以上)，背景颜色为紫色中屏设备的显示效果（992px~1200px）：小屏设备显示的效果（768px~992px）：然后是移动端设备（超小屏）的显示效果:最后我们再来看一下container类自带的左右15px的内边距 6.bootstrap中container-fluid类–第2个类fluid意思是液体的，流动的，那么在bootstrap里面。如果说container是一个响应式容器的话，那么container-fluid是一个流式容器(ps:流式布局也是移动端常用的一种适配方式，这里不做解释)。它与container类的直观区别可以从下图看出：可以看出container容器是居中显示的，而container-fluid容器是布满了屏幕的宽度，我们再来看container-fluid的代码： .container-fluid { padding-right: 15px; padding-left: 15px; margin-right: auto; margin-left: auto; } 当然这一点也可以从图上直观的看出总结一下，container类和container-fluid类是利用bootstrap时候必须为页面内容和栅格系统包裹的两个容器，其中，因为container类在不同的屏宽下设置了不同的宽度，所以container类用于固定宽度并支持响应式布局的容器。而container-fluid类因为没有设置宽度，但默认为100%，所以说其用于100% 宽度，占据全部视口（viewport）的流式容器。 7.bootstrap的栅格系统前言从这节开始进入到bootstrap的学习当中比较重要的一个环节，毕竟bootstrap的一个亮点就在于它的栅格系统布局方式非常灵活。学会使用bootstrap的栅格系统以后，利用其便能快速的达到一些常见的布局。 正文bootstrap的栅格系统本质上是通过浮动(float属性)与宽度百分比来实现的，同时也能通过调用不同的类来针对不同的屏幕尺寸达到适配，前面也提到过，bootstrap将屏幕尺寸分为四类，分别是超小屏幕&lt;768px，小屏幕 平板&gt;=768px，中等屏幕 桌面显示器&gt;=992px以及大屏幕 大桌面显示器&gt;=1200px(当然如果你对媒体查询以及min-width,max-width等属性非常熟悉的话，也可以定制自己的响应式网站，bootstrap在这方面也能让你自定义 Bootstrap 组件、Less 变量和 jQuery 插件，从而定制一份属于自己的bootstrap版本)，在bootstrap里面，大屏设备简写为lg，中屏设备为md，小屏设备为sm，超小屏设备也就是移动端设备为xs。我们首先来介绍一个类–.row，row是行的意思，先来看一下它的源代码： .row { margin-right: -15px; margin-left: -15px; } 非常简单的两行代码，左右两边各有-15px的外边距。.row类，也就是栅格系统里的“行”必须要包含在.container类或者.container-fluid类里面，它的作用有两个：(1)消除.container类或者.container-fluid类的内边距(2)实现栅格系统布局的基础（有了行才能有列）解释一下(1)：.row类左右各有15px的负边距，所以当将其包含在.container类或者.container-fluid类中的时候，可以去掉.container类或者.container-fluid类的15px的内边距。请看下面实例 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, user-scalable = 0&quot;&gt; &lt;title&gt;03 bootstrap基本模板&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../lib/bootstrap-3.3.7-dist/css/bootstrap.min.css&quot;&gt; &lt;!--[if lt IE 9]&gt; &lt;script src=&quot;../lib/html5shiv-master/dist/html5shiv.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../lib/Respond-master/dest/respond.min.js&quot;&gt;&lt;/script&gt; &lt;![endif]--&gt; &lt;style&gt; .container{ width: 100%; } .container &gt; .row{ height: 200px; background-color: purple; } .container &gt; .div{ height: 200px; background-color: yellow; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;div&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;../lib/jQuery library/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../lib/bootstrap-3.3.7-dist/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 效果：在栅格系统中，所有的内容都放在列(column)中，注意，只有列(column)可以作为行(row)的直接子元素下面我们来介绍栅格系统中列的使用，即.col-xx-xx类(“xx”表示参数)bootstrap.col-xx-xx类：第一个参数（第一个“xx”） 取值 含义 作用范围 lg 大屏(1200px+) 大屏生效 md 中屏(992px~1200px) 中屏及以上生效 sm 小屏(768px~992px) 小屏及以上生效 xs 超小屏(768px以下) 超小屏及以上生效 第二个参数（第二个“xx”）bootstrap默认会把一行分成12等份，也就是一行最多有12列，第二个参数表示的是当前的元素占12等份当中的几份，比如说col-md-4中4就表示在中屏以上的屏宽的时候占12份中的4份，也就是三分之一的宽度范围：1-12下面是代码示例： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, user-scalable = 0&quot;&gt; &lt;title&gt;03 bootstrap基本模板&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../lib/bootstrap-3.3.7-dist/css/bootstrap.min.css&quot;&gt; &lt;!--[if lt IE 9]&gt; &lt;script src=&quot;../lib/html5shiv-master/dist/html5shiv.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../lib/Respond-master/dest/respond.min.js&quot;&gt;&lt;/script&gt; &lt;![endif]--&gt; &lt;style&gt; body{ background-color: #bce8f1; } .container &gt; .row{ height: 80px; background-color: yellow; } .first-row &gt; div{ margin-top: 15px; height: 50px; border: 1px solid #ffffff; background-color: black; box-sizing: border-box; line-height: 50px; text-align: center; font-size: 1.5vw; color: white; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;first-row&quot;&gt; &lt;div class=&quot;col-lg-2&quot;&gt;2份&lt;/div&gt; &lt;div class=&quot;col-lg-6&quot;&gt;6份&lt;/div&gt; &lt;div class=&quot;col-lg-1&quot;&gt;1份&lt;/div&gt; &lt;div class=&quot;col-lg-3&quot;&gt;3份&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;second-row&quot;&gt;&lt;/div&gt; &lt;div class=&quot;third-row&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;../lib/jQuery library/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../lib/bootstrap-3.3.7-dist/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 效果如下：可以很清楚的看到一行被分成为12份。且2+6+1+3 == 12，当然，如果和大于12，那么多余的列便会被挤下来，到下面一行 &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;first-row&quot;&gt; &lt;div class=&quot;col-lg-2&quot;&gt;2份&lt;/div&gt; &lt;div class=&quot;col-lg-6&quot;&gt;6份&lt;/div&gt; &lt;div class=&quot;col-lg-1&quot;&gt;1份&lt;/div&gt; &lt;div class=&quot;col-lg-4&quot;&gt;4份&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;second-row&quot;&gt;&lt;/div&gt; &lt;div class=&quot;third-row&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 上面只是在调用了.col-lg-xx相关类，也就是说上面的示例代码只能在大屏下才有效果，放到其余三类尺寸的屏幕下只会默认占满整行，就像下面这样当我们进行完上面的简单的使用栅格系统布局之后，bootstrap还为我们提供了其他的辅助布局的类操作，具体见下表(引自bootstrap官方文档)：槽宽(gutter)即为列与列之间的间隔，通过为列设置padding属性来实现。从表中我们看到，bootstrap还为我们提供了几种实现更为复杂的布局的方式：(1)列嵌套(2)列偏移(offsets)(3)列排序下面来逐条介绍:(1)列嵌套顾名思义，列嵌套就是列与列之间的嵌套，也就是我们可以在一列中再放置12份内容，具体做法：可以通过添加一个新的.row元素和一系列.col-xx-xx元素到已经存在的.col-xx-xx元素内。我们拿实例来说话，代码如下： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, user-scalable = 0&quot;&gt; &lt;title&gt;03 bootstrap基本模板&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../lib/bootstrap-3.3.7-dist/css/bootstrap.min.css&quot;&gt; &lt;!--[if lt IE 9]&gt; &lt;script src=&quot;../lib/html5shiv-master/dist/html5shiv.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../lib/Respond-master/dest/respond.min.js&quot;&gt;&lt;/script&gt; &lt;![endif]--&gt; &lt;style&gt; body{ background-color: #bce8f1; } .container &gt; .row{ height: 80px; background-color: yellow; } .first-row &gt; div{ margin-top: 15px; height: 50px; border: 1px solid #ffffff; background-color: black; box-sizing: border-box; line-height: 50px; text-align: center; font-size: 1.5vw; color: white; } .first-row &gt; div .row{ height: 30px; margin-top: 10px; font-size: 1vw; font-weight: 900; } .first-row &gt; div .row div{ border: 1px solid #ffffff; background-color: purple; box-sizing: border-box; line-height: 30px; text-align: center; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;first-row&quot;&gt; &lt;div class=&quot;col-lg-2&quot;&gt;2份&lt;/div&gt; &lt;div class=&quot;col-lg-6&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-lg-7&quot;&gt;嵌套7份&lt;/div&gt; &lt;div class=&quot;col-lg-2&quot;&gt;嵌套2份&lt;/div&gt; &lt;div class=&quot;col-lg-3&quot;&gt;嵌套3份&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col-lg-1&quot;&gt;1份&lt;/div&gt; &lt;div class=&quot;col-lg-3&quot;&gt;3份&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;second-row&quot;&gt;&lt;/div&gt; &lt;div class=&quot;third-row&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;../lib/jQuery library/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../lib/bootstrap-3.3.7-dist/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 实现的效果如下：同样，我们还可以再在里面嵌套列，但是要注意一点：列必须基于行，所以必须将列元素作为.row类直接子元素才会有作用(2)列偏移(offsets)列偏移的意思是，我们可以通过对特定的类的调用，来达到对某一列在其原来位置的基础上向右偏移特定的距离(注意这里距离只能为整数，范围为1~12)，下面请看例子 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, user-scalable = 0&quot;&gt; &lt;title&gt;03 bootstrap基本模板&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../lib/bootstrap-3.3.7-dist/css/bootstrap.min.css&quot;&gt; &lt;!--[if lt IE 9]&gt; &lt;script src=&quot;../lib/html5shiv-master/dist/html5shiv.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../lib/Respond-master/dest/respond.min.js&quot;&gt;&lt;/script&gt; &lt;![endif]--&gt; &lt;style&gt; body{ background-color: #bce8f1; } .container &gt; .row{ background-color: yellow; } .first-row &gt; div{ margin-top: 15px; height: 50px; border: 1px solid #ffffff; background-color: black; box-sizing: border-box; line-height: 50px; text-align: center; font-size: 1.5vw; color: white; } .first-row &gt; div .row{ height: 30px; margin-top: 10px; font-size: 1vw; font-weight: 900; } .first-row &gt; div .row div{ border: 1px solid #ffffff; background-color: purple; box-sizing: border-box; line-height: 30px; text-align: center; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;first-row&quot; style=&quot;overflow: hidden&quot;&gt; &lt;div class=&quot;col-lg-2&quot;&gt;2份&lt;/div&gt; &lt;div class=&quot;col-lg-6&quot;&gt;6份&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;first-row&quot;&gt; &lt;div class=&quot;col-lg-2&quot;&gt;2份&lt;/div&gt; &lt;div class=&quot;col-lg-6 col-lg-offset-4&quot; id=&quot;lg-offset-6&quot;&gt;6份&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;../lib/jQuery library/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../lib/bootstrap-3.3.7-dist/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 效果如下图：我们从代码里可以看出，.row类下面的两个div的样式几乎一样，所不同的是，第二个div中填加了.col-lg-offset-4类，致使第二个div下面id=”lg-offset-6”的块元素向右平移了4份的距离，直接与右边对齐。本质上，.col-xx-offset-4(“xx”表示屏幕尺寸)是添加了左边距才使得元素能向右偏移，我们从bootstrap的代码中能很清晰的看出这一点 .col-xs-offset-12 { margin-left: 100%; } .col-xs-offset-11 { margin-left: 91.66666667%; } .col-xs-offset-10 { margin-left: 83.33333333%; } .col-xs-offset-9 { margin-left: 75%; } 上面的例子只是给出了在大屏也就是lg的情况下的偏移，其余情况可以自己将代码复制下去进行改动验证。(3)列排序在默认的情况下，列的排序会按照我们代码规定的顺序，写在前面的排在前面，写在后面的排在后面，这里用到上面的例子 &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;first-row&quot;&gt; &lt;div class=&quot;col-lg-2&quot;&gt;2份&lt;/div&gt; &lt;div class=&quot;col-lg-6&quot;&gt;6份&lt;/div&gt; &lt;div class=&quot;col-lg-1&quot;&gt;1份&lt;/div&gt; &lt;div class=&quot;col-lg-4&quot;&gt;4份&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;second-row&quot;&gt;&lt;/div&gt; &lt;div class=&quot;third-row&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 如图和代码所示，列从左到有的顺序默认按照2，6，1，4，这样进行排序，而bootstrap给我们提供了相关类可以改变列与列之间默认的排序方式，即.col-xx-xx-xx类。.col-xx-xx-xx类，第一个参数表示屏幕尺寸，老规矩，有lg，md，sm，xs四种取值，第二个参数代表方向，有push与pull两个取值，其中push(推)，方向向右，pull(拉)，方向为左，第三个参数表示向左拉或者向右推的列数，取值为1~12，下面来举例描述首先代码如下: &lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, user-scalable = 0&quot;&gt; &lt;title&gt;05 栅格系统&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../lib/bootstrap-3.3.7-dist/css/bootstrap.css&quot;&gt; &lt;!--[if lt IE 9]&gt; &lt;script src=&quot;../lib/html5shiv-master/dist/html5shiv.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../lib/Respond-master/dest/respond.min.js&quot;&gt;&lt;/script&gt; &lt;![endif]--&gt; &lt;style&gt; body,h1,h2,h3,h4,h5,h6,p,span{ margin: 0; padding: 0; } .container{ height: 360px; background-color: #bce8f1; } /*只选择某个元素的子元素用 &quot;&gt;&quot; */ .container &gt; .row{ height: 100px; background-color: yellow; } .container &gt; .row &gt; div{ font-size: 1.5vw; color: white; text-align: center; line-height: 50px; height: 50px; border: 1px solid #cccccc; background-color: green; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!--响应式容器--&gt; &lt;div class=&quot;container&quot;&gt; &lt;!--栅格系统--&gt; &lt;div class=&quot;row&quot;&gt; &lt;!--列--&gt; &lt;!--排序前--&gt; &lt;div class=&quot;col-xs-3&quot;&gt;3&lt;/div&gt; &lt;div class=&quot;col-xs-4&quot;&gt;4&lt;/div&gt; &lt;div class=&quot;col-xs-5&quot;&gt;5&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;!--列--&gt; &lt;!--列排序--&gt; &lt;div class=&quot;col-xs-3 col-xs-push-5&quot;&gt;3&lt;/div&gt; &lt;div class=&quot;col-xs-4 col-xs-push-5&quot;&gt;4&lt;/div&gt; &lt;div class=&quot;col-xs-5 col-xs-pull-7&quot;&gt;5&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;../lib/jQuery library/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../lib/bootstrap-3.3.7-dist/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 第一个含有.row类的div没有调用其他类，所以展现出来的效果就是默认的排序3,4,5，而第二个含有.row类的div通过调用.col-xx-push-xx类与.col-xx-pull-xx类实现了5,3,4的排序效果，我们可以来看一下这类类的代码，以更好了解他们的作用 .col-sm-pull-1 { right: 8.33333333%; } .col-sm-pull-0 { right: auto; } .col-sm-push-12 { left: 100%; } 可以看出，实现列排序的本质也是通过对左右边距的距离进行定位，从而达到列向左或者向右平移指定距离的效果，在上面的例子中，3份的div向右平移5个单位，4份的div向右平移4个单位，5份的div向左平移了7个单位，且因为使用了xs，所以在超小屏及以上屏幕尺寸均可以适配这种做法。 8.bootstrap响应式工具(响应式工具类)前言利用bootstrap进行响应式开发是非常方便的，只需要用.container类作为第一级父容器，将其余的北荣均放在.container下面作为其子元素就能达到适配不同终端的要求，当然，想要达到在不同终端下面显示的效果不一样，上面写的内容还并不能做到如此多元化的效果，所以在这节我们将会介绍其他的bootstrap提供的响应式工具(类)，通过调用不同的类来达到在不同终端有不同效果的要求。 正文关于bootstrap响应式工具(类)，我主要记录了两种(1).visible-xx-xx类(2).hidden-xx类分别控制了在不同的屏幕尺寸下的显示和隐藏(1).visible-xx-xx类.visible-xx-xx类，第一个参数同样代表了屏幕的尺寸，有四种取值，lg，md，sm与xs，分别代表了在大屏可见，中等屏幕可见，小屏幕可见以及超小屏幕可见(注意此时每一种尺寸只代表了当前屏幕的尺寸，在其之上的尺寸范围并不适用，也就是说，.visible-xs-xx只代表了能在超小屏幕可见，而不是超小屏幕即以上均可见).visible-xx-xx类，第二个参数有三种取值，分别为block，inline，inline-block，与CSS中的display:block，display:inline，display:inline-block相对应，bootstrap中也给我们列出了.visible-xx-xx类的相关取值，如下图:至于单独的使用.visible-xs、.visible-sm、.visible-md、.visible-lg类也不是不可以，但是从v3.2.0版本开始不建议使用，控制元素的隐藏与显示更加常用.hidden-xx相关类。当然visiblex相关类的取值不止上面这些，有兴趣可以去读一读bootstrap的源码，里面有详细的代码说明。(2).hidden-xx类相对于.visible-xx-xx相关类，.hidden-xx相关类相对来说更加常用而且比较好理解，它一共只用四种取值，分别是.hidden-xs，.hidden-sm，.hidden-md，.hidden-lg，分别代表了在超小屏，小屏，中屏以及大屏隐藏，关于这个我们可以参考bootstrap给出的官方文档OK，介绍完了相关类的取值以及他们的含义，我们来看一下下面这个代码 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, user-scalable = 0&quot;&gt; &lt;title&gt;06 响应式工具&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../lib/bootstrap-3.3.7-dist/css/bootstrap.min.css&quot;&gt; &lt;!--[if lt IE 9]&gt; &lt;script src=&quot;../lib/html5shiv-master/dist/html5shiv.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../lib/Respond-master/dest/respond.min.js&quot;&gt;&lt;/script&gt; &lt;![endif]--&gt; &lt;style&gt; .container{ height: 240px; background-color: #00CCFF; font-size: 2vw; } header{ height: 80px; background-color: purple; text-align: center; color: #ffffff; line-height: 80px; } section{ height: 80px; background-color: yellow; text-align: center; color: #000000; line-height: 80px; } footer{ height: 80px; background-color: #2b542c; text-align: center; color: white; line-height: 80px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 需求： 1.在大屏设备 显示 头 内容 脚 2.在中屏设备 显示 内容 脚 3.在小屏设备 显示 内容 4,在超小屏设备 显示 nothing --&gt; &lt;!--使用 响应式工具类--&gt; &lt;div class=&quot;container&quot;&gt; &lt;!--头 只在大屏的时候显示，中屏，小屏，超小屏均隐藏--&gt; &lt;header class=&quot;hidden-md hidden-sm hidden-xs visible-lg&quot;&gt;头&lt;/header&gt; &lt;!--内容 在超小屏不显示，大屏中屏小屏显示--&gt; &lt;section class=&quot;hidden-xs&quot;&gt;内容&lt;/section&gt; &lt;!--脚 在小屏和超小屏不显示--&gt; &lt;footer class=&quot;hidden-sm hidden-xs&quot;&gt;脚&lt;/footer&gt; &lt;/div&gt; &lt;script src=&quot;../lib/jQuery library/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../lib/bootstrap-3.3.7-dist/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 对应不同屏幕尺寸显示的效果如图:大屏：中屏：小屏：超小屏：同时贴出相关.hidden-xx类代码以供理解 @media (max-width: 767px) { .hidden-xs { display: none !important; } } @media (min-width: 768px) and (max-width: 991px) { .hidden-sm { display: none !important; } } @media (min-width: 992px) and (max-width: 1199px) { .hidden-md { display: none !important; } } @media (min-width: 1200px) { .hidden-lg { display: none !important; } } 9.bootstrap导航条从这里开始，包括下面的内容，基本上就是介绍bootstrap的一些常用组件，首先来看bootstrap的导航条。从bootstrap中拿到它的导航条运用到我们自己设计的网页中，往往导航条的样式并不是bootstrap给出的默认的样式，所以我们需要去读懂导航条部分的代码以便我们能更准确的进行修改以达到我们期望的效果。使用bootstrap提供的导航栏的时候，可以直接使用HTML5nav标签，当然也可以使用div标签，bootstrap官方文档中提示我们使用div标签的时候，需要加上role=”navigation”属性，role属性的作用是为了能使盲人用户知道当前浏览的是什么界面，然而在国内由于这方面还未普及，所以我们也可以不需要role=”navigation”属性，直接使用div标签即可，但为了更加明确，建议使用nav标签。这里我们通过bootstrap给出的样例代码来进行一步步的解释 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-CN&quot;&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, user-scalable = 0&quot;&gt; &lt;title&gt;08 bootstrap导航条&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../lib/bootstrap-3.3.7-dist/css/bootstrap.css&quot;&gt; &lt;!--[if lt IE 9]&gt; &lt;script src=&quot;../lib/html5shiv-master/dist/html5shiv.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../lib/Respond-master/dest/respond.min.js&quot;&gt;&lt;/script&gt; &lt;![endif]--&gt; &lt;/head&gt; &lt;body&gt; &lt;!--导航条 默认样式的导航条 navbar-default --&gt; &lt;nav class=&quot;navbar navbar-default&quot;&gt; &lt;!--响应式容器--&gt; &lt;div class=&quot;container&quot;&gt; &lt;!--商标logo 与 切换按钮 只会在移动端显示(媒体查询) --&gt; &lt;!-- Brand and toggle get grouped for better mobile display --&gt; &lt;div class=&quot;navbar-header&quot;&gt; &lt;!--切换按钮--&gt; &lt;!-- data-toggle=&quot;collapse&quot; 声明折叠组件 data-target=&quot;#bs-example-navbar-collapse-1&quot; 控制id=&quot;bs-example-navbar-collapse-&quot;的元素 屏幕阅读器 辅助性的阅读设备（例如盲人用户） aria-expanded=&quot;false&quot; aria- 都是给屏幕阅读器使用的 &lt;span class=&quot;sr-only&quot;&gt;Toggle navigation&lt;/span&gt; 也和屏幕阅读器有关系 sr-only &lt;==&gt; screen read only 服务盲人用户阅读 role 同样是给屏幕阅读器使用的 用来表明当前元素的功能，作用是什么 --&gt; &lt;button type=&quot;button&quot; class=&quot;navbar-toggle collapsed&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#bs-example-navbar-collapse-1&quot; aria-expanded=&quot;false&quot;&gt; &lt;span class=&quot;sr-only&quot;&gt;Toggle navigation&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;/button&gt; &lt;!--商标logo区域--&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;Brand&lt;/a&gt; &lt;/div&gt; &lt;!-- 切换按钮控制要切换的内容 --&gt; &lt;!-- Collect the nav links, forms, and other content for toggling --&gt; &lt;div class=&quot;collapse navbar-collapse&quot; id=&quot;bs-example-navbar-collapse-1&quot;&gt; &lt;ul class=&quot;nav navbar-nav&quot;&gt; &lt;!--active 当前选中--&gt; &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;Link &lt;span class=&quot;sr-only&quot;&gt;(current)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;!--下拉菜单--&gt; &lt;li class=&quot;dropdown&quot;&gt; &lt;!--data-toggle=&quot;dropdown声明了一个下拉组件 a下面的ul就是被控制的元素（控制其显示与隐藏）--&gt; &lt;a href=&quot;#&quot; class=&quot;dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; role=&quot;button&quot; aria-haspopup=&quot;true&quot; aria-expanded=&quot;false&quot;&gt;Dropdown &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt;&lt;/a&gt; &lt;ul class=&quot;dropdown-menu&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Another action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Something else here&lt;/a&gt;&lt;/li&gt; &lt;li role=&quot;separator&quot; class=&quot;divider&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Separated link&lt;/a&gt;&lt;/li&gt; &lt;li role=&quot;separator&quot; class=&quot;divider&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;One more separated link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;form class=&quot;navbar-form navbar-left&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;Search&quot;&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;Submit&lt;/button&gt; &lt;/form&gt; &lt;ul class=&quot;nav navbar-nav navbar-right&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;dropdown&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; role=&quot;button&quot; aria-haspopup=&quot;true&quot; aria-expanded=&quot;false&quot;&gt;Dropdown &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt;&lt;/a&gt; &lt;ul class=&quot;dropdown-menu&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Another action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Something else here&lt;/a&gt;&lt;/li&gt; &lt;li role=&quot;separator&quot; class=&quot;divider&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Separated link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;!-- /.navbar-collapse --&gt; &lt;/div&gt;&lt;!-- /.container-fluid --&gt; &lt;/nav&gt; &lt;script src=&quot;../lib/jQuery library/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../lib/bootstrap-3.3.7-dist/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 导航条的样子是这样的首先，nav标签作为最上一级父容器，内包含.navbar，.navbar-default两个类，下面是这两个类的代码: .navbar { position: relative; min-height: 50px; margin-bottom: 20px; border: 1px solid transparent; } .navbar-default { background-color: #f8f8f8; border-color: #e7e7e7; } 可以看出只是很简单的设置了位置属性，高度，背景颜色等，其中.navbar-default表示默认样式的导航条。上面我们说过，实现响应式必有要有.container类，所以在nav下面的div调用了.container类让我们知道这是一个响应式的导航条，但是响应式的具体效果在哪，我们还要往下看。.container类下面包含两个子容器div，第一个div生声明了导航栏左边的Brand以及一个响应式的声明，我们改变窗口宽度，会发现缩小到超小屏幕范围后，导航条会消失不见，取而代之的是左上角的menu按钮，点开来看，我们会发现这个正是隐藏的导航条，为什么这样？我们看到第一个div里有navbar-header这个类，我们查看bootstrap关于此类的源代码: @media (min-width: 768px) { .navbar-header { float: left; } } 可以看出，对小屏及以上的设备，会给当行调添加float:left的效果，也就是说会完整的显示出来。那对于小屏以下的设备也就是移动端设备就会隐藏，取而代之的是那个菜单栏的按钮。下面的button里面有两个属性需要我们注意一下，即data-toggle与data-target属性。data-toggle=”collapse”声明了这是一个”collapse”即折叠组件（折叠组件下面会有）data-target=”#bs-example-navbar-collapse-1”则是指明了该折叠组件控制的元素，我们往下看，会在第二个div里面看到id=”bs-example-navbar-collapse-1，也就是说，上面的button是来控制我们下面这个第二个div的。有的小伙伴可能注意到，在我们第一个div下面有这么一句话 &lt;span class=&quot;sr-only&quot;&gt;Toggle navigation&lt;/span&gt; 但是在浏览器里面却找不到这句话在哪里。不用担心，这个.sr-only类是为了给盲人阅读该网页提供的，我们不需要去关注这个，类似这个的还有以.aria-xxx开头以及声明了role属性的均属于这种情况，我们不需要去关注，遇到的话可以直接删除以稍微的减少一下代码量（在代码注释中已经有详细的解释）。后面button区域里面定义了屏幕阅读器（没有什么作用）和移动端导航栏隐藏后显示的切换按钮 &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; 可以看出按钮是由三个span画出来的，bootstrap.css里面对.icon-bar的样式定义如下(注意display:block)： .navbar-toggle .icon-bar { display: block; width: 22px; height: 2px; border-radius: 1px; } 下面的代码与上面的较为类似就不再详述，可以自行去读一读代码并自己去理解。到这里戒指bootstrap的组件就先告一段落，因为bootstrap组件太多，所以只能选择一两个进行详细的解释，其余的我会后期慢慢补充，或者有兴趣的可以自己去bootstrap官网去看文档。 10.bootstrap的collapse(折叠)组件下面我们来介绍bootstrap的一些JavaScript组件，首先是collapse（折叠）组件。collapse插件作用：类似下拉菜单，点击显示，失焦的时候隐藏，可以节省空间的同时起到一定的美观效果下面可以看几个类似的效果：(更多的实例请到bootstrap官方文档中去寻找或者在自己浏览网页的过程中可以注意观察一下)实例代码如下： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, user-scalable = 0&quot;&gt; &lt;title&gt;09 bootstrap中的collapse插件&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../lib/bootstrap-3.3.7-dist/css/bootstrap.min.css&quot;&gt; &lt;!--[if lt IE 9]&gt; &lt;script src=&quot;../lib/html5shiv-master/dist/html5shiv.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../lib/Respond-master/dest/respond.min.js&quot;&gt;&lt;/script&gt; &lt;![endif]--&gt; &lt;/head&gt; &lt;body&gt; &lt;!--需求： 一个按钮（或者说某一个元素）能控制某一块区域的显示和隐藏--&gt; &lt;!-- data-toggle=&quot;collapse（组件）&quot; 声明折叠组件 data-target=&quot;选择器&quot; 设置需要控制的目标元素 通过选择器 对于a标签来说，需要控制的目标元素可以直接写在href属性中 即href=&quot;选择器&quot; --&gt; &lt;button data-toggle=&quot;collapse&quot; data-target=&quot;#target&quot;&gt;按钮&lt;/button&gt; &lt;a href=&quot;#target&quot; data-toggle=&quot;collapse&quot;&gt;链接&lt;/a&gt; &lt;div class=&quot;btn btn-info&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#target&quot;&gt;div按钮&lt;/div&gt; &lt;!--需要控制的区域--&gt; &lt;div id=&quot;target&quot; class=&quot;target&quot;&gt; &lt;p&gt;内容&lt;/p&gt; &lt;p&gt;内容&lt;/p&gt; &lt;p&gt;内容&lt;/p&gt; &lt;p&gt;内容&lt;/p&gt; &lt;p&gt;内容&lt;/p&gt; &lt;p&gt;内容&lt;/p&gt; &lt;p&gt;内容&lt;/p&gt; &lt;p&gt;内容&lt;/p&gt; &lt;p&gt;内容&lt;/p&gt; &lt;p&gt;内容&lt;/p&gt; &lt;p&gt;内容&lt;/p&gt; &lt;p&gt;内容&lt;/p&gt; &lt;p&gt;内容&lt;/p&gt; &lt;p&gt;内容&lt;/p&gt; &lt;p&gt;内容&lt;/p&gt; &lt;p&gt;内容&lt;/p&gt; &lt;p&gt;内容&lt;/p&gt; &lt;p&gt;内容&lt;/p&gt; &lt;/div&gt; &lt;script src=&quot;../lib/jQuery library/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../lib/bootstrap-3.3.7-dist/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 首先我们定义了三个模块，分别是一个button，一个链接a和一个div，三块控制区域都声明了collapse组件即代码中的data-toggle=”collapse”，随后data-target=”#target”声明了需要去控制的内容也就是下面id=”target”的div，其中，a标签通过href=”#target”同样可以实现对目标元素的控制，也就是说有两种方法可以实现拥有对目标div显示与隐藏的控制权，即data-target=””与a标签中的href属性。下面的div即使我们要去控制的元素，也就是说上面三块都可以控制该div的显示与隐藏。总结一下：简单的利用一个折叠组件仅需要以下几个步骤：(1)声明一个折叠组件——data-toggle=”collapse”(2)声明要控制的目标元素——data-target=””或者href=””（代码可以自行复制并运行查看效果，注意需要更改bootstrap相关文件的路径） 11.bootstrap轮播图(Carousel)轮播图是在PC端和移动端都很常见的一个效果，bootstrap为我们提供了一个简单易使用的(Carousel)轮播插件，这样我们就不需要去费力的写原生的轮播图代码了，但是我们还是需要去大概的了解一下bootstrap给出的轮播图代码结构，这样也方便我们以后自己进行去编写。下面是官方文档给出的bootstrap轮播图插件样例 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, user-scalable = 0&quot;&gt; &lt;title&gt;10 bootstrap中的轮播图 carousel&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../lib/bootstrap-3.3.7-dist/css/bootstrap.css&quot;&gt; &lt;!--[if lt IE 9]&gt; &lt;script src=&quot;../lib/html5shiv-master/dist/html5shiv.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../lib/Respond-master/dest/respond.min.js&quot;&gt;&lt;/script&gt; &lt;![endif]--&gt; &lt;body&gt; &lt;!--carousel 这是轮播图模块--&gt; &lt;!--slide 是否有切换时的平移动画--&gt; &lt;!--data-ride=&quot;carousel&quot; 声明是一个轮播图组件--&gt; &lt;div id=&quot;carousel-example-generic&quot; class=&quot;carousel slide&quot; data-ride=&quot;carousel&quot;&gt; &lt;!--指示器 --- 点盒子--&gt; &lt;!-- Indicators --&gt; &lt;ol class=&quot;carousel-indicators&quot;&gt; &lt;!-- data-target=&quot;#carousel-example-generic&quot; 需要控制的id为carousel-example-generic的轮播图 data-slide-to=&quot;0&quot; 控制轮播图中索引为0的图片 active 当前对应索引的点（被选中的图片对应的点） --&gt; &lt;li data-target=&quot;#carousel-example-generic&quot; data-slide-to=&quot;0&quot; class=&quot;active&quot;&gt;&lt;/li&gt; &lt;li data-target=&quot;#carousel-example-generic&quot; data-slide-to=&quot;1&quot;&gt;&lt;/li&gt; &lt;li data-target=&quot;#carousel-example-generic&quot; data-slide-to=&quot;2&quot;&gt;&lt;/li&gt; &lt;li data-target=&quot;#carousel-example-generic&quot; data-slide-to=&quot;3&quot;&gt;&lt;/li&gt; &lt;/ol&gt; &lt;!--图片盒子 滑动容器--&gt; &lt;!-- Wrapper for slides --&gt; &lt;div class=&quot;carousel-inner&quot;&gt; &lt;!--图片 当前默认显示的图片--&gt; &lt;div class=&quot;item active&quot;&gt; &lt;img src=&quot;../images/轮播图3.jpg&quot;/&gt; &lt;!--图片中的文字说明部分--&gt; &lt;div class=&quot;carousel-caption&quot;&gt; ... &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;img src=&quot;../images/轮播图7.jpg&quot;/&gt; &lt;div class=&quot;carousel-caption&quot;&gt; ... &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;img src=&quot;../images/轮播图8.jpg&quot;/&gt; &lt;div class=&quot;carousel-caption&quot;&gt; ... &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;img src=&quot;../images/轮播图9.jpg&quot;/&gt; &lt;div class=&quot;carousel-caption&quot;&gt; ... &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--控制轮播图平移的方向键--&gt; &lt;!-- 左边的是上一张 data-slide=&quot;prev&quot; left 右边的是下一张 data-slide=&quot;next&quot; right --&gt; &lt;!-- Controls --&gt; &lt;a class=&quot;left carousel-control&quot; href=&quot;#carousel-example-generic&quot; data-slide=&quot;prev&quot;&gt; &lt;!--bootstrap向左边的图标--&gt; &lt;span class=&quot;glyphicon glyphicon-chevron-left&quot;&gt;&lt;/span&gt; &lt;/a&gt; &lt;a class=&quot;right carousel-control&quot; href=&quot;#carousel-example-generic&quot; data-slide=&quot;next&quot;&gt; &lt;!--bootstrap向右边的图标--&gt; &lt;span class=&quot;glyphicon glyphicon-chevron-right&quot;&gt;&lt;/span&gt; &lt;/a&gt; &lt;/div&gt; &lt;script src=&quot;../lib/jQuery library/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../lib/bootstrap-3.3.7-dist/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 首先最上级的div中的属性data-ride=”carousel”声明了这是一个轮播图组件。下面的ol声明了点盒子，ol下面的每个li里面都含有data-target=”#carousel-example-generic”表明点盒子是控制的id=”carousel-example-generic”的轮播图，data-slide-to=”1”是表明了当前点盒子控制的图片的索引，class=”active”表明当前显示的图片（当前对应索引的图片，此时索引是0）下面第一个含有class=”carousel-inner”的div定义了一个图片容器，其下面每一个含有.item类的div是每一张图片的容器，里面的img标签定义了图片元素，与它同级的div定义了对每一张图片的描述，具体如下： &lt;div class=&quot;item&quot;&gt; &lt;img src=&quot;...&quot; alt=&quot;...&quot;&gt; &lt;div class=&quot;carousel-caption&quot;&gt; &lt;h3&gt;...&lt;/h3&gt; &lt;p&gt;...&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; 在下面一共有4个div也就是一共有4张图片进行轮播，与这个div同级的两个a标签是定义了往左滑和往右滑的两个箭头，注意a标签里面的href=”#carousel-example-generic”同样声明了需要去控制的轮播图容器，然后data-slide属性规定了滑动的方向，有prev与next两个取值，分别代表了前一张与后一张。a标签里面的span里面的lyphicon-chevron-right和lyphicon-chevron-left是用了bootstrap自己规定的图标，类似于fontawesome。以上就是整个轮播图的结构。 12.bootstrap中的Affix(吸顶)组件 13.总结:bootstrap常用类]]></content>
      <tags>
        <tag>bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于删除节点幕后的事情]]></title>
    <url>%2F2018%2F08%2F29%2F%E5%85%B3%E4%BA%8E%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9%E5%B9%95%E5%90%8E%E7%9A%84%E4%BA%8B%E6%83%85%2F</url>
    <content type="text"><![CDATA[前言这篇文章原来是自己写的第一篇博文，因为格式太难看于是在这里进行了一次重新的修改与发布，至于内容，emmmmmm，有兴趣就看看当做了解就好 正文当时刚学到js，当看到删除节点这节的时候，自己写了一个程序来测试，点击清除节点按钮却发现了出人意料的结果，经过长时间的思考最终参透了其中的奥秘，于是发布上来，下面是代码: &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;content&quot;&gt; &lt;h1&gt;html&lt;/h1&gt; &lt;h1&gt;php&lt;/h1&gt; &lt;h1&gt;javascript&lt;/h1&gt; &lt;h1&gt;jquery&lt;/h1&gt; &lt;h1&gt;java&lt;/h1&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; document.write(content.childNodes.length); function clearText() { var content=document.getElementById(&quot;content&quot;); // 在此完成该函数 for(var i=0;i&lt;content.childNodes.length;i++){ var childNode = content.childNodes[i]; content.removeChild(childNode); } } &lt;/script&gt; &lt;button onclick=&quot;clearText()&quot;&gt;清除节点内容&lt;/button&gt; &lt;/body&gt; &lt;/html&gt; 运行这个程序会发现，第一次点击按钮的时候没有任何反应，第二次点击按钮的时候只剩下了php与jquery两个，再点击按钮php会被删除掉，再点击按钮才会把jQuery删除掉，这是为什么呢？经过仔细观察程序以及了解删除的原理后，得到以下结论，文字比较难叙述，我会尽量往清楚去说明。因为我们使用的是chrome浏览器也就是常说的谷歌浏览器，与IE浏览器不同的是，谷歌，Firefox等浏览器不会忽略空白节点，也就是说会把空白节点当做子节点的一部分，那什么是空白节点呢？我们知道，在HTML代码里在div标签下我们可以看见5个h1标签，也就是元素节点，这是我们可见的，所以我们下意识的就会认为只有5个节点，然而实际上并不是这样，其中还有空白节点的存在，也就是回车，没错，就是你在写代码的时候按下的回车键，那我们来数一数有多少个回车键呢？如图所示我们可以看出其实一共有6个空白节点，所以一共是有11个节点，而不是我们想象的5个。那么问题来了为什么会出现如此怪异的删除效果呢要知道一切现实出来的效果斗鱼我们的代码与变量的变化有关，只要分析清楚了变量的变化，那这个效果就不难理解了，我们来看源代码。源代码的关键地方在content.childNodes.length，我们如果对这条语句进行输出，即“document.write(content.childNodes.length)”会发现得到的结果是11，如果我们形象的表示此时每个节点的排列的话，是这样子的开始循环时，i=0，条件满足，所以删掉第一个空白节点，但此时两个地方发生变化，一个是HTML的标号由于前面的空白节点被删除所以由1变为0，同时length由11变为10，此时i++变为1，因为HTML的标号已经变为0，那么他下面的第二个空白节点的标号就变为1，所以再次循环一次删除的是第二个空白节点而不是HTML，在视觉效果上就相当于没有删除。i++变为2，length变为9，因为删掉了第二个空白节点，所以php现在紧挨着HTML，标号为1（因为HTML的标号为0）此时i=2小于length=9，所以循环继续，此时删除的是标号为2的那个节点也就是php下面的节点—第三个空白节点同理删除后其后面的节点的标号向前进，在视觉效果上仍然没有删除任何东西，而此时length再一次减小，变为8，i变为3，继续循环，javascript此时的标号变为2，第四个空白节点的标号变为3，所以把第四个空白节点删掉，i为4，length为8，此时iquery由于紧挨着javascript，中间的空白节点已经删除，所以它的标号为3，它下面的第五个空白节点的标号为4，所以把第五个空白节点删掉，i=5，length=7，视觉上无变化，再进循环，java的标号已经变为4，它下面的第六个空白节点标号为5，对应i=5，删除掉，此时i=6，length=7，此时后面的没有节点，所以全部是null了，就会退出循环，第一次的点击按钮实际上是删除了所有的空白节点。 第二次点击按钮此时的length已经变为5，因为只剩下了5个元素节点，也就是5个h1标签，标号是0到4，从i=0开始循环，第一次删除掉HTML，剩下4个节点的标号都因此减一，同时length-1变为4，i变为1，再一次进行，删除掉标号由2变为1的javascript，留下了php，javascript后面的jquery和java的标号变为1和2，i变为2，length变为3，循环回来，删除掉标号为2的节点即java，length变为2，i变为3，退出循环，所以第二次点击按钮后剩下的是php和jquery 第三次点击length已经变为2，i从0开始，第一次循环删除掉php，i变为1，length变为1，jquery的标号变为0，不满足循环条件，退出for循环，第三次结束，剩下一个jquery。 第四次点击删除掉jquery，皆大欢喜。好啦，上面就是为什么我们的代码会执行出这样的效果的解释，相信大家只要能看完都能看懂的啦。那么想要一次性的删除怎么做呢？很简单，从后往前循环就好啦。代码改为： for(i=content.childNodes.length-1;i&gt;=0;i--)]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于在Mic theme配置下的一些心得]]></title>
    <url>%2F2018%2F08%2F28%2F%E5%85%B3%E4%BA%8E%E5%9C%A8Mic-theme%E9%85%8D%E7%BD%AE%E4%B8%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[关于在Mic theme配置下的一些心得前言本人是一个前端小白，最近才开始搭建自己的博客并且开始进行配置，也发布一些自己写的小文章，因为开始用到的主题是next，当然next的简洁大方是很受大部分大佬们所喜欢的，但作为一个前端萌新，同时也是电影《指环王》的忠实爱好者，期待一个更加魔幻的主题来作为你自己博客的主界面，在我的不懈努力之下终于找到了Mic_theme这个主题，经过这几天的配置，同时也踩过不少坑，博客已经初具形态，在日后的配置中，会经常更新这篇文章，加入一些自己喜欢的内容和效果。一小点题外话，建议大家用一些专业的文本编辑器，例如我用的是MarkdownPad，或者用WebStorm什么的 正文言归正传,第一次写这篇文章，主要有以下几个内容1.更换背景2.更换intro部分介绍3.更换导航栏样式4.给每一篇文章添加缩略图5.自定义样式6.自定义html文件 以下是详细讲解 1.更换背景更换背景就是说更换在文章“下面”fixed的图片，初期下载下来Mic_theme的时候背景图片是这个我们在从github里面clone下来的 hexo-theme-Mic_theme-&gt;readme.md里面可以看到这样的说法 3.主页背景图片：默认链接是在主站以下目录的 &quot;img/bg.jpg&quot; 就代表&quot;miccall.tech/img/bg.jpg&quot; 暂不支持外链 **backgroundpic :** &quot;img/bg.jpg&quot; 在对应的主题配置文件(Mic_theme里面的主题配置文件)_config.yml可以看到如下的参数配置（我是用webstorm打开的）其中backgroundpic的值是背景图片的链接，图片名是bg.jpg所以在更换背景时，只需要更改链接就可以了，只需要注意一点，图片必须在themes\hexo-theme-Mic_Theme\source\img目录下才可以直接根据图片名添加，否则没有效果ps:获取图片链接的代码在:themes\hexo-theme-Mic_Theme\source\img\head.ejs里面，代码如下 body:before { content: &#39; &#39;; position: fixed; top: 0; background: url(&#39;&lt;%- config.root %&gt;&lt;%- theme.head.backgroundpic%&gt;&#39;) center 0 no-repeat; right: 0; bottom: 0; left: 0; background-size: cover; } 2.更换intro部分介绍首先，默认的intro介绍是这样子的我们想要改成自己的介绍，需要在themes\hexo-theme-Mic_Theme里面的_config.yml主题配置文件里面进行设置，直接在文件里面修改对应的值即可，这个是我自己修改后的介绍 Intro: name: 不会拉小提琴的左脚&lt;sub&gt;的博客&lt;/sub&gt; slogan: &quot;Welcome to my blog page&quot; HeadButton: home page 在_config.yml文件中配置的时候，可以直接通过html的标签来实现文字的一些效果，比如我用到了sub标签，实现了下角标的效果同样，如果有小伙伴好奇这个THIS IS是怎么出现的，可以在themes\hexo-theme-Mic_Theme\layout_partial下面的intro.ejs文件里面找到对应的html代码，并可以做出相应的修改 &lt;div id=&quot;intro&quot;&gt; &lt;h1&gt;You are at&lt;br /&gt; &lt;%- theme.Intro.name %&gt; &lt;/h1&gt; &lt;p&gt; &lt;%- theme.Intro.slogan %&gt; &lt;/p&gt; &lt;ul class=&quot;actions&quot;&gt; &lt;li&gt;&lt;a href=&quot;#header&quot; class=&quot;button icon solo fa-arrow-down scrolly&quot;&gt;Continue&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; 同时对应的css代码全部在themes\hexo-theme-Mic_Theme\source\css下面的mic_main.css中，对应的设置介绍部分的代码93~319行，这里只贴出部分代码以作示例 #intro h1 { margin-top: 6rem; letter-spacing:8px; font-size: 4rem; line-height: 4rem; user-select: none; } #intro p { font-size: 3rem; font-style: italic; margin-top: -0.25rem; text-align: center; user-select: none; } @media screen and (max-width: 500px) { #intro { padding: 3rem 2rem 1rem 2rem ; min-height: 80vh; } #intro h1 { font-size: 5rem; line-height: 1.1; margin-bottom: 7rem; } #intro p { font-size: 1rem; margin-top: 0rem; } #intro .actions { display: none; } } 3.更换导航栏样式默认的导航栏样式如下：如图所示，大致可分为两个部分，左边是个人信息等的导航(当然不止这些，可以自行设置),右边是设置导航栏的图片，默认有github和500px,下面我们来自己进行一下配置首先，我们来看官方的readme.md文档: Home_name: 主页 # 主页名字 is_use_categories : true # 是否启用分类 categories_name: 分类 # 分类名字 is_use_archives : false # 是否启用归档 archives_name: 归档 # 归档名字 icon: # 导航栏上的图标 github: use: true # 是否启用 link: https://github.com/miccall # 点击地址 Twitter: use: false link: Facebook: use: false link: Instagram: use: false link: pages: # 自定义连接页 # link 的参数为相对路径，对应 hexo 目录下的 source 件夹内的相应文件夹 简历: link: &quot;/about/&quot; 团队 : link: &quot;/group/&quot; 图库 : link: &quot;/gallery/&quot; 标签: link: &quot;/tag/&quot; #自定义标签名 # link：“路径” MainFirst: # 导航栏下面的主页 name: Miccall Metro # 大标题名字 description: Welcome to my Blog # 第二标签 描述 pic_url: /img/me.jpg # 图片地址 goto_ulr: &quot;&quot; # 点击跳转 Gallery: # 图库页 title: Mr.metro description: Just another fine responsive 首先，左侧第一个内容主页在Home_name一栏进行设置，名字可以自定义，如改成Home Page第二个分类，是否启用分类is_use_categories默认设置为true，即启用分类，可以修改为false或者删除第三个归档。默认设置为false，同样可以修改参数的值来达到其他的效果，例如，设置为true后默认按时间分类icon设置了右侧的图标样式，图标均取自于fontawesome可以自定义，注意github里面的link要改成自己的github地址MainFisrt定义了位于导航栏下方的自我介绍的内容以及自己的图片，如果不想要，可以在themes\hexo-theme-Mic_Theme\layout_partial里面的mainfirst.ejs文件中设置display:none令其隐藏，具体代码如下: &lt;div id=&quot;main&quot; style=&quot;display: none&quot;&gt; &lt;!-- Main first s--&gt; &lt;article id=&quot;me&quot; class=&quot;panel&quot;&gt; &lt;header style=&quot;color: #000000;&quot;&gt; &lt;h1&gt;&lt;%- theme.MainFirst.name %&gt;&lt;/h1&gt; &lt;p&gt;&lt;%- theme.MainFirst.description %&gt;&lt;/p&gt; &lt;a href=&quot;&lt;%- theme.MainFirst.goto_ulr %&gt;&quot; class=&quot;jumplink pic&quot;&gt; &lt;img src=&quot;&lt;%- theme.MainFirst.pic_url %&gt;&quot; alt=&quot;&quot; /&gt; &lt;/a&gt; &lt;/header&gt; &lt;/article&gt; &lt;!-- Main first e--&gt; &lt;/div&gt; 4.给每一篇文章添加缩略图昨天本来已经写完这部分了，结果没有保存。。。只好重新开始o(╯□╰)o我们在官网给出的样例中可以看到里面的每一篇文章都有一个背景，逼格瞬间上去了有木有啊~（附样例） 然而我们刚配置好的博客打开来看文章背后是一片空白，就像这样子那怎么样才能达到官网样例的效果呢？仔细阅读官网的readme.md文档，发现里面有这样一个参数：thumbnail，后面加的注释意为缩略图 title: # 文章标题 date: 2017/3/27 13:48:25 # 文章发表时间 tags: - 标签1 - 标签2 (可选) categories: Algorithm # 分类 thumbnail: https://xxxxxxxxxx.png # 略缩图 可能我们第一眼看上去并没有看懂这个缩略图的意思，但是通读整篇文档，最有可能的就是这个了，那么我们按照文档里面给出的格式进行配置，因为我这里用到的是MarkdownPad2，可以直击添加图片，但这里注意一点，利用MarkdownPad2上传的图片链接的格式是 ![](https://xxxxxxxxxxxxx.png) 而文档中要求只需要https后面的东西，所以生成链接后直接拿出https://xxxxxxxxx.png部分，添加到文章头部的参数thumbnail后面，然后保存，执行hexo s，再次打开的效果就和例子里面的一样了φ(≧ω≦*)♪，OK大功告成! --- title: 关于在Mic theme配置下的一些心得 date: 2018-08-28 15:21:07 tags: Mic_theme hexo blog thumbnail: https://i.imgur.com/OBxizjH.jpg --- 最终效果如图 5.自定义样式说起来自己的博客肯定希望有点自己的个性，所以免不了就会想着这里改动一下，那里改动一下，然而直接在主题配置文件里修改如果还达不到个人的口味，就会希望一些更直接的修改，所以在这里我介绍一下直接对css文件进行修改的方法，我自己也在这里面改了不少了首先：主css文件在themes\hexo-theme-Mic_Theme\source\css下的mic_main.css文件中，打开来一看，有4000多行，那跑不了了，就是它了，我们只需要找到对应的选择器，即可在里面进行修改，同时该css文件中也加入了响应式的写法，同样可以自己修改，下面是我自己修改的几个例子： 1.导航栏样式的修改在mic_main.css文件1382行左右，可以看到这样一段代码 @media screen and (max-width: 980px) { #nav { display: none; } } 也就是说在屏幕宽度小于等于980px的时候，默认的导航栏样式消失，至于消失的导航栏去了哪，可以在博客界面右上角看到多了一个menu按钮，点开来看导航都在里面，同时在mic_main.css文2012行有如下代码 @media screen and (max-width: 980px) { #navPanelToggle { display: block; } } 意思很简单，就是显示那个menu按钮，这里面我们可以修改一下边界的宽度，因为现在主流的四种设备即为大屏，中屏，小屏，超小屏，其分类的边界为1200px,992px,768px,即1200px以上是大屏，也就是我们电脑或者显示器的屏幕，992px~1200px为中屏，一般是桌面显示器，768px~992px是小屏幕，一般是平板等，再往下小于768px的就是移动端也就是我们的手机了(以上数据来自于bootstrap的媒体查询宽度)，所以如果你觉得980px别扭的话，可以修改为其他值。点开menu菜单，除了几个链接，就是白白的背景，我们可以为背景加上自己喜欢的图片，设置方法:找到mic_main.css文件里面的id=#navPanel（可以在控制台里面直接找到），在其伪类before下添加背景图片的代码(mic_main.css下2053行上下),下面是我修改后的代码 #navPanel:before{ content: &quot;&quot;; background: url(../images/me2.jpg) center no-repeat; position: absolute; width: 100%; height: 100%; background-size: cover; overflow: hidden; top: 0; left: 0; } 再次打开观察效果 酷的一批啊，哈哈（ps:原来的文字是黑色的，大家可以自行修改，为了对比明显，我将其改为了白色）]]></content>
      <tags>
        <tag>Mic_theme hexo blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery鼠标事件总结（持续更新中）]]></title>
    <url>%2F2018%2F08%2F26%2FjQuery%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[jQuery鼠标事件jQuery鼠标事件–鼠标滚轮事件jQuery鼠标滚轮事件一共分为两类： 支持Firefox浏览器 针对火狐浏览器需要对DOMMouseScroll事件进行监听 支持其他浏览器 针对其他浏览器直接添加事件onmousewheel即可 还有一点两类浏览器不同的地方在于：Firefox浏览器在判断鼠标滚轮滚动的方向时与其他浏览器方向相反，其余四类浏览器使用event对象里面的wheelDelta事件来进行对鼠标滚动的判断。它的取值有两个，分别是+120和-120，+120表示滚轮向上滚动，-120表示滚轮向下滚动在Firefox中，使用event对象那个里面的detail事件来判断滚轮滚动的方向，同样取值有两个，分别为+3和-3，与另外四类浏览器不同的是，向上滚的时候detail的值是-3，向下滚是+3 下面请看代码实例–通过滚动鼠标滚轮，可以使输入框内的数字变大变小，同时可以在控制台内输出不同浏览器里面两种事件wheelDelta和detail的值，读者可以亲自验证后加深理解 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;01 鼠标滚轮事件&lt;/title&gt; &lt;style&gt; body{ margin: 0; padding: 0; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;text&quot; value=&quot;1&quot;&gt; &lt;script&gt; window.onload = function (ev) { /*根据浏览器的不同赋不同的值*/ var mouseWheel = navigator.userAgent.indexOf(&#39;Firefox&#39;) &gt;= 0 ? &#39;DOMMouseScroll&#39;: &#39;mouseWheel&#39;; var numVal = document.querySelector(&quot;input&quot;).value; /*打印当前输入框内的value值*/ console.log(numVal); if (document.addEventListener){ /*火狐浏览器*/ /*使用addEventListener监听DOMMouseScroll事件*/ document.addEventListener(&#39;DOMMouseScroll&#39;,function (e) { e = e || window.event; if (e.detail &gt; 0){ /*向下滚*/ console.log(e.detail); numVal--; document.querySelector(&quot;input&quot;).value = numVal; }else if (e.detail &lt; 0){ /*向上滚*/ console.log(e.detail); numVal++; document.querySelector(&quot;input&quot;).value = numVal; } },false); /*其他浏览器*/ /*onmousewheel 直接绑定鼠标滚轮滚动事件*/ window.onmousewheel = function (e) { if (e.wheelDelta){ if (e.wheelDelta &gt; 0){ console.log(e.wheelDelta); // console.log(&quot;上&quot;); numVal++; // console.log(numVal); document.querySelector(&quot;input&quot;).value = numVal; }else if (e.wheelDelta &lt; 0){ console.log(e.wheelDelta); // console.log(&quot;下&quot;); numVal--; // console.log(numVal); document.querySelector(&quot;input&quot;).value = numVal; } } } } } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;]]></content>
      <tags>
        <tag>jQuery mouse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[overflowhidden]]></title>
    <url>%2F2018%2F08%2F26%2Foverflow%20hidden%E7%9A%84%E5%A4%9A%E9%87%8D%E4%BD%9C%E7%94%A8%2F</url>
    <content type="text"><![CDATA[overflow:hidden的多重作用1.第一个当然就是最常见也最常用的溢出隐藏啦OK，首先是没有加overflow:hidden时的效果代码如下： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;镂空测试&lt;/title&gt; &lt;style&gt; body{ margin: 0; padding: 0; } .parentBox{ width: 200px; height: 200px; background-color: yellow; } .childBox{ width: 100px; height: 300px; background-color: #2b542c; z-index: 99; margin-left: 15px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;parentBox&quot;&gt; &lt;div class=&quot;childBox&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 这个效果的形成非常好理解，我们直接看加入overflow:hidden之后的效果部分代码如下（其余部分不变）： .parentBox{ width: 200px; height: 200px; background-color: yellow; overflow: hidden; } 可以看出子元素超出父元素的部分隐藏掉了，这里要注意一点：overflow:hidden一定是设置在父容器上面才能让子容器隐藏！ 2.第二个可能不太常用，那就是清除浮动在css常见的一种高度设置就是用子容器来撑开父容器的高度，这样不用给父容器设置高度，只需要依靠子容器自己的内容，边距等撑开高度，然而，当我们这个子容器设置了浮动属性后，效果就是下面这个样子：代码如下： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;镂空测试&lt;/title&gt; &lt;style&gt; body{ margin: 0; padding: 0; } .parentBox{ padding: 25px; width: 200px; background-color: yellow; } .childBox{ width: 100px; height: 300px; background-color: #2b542c; margin-left: 15px; float: left; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;parentBox&quot;&gt; &lt;div class=&quot;childBox&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 为什么会有这个样子，为什么子容器没有撑开父容器的高度？原因在这里：子容器设置float属性后（这里是float:left），脱离了原本的文档流，可以这么理解，在设置float属性前，子容器与它的父容器是出于同一个平面上的，我们暂且把这个平面叫做文档流，这样因为在同一平面，所以子容器有什么变化都会影响到父容器，所以给子容器设置高度能撑开父容器，而设置了float属性后，子容器脱离原本的文档流，从浏览器里面可以看到子容器是在父容器上面，用“平面”来解释就是子容器到了一个比父容器高那么一点的另一个平面上（实际上并不存在，类比去理解），那么在这个平面上子容器不管进行什么动作都不会影响父容器，也自然不会撑开父容器的高度了（在本例中与float属性有同样效果的还有position:absolute，也就是绝对定位和position:fixed固定定位，他们也会让元素脱离当前的文档流）然而在给父容器设置了overflow:hidden后， .parentBox{ padding: 25px; width: 200px; background-color: yellow; overflow: hidden; } 注意子元素此时是设置的float属性，如果设置了上文说到的position两个属性，那么overflow:hidden不会有效果 3.第三个作用与第二个差不多，也是消除浮动的影响，通过overflow:hidden来实现自适应布局直接代码+效果说话 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;镂空测试&lt;/title&gt; &lt;style&gt; body{ margin: 0; padding: 0; } .contentBox1{ width: 200px; height: 200px; background-color: yellow; float: left; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;contentBox1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;contentBox2&quot;&gt;内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 为什么会有这样的效果？因为float的初衷就是也只是实现文字环绕效果，只不过后来人们用它来布局，慢慢的就舍弃了它的本质了然后我们给第二个div加上overflow:hidden属性 .contentBox2{ overflow: hidden; } 现在的效果：可以看到的是，文字全被“挤到”了右侧，就想是两个div之间插入了一堵无形的墙把两个div给隔开了（这样的结构满足了流式布局的要求，可以作为左侧固定，右侧自适应的一个模板，即两栏自适应）关于overflow:hidden为什么能清除浮动，我会在另一篇博文中详细解释]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
</search>
