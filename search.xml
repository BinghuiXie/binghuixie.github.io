<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[bootstrap学习笔记]]></title>
    <url>%2F2018%2F08%2F29%2Fbootstrap%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言前几天为了写一个响应式开发的项目，于是学习了bootstrap这个框架，个人认为，bootstrap最强大的地方就在于它的布局，也就是栅格系统，所以在这里也贴出自己学习bootstrap时整理的笔记，着重会讲到bootstrap的栅格系统以及自己踩过的坑等等。注意，复制本文的代码并使用时，里面库的引入需要将路径改为自己的bootstrap路径 正文将要叙述的东西罗列了一下，大概有下面几点1.什么是响应式布局2.媒体查询3.bootstrap的下载与使用4.bootstrap基本模板5.bootstrap中container类–第1个类6.bootstrap中container-fluid类–第2个类7.bootstrap的栅格系统8.bootstrap响应式工具(响应式工具类)9.bootstrap导航条10.bootstrap的collapse(折叠)组件11.bootstrap轮播图12.bootstrap中的Affix(吸顶)组件13.总结：bootstrap常用类ps:上面只是介绍了bootstrap中很少的一部分，更多有关bootstrap内容请移步bootstrap官方中文文档 1.什么是响应式布局前面提到过，用到bootstrap的目的是用来做一个响应式的项目。那么，什么是响应式开发呢？百度百科给出的响应式布局的概念如下： 响应式布局是Ethan Marcotte在2010年5月份提出的一个概念，简而言之，就是一个网站能够兼容多个终端——而不是为每个终端做一个特定的版本。这个概念是为解决移动互联网浏览而诞生的。 响应式布局可以为不同终端的用户提供更加舒适的界面和更好的用户体验，而且随着目前大屏幕移动设备的普及，用“大势所趋”来形容也不为过。随着越来越多的设计师采用这个技术，我们不仅看到很多的创新，还看到了一些成形的模式。 不出意料，百科里面给出的定义不去仔细研读的话好像是不怎么看得懂，下面我给翻译一下：什么叫做一个网站能够兼容多个终端，我们来看两张图（给个面子，忽略排版问题）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们只看数字的部分，左面这张图是屏幕宽度1270px时候显示的样子，可以看出是一行有三个数字，右面这张是屏幕宽度为375px时候的显示效果，可以看出现在是一行一个数字，而不是一行三个数字了。所以，什么是一个网站能够兼容多个终端，我自己的理解是这样的：一个网站（网页），在不同浏览的屏幕宽度下显示的效果不同，达到了只需要写一个网站，就可以在电脑屏幕，平板屏幕，手机屏幕等多种设备（终端）上均能正常的浏览，而不是单独的针对电脑屏幕写一个网站，针对平板的屏幕大小再写一个网站，很大程度上简化了工作量。至于定义后面的针对移动互联网浏览而诞生的这点，涉及到了移动端的知识，后见会讲。好了，到这里应该会理解了什么是响应式，那么如何来实现响应式呢？这就用到了媒体查询。 2.媒体查询读到这里我们应该已经了解了什么是响应式开发，而媒体查询就是用来实现响应式开发的一种“工具”，下面我们来介绍通过css的media来实现媒体查询，具体的格式为 @media mediatype and|not|only (media feature) { CSS-Code; } 首先如同声明一个css动画一样，我们用@media声明一个媒体查询，其中mediatype表示媒体查询的类型，这里引用一下菜鸟教程对该参数的解释 值 描述 all 用于所有设备 aural 已废弃。用于语音和声音合成器 braille 已废弃。 应用于盲文触摸式反馈设备 embossed 已废弃。 用于打印的盲人印刷设备 handheld 已废弃。 用于掌上设备或更小的装置，如PDA和小型电话 print 用于打印机和打印预览 projection 已废弃。 用于投影设备 screen 用于电脑屏幕，平板电脑，智能手机等。 speech 应用于屏幕阅读器等发声设备 tty 已废弃。 用于固定的字符网格，如电报、终端设备和对字符有限制的便携设备 tv 已废弃。 用于电视和网络电视 注意对screen即屏幕的查询是我们的重点后面的and|not|only表示查询的条件，一般常用and，注意and后面有一个空格，后面在括号内写入媒体查询起作用时满足的条件，如果想有多个条件(css样式)，可以写成下面这个样子 @media mediatype and (condition1) and (condition2) ... { CSS-Code; } 在大括号内可以写入css代码，以实现媒体查询。在bootstrap官方文档中，将目前市面上主流的屏幕宽度分为四类，分界线为1200px，992px，768px，即1200px以上是大屏，也就是我们电脑或者显示器的屏幕，992px~1200px为中屏，一般是桌面显示器，768px~992px是小屏幕，一般是平板等，再往下小于768px的就是移动端也就是我们的手机了，所以，针对这四种设备写出来的媒体查询是这样子的 /*大屏设备 1200px以上*/ /*满足条件的时候会生效*/ @media screen and (min-width: 1200px){ } /*中屏设备 992px - 1200px*/ @media screen and (min-width: 992px) and (max-width: 1200px){ } /*小屏设备 768px - 992px*/ @media screen and (min-width: 768px) and (max-width: 992px){ } /*超小屏设备 768px以下*/ @media screen and (max-width: 768px){ } /*媒体查询*/ /* 关键字 查询的是screen屏幕 条件以and连接 and后面必须有空格 &quot;()&quot;里面放条件(css样式) @media screen and (min-width: 1200px){ 写css样式 } */ 以上就是媒体查询的基本内容了，下面给出一个实例代码，可以复制下来自己运行观察在不同的屏幕宽度下显示的效果(代码里meta标签里面对viewport的声明会在移动端专题里面讲到)示例代码： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;媒体查询&lt;/title&gt; &lt;style&gt; body{ margin: 0; padding: 0; } .container{ width: 1200px; height: 1200px; margin: 0 auto; background-color:black; } span.container1{ font-size: 50px; font-weight: bold; color: red; display: block; top: 50%; /*一种水平居中和垂直居中的方法*/ position: absolute; right: 50%; transform: translate(50%,50%); /*另一种水平居中的方法 display:block; margin: 0 auto; /**!*/ } /*大屏设备 1200px以上*/ /*满足条件的时候会生效*/ @media screen and (min-width: 1200px){ .container{ width: 1170px; background-color: yellow; } span.container1{ color: green; } } /*中屏设备 992px - 1200px*/ @media screen and (min-width: 992px) and (max-width: 1200px){ .container{ width: 970px; background-color: green; } span.container1{ color: black; } } /*小屏设备 768px - 992px*/ @media screen and (min-width: 768px) and (max-width: 992px){ .container{ width: 750px; background-color: blue; } span.container1{ color: maroon; } } /*超小屏设备 768px以下*/ @media screen and (max-width: 768px){ .container{ background-color: purple; width: 100%; } span.container1{ color: white; } } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;container&quot;&gt;&lt;/div&gt; &lt;span class=&quot;container1&quot;&gt;媒体查询&lt;/span&gt; &lt;/body&gt; &lt;/html&gt; 看完这段代码大家会不会有一个问题：如果每一种设备都需要写一次代码的话那四种设备不是要写四份代码吗？这样如何能体现减少了代码量的地方呢？这个问题，即将在下面的bootstrap使用中得到解决，接着学习第3节吧~ 3.bootstrap的下载与使用前言好了，到这里大家已经知道了什么是响应式布局以及如何利用媒体查询来实现响应式布局了，那么，上面我们也提出过问题：每一种设备（终端）都写一份代码并没有体现出代码量优化的特点。那么从这节开始我会写如何利用bootstrap来完成响应式布局，大大降低你的工作量。本节内容：bootstrap的下载与使用在官网给出的文档中我们可以看到，其给我们提供了三种下载方式，如下：我们需要的就是第一种也就是用于生产环境的bootstrap，点击下载bootstrap，解压，即可得到bootstrap的css，js和fonts字体文件。接下来就是使用bootstrap了 4.bootstrap基本模板想要bootstrap能正常运行，必须需要一个bootstrap的基本模板，说白了就是一个html文件，需要在其中引入特定的内容，否则bootstrap使用的时候不会有任何效果，下面是官方文档给出的bootstrap基本模板 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt; &lt;title&gt;Bootstrap 101 Template&lt;/title&gt; &lt;!-- Bootstrap --&gt; &lt;link href=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;!-- HTML5 shim 和 Respond.js 是为了让 IE8 支持 HTML5 元素和媒体查询（media queries）功能 --&gt; &lt;!-- 警告：通过 file:// 协议（就是直接将 html 页面拖拽到浏览器中）访问页面时 Respond.js 不起作用 --&gt; &lt;!--[if lt IE 9]&gt; &lt;script src=&quot;https://cdn.bootcss.com/html5shiv/3.7.3/html5shiv.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/respond.js/1.4.2/respond.min.js&quot;&gt;&lt;/script&gt; &lt;![endif]--&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;你好，世界！&lt;/h1&gt; &lt;!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) --&gt; &lt;script src=&quot;https://cdn.bootcss.com/jquery/1.12.4/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 --&gt; &lt;script src=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 下面对这段代码进行一下分析和解释 &lt;!--html5文档申明--&gt; &lt;!DOCTYPE html&gt; &lt;!--使用中文简体语言声明--&gt; &lt;html lang=&quot;zh-CN&quot;&gt; &lt;!--台湾--&gt; &lt;!--&lt;html lang=&quot;zh-tw&quot;&gt;--&gt; &lt;head&gt; &lt;!--当前文档的编码声明--&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;!--指明当前IE浏览器按最新的渲染引擎edge来渲染页面--&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;!--视口：视口的宽度和设备一致，默认缩放比是1.0，不允许用户自行缩放--&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, user-scalable = 0&quot;&gt; &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt; &lt;!--页面自上向下解析 优先告诉浏览器用最新的引擎来渲染，并且告诉浏览器这是一个移动端页面--&gt; &lt;title&gt;03 bootstrap基本模板&lt;/title&gt; &lt;!-- Bootstrap --&gt; &lt;!--引入bootstrap的核心样式库--&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../lib/bootstrap-3.3.7-dist/css/bootstrap.min.css&quot;&gt; &lt;!-- HTML5 shiv 和 Respond.js 是为了让 IE8 支持 HTML5 元素和媒体查询（media Queries）功能 --&gt; &lt;!--HTML5 shiv 解决标签兼容问题--&gt; &lt;!--Respond.js 解决媒体查询兼容问题--&gt; &lt;!-- 警告：通过 file:// 协议（就是直接将 html 页面拖拽到浏览器中）访问页面时 Respond.js 不起作用 --&gt; &lt;!--条件注释 IE9以下生效--&gt; &lt;!--[if lt IE 9]&gt; &lt;script src=&quot;../lib/html5shiv-master/dist/html5shiv.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../lib/Respond-master/dest/respond.min.js&quot;&gt;&lt;/script&gt; &lt;![endif]--&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;你好，世界！&lt;/h1&gt; &lt;!--bootstrap是基于jQuery进行开发的--&gt; &lt;!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) --&gt; &lt;script src=&quot;../lib/jQuery library/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; &lt;!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 --&gt; &lt;script src=&quot;../lib/bootstrap-3.3.7-dist/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 5.bootstrap中container类–第1个类在完成bootstrap的模板以后，我们就可以开始利用bootstrap来进行响应式网页的开发了，首先，我们来介绍bootstrap中的一个类–container，也是我们学习bootstrap的第一个类。首先来看一下container类的源代码 .container { padding-right: 15px; padding-left: 15px; margin-right: auto; margin-left: auto; } @media (min-width: 768px) { .container { width: 750px; } } @media (min-width: 992px) { .container { width: 970px; } } @media (min-width: 1200px) { .container { width: 1170px; } } 可以看出，通过媒体查询，以1200px，992px，768px三个分界点使container类在不同屏幕宽度的终端上面分为三种不同的宽度，而container类设置的margin: 0 auto;(等价于margin-right: auto;margin-left: auto;)意味着包含在container类里面的内容可以水平居中显示。注意container类还有左右内边距各15px宽度，这也意味着如果我们不消除内边距，container类里面的内容是不会充满整个屏幕的，下面我们通过媒体查询来使container类里面的内容在不同屏宽下面展示出不同的效果，代码如下： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, user-scalable = 0&quot;&gt; &lt;title&gt;03 bootstrap基本模板&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../lib/bootstrap-3.3.7-dist/css/bootstrap.min.css&quot;&gt; &lt;!--[if lt IE 9]&gt; &lt;script src=&quot;../lib/html5shiv-master/dist/html5shiv.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../lib/Respond-master/dest/respond.min.js&quot;&gt;&lt;/script&gt; &lt;![endif]--&gt; &lt;style&gt; .container{ height: 480px; } /*移动端设备 768px以下 */ @media (max-width: 767px) { .container { width: 480px; background-color: red; } } /*小屏（平板）设备 768px -- 991px */ @media (min-width: 768px) { .container { width: 750px; background-color: yellow; } } /*中屏设备（桌面显示器） 992px -- 1199px*/ @media (min-width: 992px) { .container { width: 970px; background-color: #2b542c; } } /*大屏设备（显示器） 1200px以上*/ @media (min-width: 1200px) { .container { width: 1170px; background-color: purple; } } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!--响应式容器--&gt; &lt;div class=&quot;container&quot;&gt; &lt;/div&gt; &lt;script src=&quot;../lib/jQuery library/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../lib/bootstrap-3.3.7-dist/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 注意默认情况下container类是没有高度的，所以必须为其设置高度或者利用子元素将其高度撑开才能使其可见下面是在不同屏幕宽度下显示的效果首先是大屏设备下(1200px以上)，背景颜色为紫色中屏设备的显示效果（992px~1200px）：小屏设备显示的效果（768px~992px）：然后是移动端设备（超小屏）的显示效果:最后我们再来看一下container类自带的左右15px的内边距 6.bootstrap中container-fluid类–第2个类fluid意思是液体的，流动的，那么在bootstrap里面。如果说container是一个响应式容器的话，那么container-fluid是一个流式容器(ps:流式布局也是移动端常用的一种适配方式，这里不做解释)。它与container类的直观区别可以从下图看出：可以看出container容器是居中显示的，而container-fluid容器是布满了屏幕的宽度，我们再来看container-fluid的代码： .container-fluid { padding-right: 15px; padding-left: 15px; margin-right: auto; margin-left: auto; } 当然这一点也可以从图上直观的看出总结一下，container类和container-fluid类是利用bootstrap时候必须为页面内容和栅格系统包裹的两个容器，其中，因为container类在不同的屏宽下设置了不同的宽度，所以container类用于固定宽度并支持响应式布局的容器。而container-fluid类因为没有设置宽度，但默认为100%，所以说其用于100% 宽度，占据全部视口（viewport）的流式容器。 7.bootstrap的栅格系统前言从这节开始进入到bootstrap的学习当中比较重要的一个环节，毕竟bootstrap的一个亮点就在于它的栅格系统布局方式非常灵活。学会使用bootstrap的栅格系统以后，利用其便能快速的达到一些常见的布局。 正文bootstrap的栅格系统本质上是通过浮动(float属性)与宽度百分比来实现的，同时也能通过调用不同的类来针对不同的屏幕尺寸达到适配，前面也提到过，bootstrap将屏幕尺寸分为四类，分别是超小屏幕&lt;768px，小屏幕 平板&gt;=768px，中等屏幕 桌面显示器&gt;=992px以及大屏幕 大桌面显示器&gt;=1200px(当然如果你对媒体查询以及min-width,max-width等属性非常熟悉的话，也可以定制自己的响应式网站，bootstrap在这方面也能让你自定义 Bootstrap 组件、Less 变量和 jQuery 插件，从而定制一份属于自己的bootstrap版本)，在bootstrap里面，大屏设备简写为lg，中屏设备为md，小屏设备为sm，超小屏设备也就是移动端设备为xs。我们首先来介绍一个类–.row，row是行的意思，先来看一下它的源代码： .row { margin-right: -15px; margin-left: -15px; } 非常简单的两行代码，左右两边各有-15px的外边距。.row类，也就是栅格系统里的“行”必须要包含在.container类或者.container-fluid类里面，它的作用有两个：(1)消除.container类或者.container-fluid类的内边距(2)实现栅格系统布局的基础（有了行才能有列）解释一下(1)：.row类左右各有15px的负边距，所以当将其包含在.container类或者.container-fluid类中的时候，可以去掉.container类或者.container-fluid类的15px的内边距。请看下面实例 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, user-scalable = 0&quot;&gt; &lt;title&gt;03 bootstrap基本模板&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../lib/bootstrap-3.3.7-dist/css/bootstrap.min.css&quot;&gt; &lt;!--[if lt IE 9]&gt; &lt;script src=&quot;../lib/html5shiv-master/dist/html5shiv.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../lib/Respond-master/dest/respond.min.js&quot;&gt;&lt;/script&gt; &lt;![endif]--&gt; &lt;style&gt; .container{ width: 100%; } .container &gt; .row{ height: 200px; background-color: purple; } .container &gt; .div{ height: 200px; background-color: yellow; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;div&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;../lib/jQuery library/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../lib/bootstrap-3.3.7-dist/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 效果：在栅格系统中，所有的内容都放在列(column)中，注意，只有列(column)可以作为行(row)的直接子元素下面我们来介绍栅格系统中列的使用，即.col-xx-xx类(“xx”表示参数)bootstrap.col-xx-xx类：第一个参数（第一个“xx”） 取值 含义 作用范围 lg 大屏(1200px+) 大屏生效 md 中屏(992px~1200px) 中屏及以上生效 sm 小屏(768px~992px) 小屏及以上生效 xs 超小屏(768px以下) 超小屏及以上生效 第二个参数（第二个“xx”）bootstrap默认会把一行分成12等份，也就是一行最多有12列，第二个参数表示的是当前的元素占12等份当中的几份，比如说col-md-4中4就表示在中屏以上的屏宽的时候占12份中的4份，也就是三分之一的宽度范围：1-12下面是代码示例： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, user-scalable = 0&quot;&gt; &lt;title&gt;03 bootstrap基本模板&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../lib/bootstrap-3.3.7-dist/css/bootstrap.min.css&quot;&gt; &lt;!--[if lt IE 9]&gt; &lt;script src=&quot;../lib/html5shiv-master/dist/html5shiv.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../lib/Respond-master/dest/respond.min.js&quot;&gt;&lt;/script&gt; &lt;![endif]--&gt; &lt;style&gt; body{ background-color: #bce8f1; } .container &gt; .row{ height: 80px; background-color: yellow; } .first-row &gt; div{ margin-top: 15px; height: 50px; border: 1px solid #ffffff; background-color: black; box-sizing: border-box; line-height: 50px; text-align: center; font-size: 1.5vw; color: white; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;first-row&quot;&gt; &lt;div class=&quot;col-lg-2&quot;&gt;2份&lt;/div&gt; &lt;div class=&quot;col-lg-6&quot;&gt;6份&lt;/div&gt; &lt;div class=&quot;col-lg-1&quot;&gt;1份&lt;/div&gt; &lt;div class=&quot;col-lg-3&quot;&gt;3份&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;second-row&quot;&gt;&lt;/div&gt; &lt;div class=&quot;third-row&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;../lib/jQuery library/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../lib/bootstrap-3.3.7-dist/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 效果如下：可以很清楚的看到一行被分成为12份。且2+6+1+3 == 12，当然，如果和大于12，那么多余的列便会被挤下来，到下面一行 &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;first-row&quot;&gt; &lt;div class=&quot;col-lg-2&quot;&gt;2份&lt;/div&gt; &lt;div class=&quot;col-lg-6&quot;&gt;6份&lt;/div&gt; &lt;div class=&quot;col-lg-1&quot;&gt;1份&lt;/div&gt; &lt;div class=&quot;col-lg-4&quot;&gt;4份&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;second-row&quot;&gt;&lt;/div&gt; &lt;div class=&quot;third-row&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 上面只是在调用了.col-lg-xx相关类，也就是说上面的示例代码只能在大屏下才有效果，放到其余三类尺寸的屏幕下只会默认占满整行，就像下面这样当我们进行完上面的简单的使用栅格系统布局之后，bootstrap还为我们提供了其他的辅助布局的类操作，具体见下表(引自bootstrap官方文档)：槽宽(gutter)即为列与列之间的间隔，通过为列设置padding属性来实现。从表中我们看到，bootstrap还为我们提供了几种实现更为复杂的布局的方式：(1)列嵌套(2)列偏移(offsets)(3)列排序下面来逐条介绍:(1)列嵌套顾名思义，列嵌套就是列与列之间的嵌套，也就是我们可以在一列中再放置12份内容，具体做法：可以通过添加一个新的.row元素和一系列.col-xx-xx元素到已经存在的.col-xx-xx元素内。我们拿实例来说话，代码如下： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, user-scalable = 0&quot;&gt; &lt;title&gt;03 bootstrap基本模板&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../lib/bootstrap-3.3.7-dist/css/bootstrap.min.css&quot;&gt; &lt;!--[if lt IE 9]&gt; &lt;script src=&quot;../lib/html5shiv-master/dist/html5shiv.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../lib/Respond-master/dest/respond.min.js&quot;&gt;&lt;/script&gt; &lt;![endif]--&gt; &lt;style&gt; body{ background-color: #bce8f1; } .container &gt; .row{ height: 80px; background-color: yellow; } .first-row &gt; div{ margin-top: 15px; height: 50px; border: 1px solid #ffffff; background-color: black; box-sizing: border-box; line-height: 50px; text-align: center; font-size: 1.5vw; color: white; } .first-row &gt; div .row{ height: 30px; margin-top: 10px; font-size: 1vw; font-weight: 900; } .first-row &gt; div .row div{ border: 1px solid #ffffff; background-color: purple; box-sizing: border-box; line-height: 30px; text-align: center; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;first-row&quot;&gt; &lt;div class=&quot;col-lg-2&quot;&gt;2份&lt;/div&gt; &lt;div class=&quot;col-lg-6&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-lg-7&quot;&gt;嵌套7份&lt;/div&gt; &lt;div class=&quot;col-lg-2&quot;&gt;嵌套2份&lt;/div&gt; &lt;div class=&quot;col-lg-3&quot;&gt;嵌套3份&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col-lg-1&quot;&gt;1份&lt;/div&gt; &lt;div class=&quot;col-lg-3&quot;&gt;3份&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;second-row&quot;&gt;&lt;/div&gt; &lt;div class=&quot;third-row&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;../lib/jQuery library/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../lib/bootstrap-3.3.7-dist/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 实现的效果如下：同样，我们还可以再在里面嵌套列，但是要注意一点：列必须基于行，所以必须将列元素作为.row类直接子元素才会有作用(2)列偏移(offsets)列偏移的意思是，我们可以通过对特定的类的调用，来达到对某一列在其原来位置的基础上向右偏移特定的距离(注意这里距离只能为整数，范围为1~12)，下面请看例子 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, user-scalable = 0&quot;&gt; &lt;title&gt;03 bootstrap基本模板&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../lib/bootstrap-3.3.7-dist/css/bootstrap.min.css&quot;&gt; &lt;!--[if lt IE 9]&gt; &lt;script src=&quot;../lib/html5shiv-master/dist/html5shiv.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../lib/Respond-master/dest/respond.min.js&quot;&gt;&lt;/script&gt; &lt;![endif]--&gt; &lt;style&gt; body{ background-color: #bce8f1; } .container &gt; .row{ background-color: yellow; } .first-row &gt; div{ margin-top: 15px; height: 50px; border: 1px solid #ffffff; background-color: black; box-sizing: border-box; line-height: 50px; text-align: center; font-size: 1.5vw; color: white; } .first-row &gt; div .row{ height: 30px; margin-top: 10px; font-size: 1vw; font-weight: 900; } .first-row &gt; div .row div{ border: 1px solid #ffffff; background-color: purple; box-sizing: border-box; line-height: 30px; text-align: center; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;first-row&quot; style=&quot;overflow: hidden&quot;&gt; &lt;div class=&quot;col-lg-2&quot;&gt;2份&lt;/div&gt; &lt;div class=&quot;col-lg-6&quot;&gt;6份&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;first-row&quot;&gt; &lt;div class=&quot;col-lg-2&quot;&gt;2份&lt;/div&gt; &lt;div class=&quot;col-lg-6 col-lg-offset-4&quot; id=&quot;lg-offset-6&quot;&gt;6份&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;../lib/jQuery library/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../lib/bootstrap-3.3.7-dist/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 效果如下图：我们从代码里可以看出，.row类下面的两个div的样式几乎一样，所不同的是，第二个div中填加了.col-lg-offset-4类，致使第二个div下面id=”lg-offset-6”的块元素向右平移了4份的距离，直接与右边对齐。本质上，.col-xx-offset-4(“xx”表示屏幕尺寸)是添加了左边距才使得元素能向右偏移，我们从bootstrap的代码中能很清晰的看出这一点 .col-xs-offset-12 { margin-left: 100%; } .col-xs-offset-11 { margin-left: 91.66666667%; } .col-xs-offset-10 { margin-left: 83.33333333%; } .col-xs-offset-9 { margin-left: 75%; } 上面的例子只是给出了在大屏也就是lg的情况下的偏移，其余情况可以自己将代码复制下去进行改动验证。(3)列排序在默认的情况下，列的排序会按照我们代码规定的顺序，写在前面的排在前面，写在后面的排在后面，这里用到上面的例子 &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;first-row&quot;&gt; &lt;div class=&quot;col-lg-2&quot;&gt;2份&lt;/div&gt; &lt;div class=&quot;col-lg-6&quot;&gt;6份&lt;/div&gt; &lt;div class=&quot;col-lg-1&quot;&gt;1份&lt;/div&gt; &lt;div class=&quot;col-lg-4&quot;&gt;4份&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;second-row&quot;&gt;&lt;/div&gt; &lt;div class=&quot;third-row&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 如图和代码所示，列从左到有的顺序默认按照2，6，1，4，这样进行排序，而bootstrap给我们提供了相关类可以改变列与列之间默认的排序方式，即.col-xx-xx-xx类。.col-xx-xx-xx类，第一个参数表示屏幕尺寸，老规矩，有lg，md，sm，xs四种取值，第二个参数代表方向，有push与pull两个取值，其中push(推)，方向向右，pull(拉)，方向为左，第三个参数表示向左拉或者向右推的列数，取值为1~12，下面来举例描述首先代码如下: &lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, user-scalable = 0&quot;&gt; &lt;title&gt;05 栅格系统&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../lib/bootstrap-3.3.7-dist/css/bootstrap.css&quot;&gt; &lt;!--[if lt IE 9]&gt; &lt;script src=&quot;../lib/html5shiv-master/dist/html5shiv.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../lib/Respond-master/dest/respond.min.js&quot;&gt;&lt;/script&gt; &lt;![endif]--&gt; &lt;style&gt; body,h1,h2,h3,h4,h5,h6,p,span{ margin: 0; padding: 0; } .container{ height: 360px; background-color: #bce8f1; } /*只选择某个元素的子元素用 &quot;&gt;&quot; */ .container &gt; .row{ height: 100px; background-color: yellow; } .container &gt; .row &gt; div{ font-size: 1.5vw; color: white; text-align: center; line-height: 50px; height: 50px; border: 1px solid #cccccc; background-color: green; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!--响应式容器--&gt; &lt;div class=&quot;container&quot;&gt; &lt;!--栅格系统--&gt; &lt;div class=&quot;row&quot;&gt; &lt;!--列--&gt; &lt;!--排序前--&gt; &lt;div class=&quot;col-xs-3&quot;&gt;3&lt;/div&gt; &lt;div class=&quot;col-xs-4&quot;&gt;4&lt;/div&gt; &lt;div class=&quot;col-xs-5&quot;&gt;5&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;!--列--&gt; &lt;!--列排序--&gt; &lt;div class=&quot;col-xs-3 col-xs-push-5&quot;&gt;3&lt;/div&gt; &lt;div class=&quot;col-xs-4 col-xs-push-5&quot;&gt;4&lt;/div&gt; &lt;div class=&quot;col-xs-5 col-xs-pull-7&quot;&gt;5&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;../lib/jQuery library/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../lib/bootstrap-3.3.7-dist/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 第一个含有.row类的div没有调用其他类，所以展现出来的效果就是默认的排序3,4,5，而第二个含有.row类的div通过调用.col-xx-push-xx类与.col-xx-pull-xx类实现了5,3,4的排序效果，我们可以来看一下这类类的代码，以更好了解他们的作用 .col-sm-pull-1 { right: 8.33333333%; } .col-sm-pull-0 { right: auto; } .col-sm-push-12 { left: 100%; } 可以看出，实现列排序的本质也是通过对左右边距的距离进行定位，从而达到列向左或者向右平移指定距离的效果，在上面的例子中，3份的div向右平移5个单位，4份的div向右平移4个单位，5份的div向左平移了7个单位，且因为使用了xs，所以在超小屏及以上屏幕尺寸均可以适配这种做法。 8.bootstrap响应式工具(响应式工具类)前言利用bootstrap进行响应式开发是非常方便的，只需要用.container类作为第一级父容器，将其余的北荣均放在.container下面作为其子元素就能达到适配不同终端的要求，当然，想要达到在不同终端下面显示的效果不一样，上面写的内容还并不能做到如此多元化的效果，所以在这节我们将会介绍其他的bootstrap提供的响应式工具(类)，通过调用不同的类来达到在不同终端有不同效果的要求。 正文关于bootstrap响应式工具(类)，我主要记录了两种(1).visible-xx-xx类(2).hidden-xx类分别控制了在不同的屏幕尺寸下的显示和隐藏(1).visible-xx-xx类.visible-xx-xx类，第一个参数同样代表了屏幕的尺寸，有四种取值，lg，md，sm与xs，分别代表了在大屏可见，中等屏幕可见，小屏幕可见以及超小屏幕可见(注意此时每一种尺寸只代表了当前屏幕的尺寸，在其之上的尺寸范围并不适用，也就是说，.visible-xs-xx只代表了能在超小屏幕可见，而不是超小屏幕即以上均可见).visible-xx-xx类，第二个参数有三种取值，分别为block，inline，inline-block，与CSS中的display:block，display:inline，display:inline-block相对应，bootstrap中也给我们列出了.visible-xx-xx类的相关取值，如下图:至于单独的使用.visible-xs、.visible-sm、.visible-md、.visible-lg类也不是不可以，但是从v3.2.0版本开始不建议使用，控制元素的隐藏与显示更加常用.hidden-xx相关类。当然visiblex相关类的取值不止上面这些，有兴趣可以去读一读bootstrap的源码，里面有详细的代码说明。(2).hidden-xx类相对于.visible-xx-xx相关类，.hidden-xx相关类相对来说更加常用而且比较好理解，它一共只用四种取值，分别是.hidden-xs，.hidden-sm，.hidden-md，.hidden-lg，分别代表了在超小屏，小屏，中屏以及大屏隐藏，关于这个我们可以参考bootstrap给出的官方文档OK，介绍完了相关类的取值以及他们的含义，我们来看一下下面这个代码 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, user-scalable = 0&quot;&gt; &lt;title&gt;06 响应式工具&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../lib/bootstrap-3.3.7-dist/css/bootstrap.min.css&quot;&gt; &lt;!--[if lt IE 9]&gt; &lt;script src=&quot;../lib/html5shiv-master/dist/html5shiv.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../lib/Respond-master/dest/respond.min.js&quot;&gt;&lt;/script&gt; &lt;![endif]--&gt; &lt;style&gt; .container{ height: 240px; background-color: #00CCFF; font-size: 2vw; } header{ height: 80px; background-color: purple; text-align: center; color: #ffffff; line-height: 80px; } section{ height: 80px; background-color: yellow; text-align: center; color: #000000; line-height: 80px; } footer{ height: 80px; background-color: #2b542c; text-align: center; color: white; line-height: 80px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 需求： 1.在大屏设备 显示 头 内容 脚 2.在中屏设备 显示 内容 脚 3.在小屏设备 显示 内容 4,在超小屏设备 显示 nothing --&gt; &lt;!--使用 响应式工具类--&gt; &lt;div class=&quot;container&quot;&gt; &lt;!--头 只在大屏的时候显示，中屏，小屏，超小屏均隐藏--&gt; &lt;header class=&quot;hidden-md hidden-sm hidden-xs visible-lg&quot;&gt;头&lt;/header&gt; &lt;!--内容 在超小屏不显示，大屏中屏小屏显示--&gt; &lt;section class=&quot;hidden-xs&quot;&gt;内容&lt;/section&gt; &lt;!--脚 在小屏和超小屏不显示--&gt; &lt;footer class=&quot;hidden-sm hidden-xs&quot;&gt;脚&lt;/footer&gt; &lt;/div&gt; &lt;script src=&quot;../lib/jQuery library/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../lib/bootstrap-3.3.7-dist/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 对应不同屏幕尺寸显示的效果如图:大屏：中屏：小屏：超小屏：同时贴出相关.hidden-xx类代码以供理解 @media (max-width: 767px) { .hidden-xs { display: none !important; } } @media (min-width: 768px) and (max-width: 991px) { .hidden-sm { display: none !important; } } @media (min-width: 992px) and (max-width: 1199px) { .hidden-md { display: none !important; } } @media (min-width: 1200px) { .hidden-lg { display: none !important; } } 9.bootstrap导航条从这里开始，包括下面的内容，基本上就是介绍bootstrap的一些常用组件，首先来看bootstrap的导航条使用bootstrap提供的导航栏的时候，可以直接使用HTML5nav标签，当然也可以使用div标签，bootstrap官方文档中提示我们使用div标签的时候，需要加上role=”navigation”属性，role属性的作用是为了能使盲人用户知道当前浏览的是什么界面，然而在国内由于这方面还未普及，所以我们也可以不需要role=”navigation”属性，直接使用div标签即可，但为了更加明确，建议使用nav标签。这里我们通过bootstrap给出的样例代码来进行一步步的解释 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-CN&quot;&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, user-scalable = 0&quot;&gt; &lt;title&gt;08 bootstrap导航条&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../lib/bootstrap-3.3.7-dist/css/bootstrap.css&quot;&gt; &lt;!--[if lt IE 9]&gt; &lt;script src=&quot;../lib/html5shiv-master/dist/html5shiv.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../lib/Respond-master/dest/respond.min.js&quot;&gt;&lt;/script&gt; &lt;![endif]--&gt; &lt;/head&gt; &lt;body&gt; &lt;nav class=&quot;navbar navbar-default&quot;&gt; &lt;!--响应式容器--&gt; &lt;div class=&quot;container&quot;&gt; &lt;!-- Brand and toggle get grouped for better mobile display --&gt; &lt;div class=&quot;navbar-header&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;navbar-toggle collapsed&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#bs-example-navbar-collapse-1&quot;&gt; &lt;span class=&quot;sr-only&quot;&gt;Toggle navigation&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;/button&gt; &lt;!--商标区域--&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;Brand&lt;/a&gt; &lt;/div&gt; &lt;!-- Collect the nav links, forms, and other content for toggling --&gt; &lt;div class=&quot;collapse navbar-collapse&quot; id=&quot;bs-example-navbar-collapse-1&quot;&gt; &lt;ul class=&quot;nav navbar-nav&quot;&gt; &lt;!--active 当前选中--&gt; &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;!--下拉菜单--&gt; &lt;li class=&quot;dropdown&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;dropdown-toggle&quot; data-toggle=&quot;dropdown&quot;&gt;Dropdown &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt;&lt;/a&gt; &lt;ul class=&quot;dropdown-menu&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Another action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Something else here&lt;/a&gt;&lt;/li&gt; &lt;li role=&quot;separator&quot; class=&quot;divider&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Separated link&lt;/a&gt;&lt;/li&gt; &lt;li role=&quot;separator&quot; class=&quot;divider&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;One more separated link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;form class=&quot;navbar-form navbar-left&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;Search&quot;&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;Submit&lt;/button&gt; &lt;/form&gt; &lt;ul class=&quot;nav navbar-nav navbar-right&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;dropdown&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;dropdown-toggle&quot; data-toggle=&quot;dropdown&quot;&gt;Dropdown &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt;&lt;/a&gt; &lt;ul class=&quot;dropdown-menu&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Another action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Something else here&lt;/a&gt;&lt;/li&gt; &lt;li role=&quot;separator&quot; class=&quot;divider&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Separated link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;!-- /.navbar-collapse --&gt; &lt;/div&gt;&lt;!-- /.container-fluid --&gt; &lt;/nav&gt; &lt;script src=&quot;../lib/jQuery library/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../lib/bootstrap-3.3.7-dist/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 导航条的样子是这样的首先，nav标签作为最上一级父容器，内包含.navbar，.navbar-default两个类，下面是这两个类的代码: .navbar { position: relative; min-height: 50px; margin-bottom: 20px; border: 1px solid transparent; } .navbar-default { background-color: #f8f8f8; border-color: #e7e7e7; } 可以看出只是很简单的设置了位置属性，高度，背景颜色等，其中.navbar-default表示默认样式的导航条。上面我们说过，实现响应式必有要有.container类，所以在nav下面的div调用了.container类让我们知道这是一个响应式的导航条，但是响应式的具体效果在哪，我们还要往下看。.container类下面包含两个子容器div， 10.bootstrap的collapse(折叠)组件 11.bootstrap轮播图(Carousel) 12.bootstrap中的Affix(吸顶)组件 13.总结:bootstrap常用类]]></content>
      <tags>
        <tag>bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css position属性几个参数详解]]></title>
    <url>%2F2018%2F08%2F29%2Fcss-position%E5%B1%9E%E6%80%A7%E5%87%A0%E4%B8%AA%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[关于删除节点幕后的事情]]></title>
    <url>%2F2018%2F08%2F29%2F%E5%85%B3%E4%BA%8E%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9%E5%B9%95%E5%90%8E%E7%9A%84%E4%BA%8B%E6%83%85%2F</url>
    <content type="text"><![CDATA[前言这篇文章原来是自己写的第一篇博文，因为格式太难看于是在这里进行了一次重新的修改与发布，至于内容，emmmmmm，有兴趣就看看当做了解就好 正文当时刚学到js，当看到删除节点这节的时候，自己写了一个程序来测试，点击清除节点按钮却发现了出人意料的结果，经过长时间的思考最终参透了其中的奥秘，于是发布上来，下面是代码: &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;content&quot;&gt; &lt;h1&gt;html&lt;/h1&gt; &lt;h1&gt;php&lt;/h1&gt; &lt;h1&gt;javascript&lt;/h1&gt; &lt;h1&gt;jquery&lt;/h1&gt; &lt;h1&gt;java&lt;/h1&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; document.write(content.childNodes.length); function clearText() { var content=document.getElementById(&quot;content&quot;); // 在此完成该函数 for(var i=0;i&lt;content.childNodes.length;i++){ var childNode = content.childNodes[i]; content.removeChild(childNode); } } &lt;/script&gt; &lt;button onclick=&quot;clearText()&quot;&gt;清除节点内容&lt;/button&gt; &lt;/body&gt; &lt;/html&gt; 运行这个程序会发现，第一次点击按钮的时候没有任何反应，第二次点击按钮的时候只剩下了php与jquery两个，再点击按钮php会被删除掉，再点击按钮才会把jQuery删除掉，这是为什么呢？经过仔细观察程序以及了解删除的原理后，得到以下结论，文字比较难叙述，我会尽量往清楚去说明。因为我们使用的是chrome浏览器也就是常说的谷歌浏览器，与IE浏览器不同的是，谷歌，Firefox等浏览器不会忽略空白节点，也就是说会把空白节点当做子节点的一部分，那什么是空白节点呢？我们知道，在HTML代码里在div标签下我们可以看见5个h1标签，也就是元素节点，这是我们可见的，所以我们下意识的就会认为只有5个节点，然而实际上并不是这样，其中还有空白节点的存在，也就是回车，没错，就是你在写代码的时候按下的回车键，那我们来数一数有多少个回车键呢？如图所示我们可以看出其实一共有6个空白节点，所以一共是有11个节点，而不是我们想象的5个。那么问题来了为什么会出现如此怪异的删除效果呢要知道一切现实出来的效果斗鱼我们的代码与变量的变化有关，只要分析清楚了变量的变化，那这个效果就不难理解了，我们来看源代码。源代码的关键地方在content.childNodes.length，我们如果对这条语句进行输出，即“document.write(content.childNodes.length)”会发现得到的结果是11，如果我们形象的表示此时每个节点的排列的话，是这样子的开始循环时，i=0，条件满足，所以删掉第一个空白节点，但此时两个地方发生变化，一个是HTML的标号由于前面的空白节点被删除所以由1变为0，同时length由11变为10，此时i++变为1，因为HTML的标号已经变为0，那么他下面的第二个空白节点的标号就变为1，所以再次循环一次删除的是第二个空白节点而不是HTML，在视觉效果上就相当于没有删除。i++变为2，length变为9，因为删掉了第二个空白节点，所以php现在紧挨着HTML，标号为1（因为HTML的标号为0）此时i=2小于length=9，所以循环继续，此时删除的是标号为2的那个节点也就是php下面的节点—第三个空白节点同理删除后其后面的节点的标号向前进，在视觉效果上仍然没有删除任何东西，而此时length再一次减小，变为8，i变为3，继续循环，javascript此时的标号变为2，第四个空白节点的标号变为3，所以把第四个空白节点删掉，i为4，length为8，此时iquery由于紧挨着javascript，中间的空白节点已经删除，所以它的标号为3，它下面的第五个空白节点的标号为4，所以把第五个空白节点删掉，i=5，length=7，视觉上无变化，再进循环，java的标号已经变为4，它下面的第六个空白节点标号为5，对应i=5，删除掉，此时i=6，length=7，此时后面的没有节点，所以全部是null了，就会退出循环，第一次的点击按钮实际上是删除了所有的空白节点。 第二次点击按钮此时的length已经变为5，因为只剩下了5个元素节点，也就是5个h1标签，标号是0到4，从i=0开始循环，第一次删除掉HTML，剩下4个节点的标号都因此减一，同时length-1变为4，i变为1，再一次进行，删除掉标号由2变为1的javascript，留下了php，javascript后面的jquery和java的标号变为1和2，i变为2，length变为3，循环回来，删除掉标号为2的节点即java，length变为2，i变为3，退出循环，所以第二次点击按钮后剩下的是php和jquery 第三次点击length已经变为2，i从0开始，第一次循环删除掉php，i变为1，length变为1，jquery的标号变为0，不满足循环条件，退出for循环，第三次结束，剩下一个jquery。 第四次点击删除掉jquery，皆大欢喜。好啦，上面就是为什么我们的代码会执行出这样的效果的解释，相信大家只要能看完都能看懂的啦。那么想要一次性的删除怎么做呢？很简单，从后往前循环就好啦。代码改为： for(i=content.childNodes.length-1;i&gt;=0;i--)]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于在Mic theme配置下的一些心得]]></title>
    <url>%2F2018%2F08%2F28%2F%E5%85%B3%E4%BA%8E%E5%9C%A8Mic-theme%E9%85%8D%E7%BD%AE%E4%B8%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[关于在Mic theme配置下的一些心得前言本人是一个前端小白，最近才开始搭建自己的博客并且开始进行配置，也发布一些自己写的小文章，因为开始用到的主题是next，当然next的简洁大方是很受大部分大佬们所喜欢的，但作为一个前端萌新，同时也是电影《指环王》的忠实爱好者，期待一个更加魔幻的主题来作为你自己博客的主界面，在我的不懈努力之下终于找到了Mic_theme这个主题，经过这几天的配置，同时也踩过不少坑，博客已经初具形态，在日后的配置中，会经常更新这篇文章，加入一些自己喜欢的内容和效果。一小点题外话，建议大家用一些专业的文本编辑器，例如我用的是MarkdownPad，或者用WebStorm什么的 正文言归正传,第一次写这篇文章，主要有以下几个内容1.更换背景2.更换intro部分介绍3.更换导航栏样式4.给每一篇文章添加缩略图5.自定义样式6.自定义html文件 以下是详细讲解 1.更换背景更换背景就是说更换在文章“下面”fixed的图片，初期下载下来Mic_theme的时候背景图片是这个我们在从github里面clone下来的 hexo-theme-Mic_theme-&gt;readme.md里面可以看到这样的说法 3.主页背景图片：默认链接是在主站以下目录的 &quot;img/bg.jpg&quot; 就代表&quot;miccall.tech/img/bg.jpg&quot; 暂不支持外链 **backgroundpic :** &quot;img/bg.jpg&quot; 在对应的主题配置文件(Mic_theme里面的主题配置文件)_config.yml可以看到如下的参数配置（我是用webstorm打开的）其中backgroundpic的值是背景图片的链接，图片名是bg.jpg所以在更换背景时，只需要更改链接就可以了，只需要注意一点，图片必须在themes\hexo-theme-Mic_Theme\source\img目录下才可以直接根据图片名添加，否则没有效果ps:获取图片链接的代码在:themes\hexo-theme-Mic_Theme\source\img\head.ejs里面，代码如下 body:before { content: &#39; &#39;; position: fixed; top: 0; background: url(&#39;&lt;%- config.root %&gt;&lt;%- theme.head.backgroundpic%&gt;&#39;) center 0 no-repeat; right: 0; bottom: 0; left: 0; background-size: cover; } 2.更换intro部分介绍首先，默认的intro介绍是这样子的我们想要改成自己的介绍，需要在themes\hexo-theme-Mic_Theme里面的_config.yml主题配置文件里面进行设置，直接在文件里面修改对应的值即可，这个是我自己修改后的介绍 Intro: name: 不会拉小提琴的左脚&lt;sub&gt;的博客&lt;/sub&gt; slogan: &quot;Welcome to my blog page&quot; HeadButton: home page 在_config.yml文件中配置的时候，可以直接通过html的标签来实现文字的一些效果，比如我用到了sub标签，实现了下角标的效果同样，如果有小伙伴好奇这个THIS IS是怎么出现的，可以在themes\hexo-theme-Mic_Theme\layout_partial下面的intro.ejs文件里面找到对应的html代码，并可以做出相应的修改 &lt;div id=&quot;intro&quot;&gt; &lt;h1&gt;You are at&lt;br /&gt; &lt;%- theme.Intro.name %&gt; &lt;/h1&gt; &lt;p&gt; &lt;%- theme.Intro.slogan %&gt; &lt;/p&gt; &lt;ul class=&quot;actions&quot;&gt; &lt;li&gt;&lt;a href=&quot;#header&quot; class=&quot;button icon solo fa-arrow-down scrolly&quot;&gt;Continue&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; 同时对应的css代码全部在themes\hexo-theme-Mic_Theme\source\css下面的mic_main.css中，对应的设置介绍部分的代码93~319行，这里只贴出部分代码以作示例 #intro h1 { margin-top: 6rem; letter-spacing:8px; font-size: 4rem; line-height: 4rem; user-select: none; } #intro p { font-size: 3rem; font-style: italic; margin-top: -0.25rem; text-align: center; user-select: none; } @media screen and (max-width: 500px) { #intro { padding: 3rem 2rem 1rem 2rem ; min-height: 80vh; } #intro h1 { font-size: 5rem; line-height: 1.1; margin-bottom: 7rem; } #intro p { font-size: 1rem; margin-top: 0rem; } #intro .actions { display: none; } } 3.更换导航栏样式默认的导航栏样式如下：如图所示，大致可分为两个部分，左边是个人信息等的导航(当然不止这些，可以自行设置),右边是设置导航栏的图片，默认有github和500px,下面我们来自己进行一下配置首先，我们来看官方的readme.md文档: Home_name: 主页 # 主页名字 is_use_categories : true # 是否启用分类 categories_name: 分类 # 分类名字 is_use_archives : false # 是否启用归档 archives_name: 归档 # 归档名字 icon: # 导航栏上的图标 github: use: true # 是否启用 link: https://github.com/miccall # 点击地址 Twitter: use: false link: Facebook: use: false link: Instagram: use: false link: pages: # 自定义连接页 # link 的参数为相对路径，对应 hexo 目录下的 source 件夹内的相应文件夹 简历: link: &quot;/about/&quot; 团队 : link: &quot;/group/&quot; 图库 : link: &quot;/gallery/&quot; 标签: link: &quot;/tag/&quot; #自定义标签名 # link：“路径” MainFirst: # 导航栏下面的主页 name: Miccall Metro # 大标题名字 description: Welcome to my Blog # 第二标签 描述 pic_url: /img/me.jpg # 图片地址 goto_ulr: &quot;&quot; # 点击跳转 Gallery: # 图库页 title: Mr.metro description: Just another fine responsive 首先，左侧第一个内容主页在Home_name一栏进行设置，名字可以自定义，如改成Home Page第二个分类，是否启用分类is_use_categories默认设置为true，即启用分类，可以修改为false或者删除第三个归档。默认设置为false，同样可以修改参数的值来达到其他的效果，例如，设置为true后默认按时间分类icon设置了右侧的图标样式，图标均取自于fontawesome可以自定义，注意github里面的link要改成自己的github地址MainFisrt定义了位于导航栏下方的自我介绍的内容以及自己的图片，如果不想要，可以在themes\hexo-theme-Mic_Theme\layout_partial里面的mainfirst.ejs文件中设置display:none令其隐藏，具体代码如下: &lt;div id=&quot;main&quot; style=&quot;display: none&quot;&gt; &lt;!-- Main first s--&gt; &lt;article id=&quot;me&quot; class=&quot;panel&quot;&gt; &lt;header style=&quot;color: #000000;&quot;&gt; &lt;h1&gt;&lt;%- theme.MainFirst.name %&gt;&lt;/h1&gt; &lt;p&gt;&lt;%- theme.MainFirst.description %&gt;&lt;/p&gt; &lt;a href=&quot;&lt;%- theme.MainFirst.goto_ulr %&gt;&quot; class=&quot;jumplink pic&quot;&gt; &lt;img src=&quot;&lt;%- theme.MainFirst.pic_url %&gt;&quot; alt=&quot;&quot; /&gt; &lt;/a&gt; &lt;/header&gt; &lt;/article&gt; &lt;!-- Main first e--&gt; &lt;/div&gt; 4.给每一篇文章添加缩略图昨天本来已经写完这部分了，结果没有保存。。。只好重新开始o(╯□╰)o我们在官网给出的样例中可以看到里面的每一篇文章都有一个背景，逼格瞬间上去了有木有啊~（附样例） 然而我们刚配置好的博客打开来看文章背后是一片空白，就像这样子那怎么样才能达到官网样例的效果呢？仔细阅读官网的readme.md文档，发现里面有这样一个参数：thumbnail，后面加的注释意为缩略图 title: # 文章标题 date: 2017/3/27 13:48:25 # 文章发表时间 tags: - 标签1 - 标签2 (可选) categories: Algorithm # 分类 thumbnail: https://xxxxxxxxxx.png # 略缩图 可能我们第一眼看上去并没有看懂这个缩略图的意思，但是通读整篇文档，最有可能的就是这个了，那么我们按照文档里面给出的格式进行配置，因为我这里用到的是MarkdownPad2，可以直击添加图片，但这里注意一点，利用MarkdownPad2上传的图片链接的格式是 ![](https://xxxxxxxxxxxxx.png) 而文档中要求只需要https后面的东西，所以生成链接后直接拿出https://xxxxxxxxx.png部分，添加到文章头部的参数thumbnail后面，然后保存，执行hexo s，再次打开的效果就和例子里面的一样了φ(≧ω≦*)♪，OK大功告成! --- title: 关于在Mic theme配置下的一些心得 date: 2018-08-28 15:21:07 tags: Mic_theme hexo blog thumbnail: https://i.imgur.com/OBxizjH.jpg --- 最终效果如图 5.自定义样式说起来自己的博客肯定希望有点自己的个性，所以免不了就会想着这里改动一下，那里改动一下，然而直接在主题配置文件里修改如果还达不到个人的口味，就会希望一些更直接的修改，所以在这里我介绍一下直接对css文件进行修改的方法，我自己也在这里面改了不少了首先：主css文件在themes\hexo-theme-Mic_Theme\source\css下的mic_main.css文件中，打开来一看，有4000多行，那跑不了了，就是它了，我们只需要找到对应的选择器，即可在里面进行修改，同时该css文件中也加入了响应式的写法，同样可以自己修改，下面是我自己修改的几个例子： 1.导航栏样式的修改在mic_main.css文件1382行左右，可以看到这样一段代码 @media screen and (max-width: 980px) { #nav { display: none; } } 也就是说在屏幕宽度小于等于980px的时候，默认的导航栏样式消失，至于消失的导航栏去了哪，可以在博客界面右上角看到多了一个menu按钮，点开来看导航都在里面，同时在mic_main.css文2012行有如下代码 @media screen and (max-width: 980px) { #navPanelToggle { display: block; } } 意思很简单，就是显示那个menu按钮，这里面我们可以修改一下边界的宽度，因为现在主流的四种设备即为大屏，中屏，小屏，超小屏，其分类的边界为1200px,992px,768px,即1200px以上是大屏，也就是我们电脑或者显示器的屏幕，992px~1200px为中屏，一般是桌面显示器，768px~992px是小屏幕，一般是平板等，再往下小于768px的就是移动端也就是我们的手机了(以上数据来自于bootstrap的媒体查询宽度)，所以如果你觉得980px别扭的话，可以修改为其他值。点开menu菜单，除了几个链接，就是白白的背景，我们可以为背景加上自己喜欢的图片，设置方法:找到mic_main.css文件里面的id=#navPanel（可以在控制台里面直接找到），在其伪类before下添加背景图片的代码(mic_main.css下2053行上下),下面是我修改后的代码 #navPanel:before{ content: &quot;&quot;; background: url(../images/me2.jpg) center no-repeat; position: absolute; width: 100%; height: 100%; background-size: cover; overflow: hidden; top: 0; left: 0; } 再次打开观察效果 酷的一批啊，哈哈（ps:原来的文字是黑色的，大家可以自行修改，为了对比明显，我将其改为了白色）]]></content>
      <tags>
        <tag>Mic_theme hexo blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery鼠标事件总结（持续更新中）]]></title>
    <url>%2F2018%2F08%2F26%2FjQuery%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[jQuery鼠标事件jQuery鼠标事件–鼠标滚轮事件jQuery鼠标滚轮事件一共分为两类： 支持Firefox浏览器 针对火狐浏览器需要对DOMMouseScroll事件进行监听 支持其他浏览器 针对其他浏览器直接添加事件onmousewheel即可 还有一点两类浏览器不同的地方在于：Firefox浏览器在判断鼠标滚轮滚动的方向时与其他浏览器方向相反，其余四类浏览器使用event对象里面的wheelDelta事件来进行对鼠标滚动的判断。它的取值有两个，分别是+120和-120，+120表示滚轮向上滚动，-120表示滚轮向下滚动在Firefox中，使用event对象那个里面的detail事件来判断滚轮滚动的方向，同样取值有两个，分别为+3和-3，与另外四类浏览器不同的是，向上滚的时候detail的值是-3，向下滚是+3 下面请看代码实例–通过滚动鼠标滚轮，可以使输入框内的数字变大变小，同时可以在控制台内输出不同浏览器里面两种事件wheelDelta和detail的值，读者可以亲自验证后加深理解 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;01 鼠标滚轮事件&lt;/title&gt; &lt;style&gt; body{ margin: 0; padding: 0; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;text&quot; value=&quot;1&quot;&gt; &lt;script&gt; window.onload = function (ev) { /*根据浏览器的不同赋不同的值*/ var mouseWheel = navigator.userAgent.indexOf(&#39;Firefox&#39;) &gt;= 0 ? &#39;DOMMouseScroll&#39;: &#39;mouseWheel&#39;; var numVal = document.querySelector(&quot;input&quot;).value; /*打印当前输入框内的value值*/ console.log(numVal); if (document.addEventListener){ /*火狐浏览器*/ /*使用addEventListener监听DOMMouseScroll事件*/ document.addEventListener(&#39;DOMMouseScroll&#39;,function (e) { e = e || window.event; if (e.detail &gt; 0){ /*向下滚*/ console.log(e.detail); numVal--; document.querySelector(&quot;input&quot;).value = numVal; }else if (e.detail &lt; 0){ /*向上滚*/ console.log(e.detail); numVal++; document.querySelector(&quot;input&quot;).value = numVal; } },false); /*其他浏览器*/ /*onmousewheel 直接绑定鼠标滚轮滚动事件*/ window.onmousewheel = function (e) { if (e.wheelDelta){ if (e.wheelDelta &gt; 0){ console.log(e.wheelDelta); // console.log(&quot;上&quot;); numVal++; // console.log(numVal); document.querySelector(&quot;input&quot;).value = numVal; }else if (e.wheelDelta &lt; 0){ console.log(e.wheelDelta); // console.log(&quot;下&quot;); numVal--; // console.log(numVal); document.querySelector(&quot;input&quot;).value = numVal; } } } } } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;]]></content>
      <tags>
        <tag>jQuery mouse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[overflowhidden]]></title>
    <url>%2F2018%2F08%2F26%2Foverflow%20hidden%E7%9A%84%E5%A4%9A%E9%87%8D%E4%BD%9C%E7%94%A8%2F</url>
    <content type="text"><![CDATA[overflow:hidden的多重作用1.第一个当然就是最常见也最常用的溢出隐藏啦OK，首先是没有加overflow:hidden时的效果代码如下： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;镂空测试&lt;/title&gt; &lt;style&gt; body{ margin: 0; padding: 0; } .parentBox{ width: 200px; height: 200px; background-color: yellow; } .childBox{ width: 100px; height: 300px; background-color: #2b542c; z-index: 99; margin-left: 15px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;parentBox&quot;&gt; &lt;div class=&quot;childBox&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 这个效果的形成非常好理解，我们直接看加入overflow:hidden之后的效果部分代码如下（其余部分不变）： .parentBox{ width: 200px; height: 200px; background-color: yellow; overflow: hidden; } 可以看出子元素超出父元素的部分隐藏掉了，这里要注意一点：overflow:hidden一定是设置在父容器上面才能让子容器隐藏！ 2.第二个可能不太常用，那就是清除浮动在css常见的一种高度设置就是用子容器来撑开父容器的高度，这样不用给父容器设置高度，只需要依靠子容器自己的内容，边距等撑开高度，然而，当我们这个子容器设置了浮动属性后，效果就是下面这个样子：代码如下： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;镂空测试&lt;/title&gt; &lt;style&gt; body{ margin: 0; padding: 0; } .parentBox{ padding: 25px; width: 200px; background-color: yellow; } .childBox{ width: 100px; height: 300px; background-color: #2b542c; margin-left: 15px; float: left; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;parentBox&quot;&gt; &lt;div class=&quot;childBox&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 为什么会有这个样子，为什么子容器没有撑开父容器的高度？原因在这里：子容器设置float属性后（这里是float:left），脱离了原本的文档流，可以这么理解，在设置float属性前，子容器与它的父容器是出于同一个平面上的，我们暂且把这个平面叫做文档流，这样因为在同一平面，所以子容器有什么变化都会影响到父容器，所以给子容器设置高度能撑开父容器，而设置了float属性后，子容器脱离原本的文档流，从浏览器里面可以看到子容器是在父容器上面，用“平面”来解释就是子容器到了一个比父容器高那么一点的另一个平面上（实际上并不存在，类比去理解），那么在这个平面上子容器不管进行什么动作都不会影响父容器，也自然不会撑开父容器的高度了（在本例中与float属性有同样效果的还有position:absolute，也就是绝对定位和position:fixed固定定位，他们也会让元素脱离当前的文档流）然而在给父容器设置了overflow:hidden后， .parentBox{ padding: 25px; width: 200px; background-color: yellow; overflow: hidden; } 注意子元素此时是设置的float属性，如果设置了上文说到的position两个属性，那么overflow:hidden不会有效果 3.第三个作用与第二个差不多，也是消除浮动的影响，通过overflow:hidden来实现自适应布局直接代码+效果说话 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;镂空测试&lt;/title&gt; &lt;style&gt; body{ margin: 0; padding: 0; } .contentBox1{ width: 200px; height: 200px; background-color: yellow; float: left; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;contentBox1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;contentBox2&quot;&gt;内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 为什么会有这样的效果？因为float的初衷就是也只是实现文字环绕效果，只不过后来人们用它来布局，慢慢的就舍弃了它的本质了然后我们给第二个div加上overflow:hidden属性 .contentBox2{ overflow: hidden; } 现在的效果：可以看到的是，文字全被“挤到”了右侧，就想是两个div之间插入了一堵无形的墙把两个div给隔开了（这样的结构满足了流式布局的要求，可以作为左侧固定，右侧自适应的一个模板，即两栏自适应）关于overflow:hidden为什么能清除浮动，我会在另一篇博文中详细解释]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
</search>
