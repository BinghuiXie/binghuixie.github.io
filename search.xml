<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[React Hooks]]></title>
    <url>%2F2019%2F10%2F10%2FReact-Hooks%2F</url>
    <content type="text"><![CDATA[最近才看了 React Conf 2018 的发布会，对 Hooks 很感兴趣，所以写了一个 demo 同时总结了一下 Hooks 的使用。项目地址：React Hooks Test React Hooks 的出现，提供了一种能在函数式组件中使用 state， componentDidMount， componentDidUpdate，componentWillUnMount 几个钩子的功能，同时，使用 Hooks 能对逻辑进行更好的封装。 useState HooksuseState 方法提供了在函数组件中使用，修改 state 的能力，useState 方法返回两个值，第一个是 state 的值，第二个是可以修改这个值的函数，类似于 setState，useState 方法接收一个初始值，会将其作为返回的第一个参数的默认值。 import React, { useState } from 'react' function Count ( props ) { /* 默认 count = 0 */ /* 可以直接在组件中使用通过 useState 返回的变量 */ const [ count, setCount ] = useState(0); return ( &lt;div> &lt;p>You click { count } times &lt;/p> &lt;button onClick={ setCount( count + 1 ) } /> &lt;/div> ) } 上面的代码是利用 Hooks 写的，如果对应 classComponent，就是这个样子： import React, { useState } from 'react' export default class Count extends React.Component { constructor ( props ) { super (props); this.state = { count: 0 } } render () { return ( &lt;div> &lt;p>You click { this.state.count } times &lt;/p> &lt;button onClick={ this.setState({ count: this.state.count + 1 }) } /> &lt;/div> ) } } 对比两段代码可以看出，使用 useState 返回的 count 和 setCount 代替了类组件中的this.state.count 和 setState的作用。 使用 Hooks 的时候注意有一点，需要将对 Hooks 的使用放在函数组件的最上面，也就是说，不能放在条件判断，循环语句或者潜逃的函数内部里面使用 Hooks，比如： if ( true ) { const [ count, setCount ] = useState(0); } while ( true ) { const [ count, setCount ] = useState(0); } function Example ( props ) { function test () { const [ count, setCount ] = useState(0); } return ( &lt;div>example&lt;/div> ) } 上面这三种写法都是不可以的。为了帮助我们检查是否正确使用了 Hooks， React 官方提供了一个插件，安装插件以后，在最外层目录下新建 .eslintrc文件，添加如下配置： { "plugins": [ // ... "react-hooks" ], "rules": { // ... "react-hooks/rules-of-hooks": "error", "react-hooks/exhaustive-deps": "warn" } } 就可以为我们检测 Hooks 的使用是否正确了，不正确的话会抛出错误。 useEffect Hooks在平常的类组件中（class component），componentDidMount，componentDidUpdate，componentWillUnmount三个钩子比较常用，一般情况下，在componentDidMount设定绑定事件监听，发送 ajax 请求，在componentDidUpdate进行组件更新后同时更新数据的操作，在componentWillUnmount取消监听或其他操作，防止内存泄露。但在很多情况下，componentDidUpdate和componentDidMount的逻辑是重复的，比如： class Example extends React.Component { constructor(props) { super(props); this.state = { count: 0 }; } componentDidMount() { document.title = `You clicked ${this.state.count} times`; } componentDidUpdate() { document.title = `You clicked ${this.state.count} times`; } render() { return ( &lt;div> &lt;p>You clicked {this.state.count} times&lt;/p> &lt;button onClick={() => this.setState({ count: this.state.count + 1 })}> Click me &lt;/button> &lt;/div> ); } } 在上面这个例子里面就需要将同一个逻辑在不同的钩子函数中重复两次，这是因为 React 本身没有提供一个能在挂载后和组件每次更新时同时起作用的一个 API，所以即使我们能把重复的逻辑抽离出来，但还是要写两次。Hooks 的出现改变了这样的写法： import React, { useState, useEffect } from 'react'; function Example() { const [count, setCount] = useState(0); useEffect(() => { document.title = `You clicked ${count} times`; }); return ( &lt;div> &lt;p>You clicked {count} times&lt;/p> &lt;button onClick={() => setCount(count + 1)}> Click me &lt;/button> &lt;/div> ); } 使用 useEffect，它会在组件每一次更新（包括挂载）的时候都执行一次，这样就实现了componentDidMount和componentDidUpdate的功能。useEffect还可以实现componentWillUnmount的功能，方法是返回一个函数，React会在该去清除的时候执行这个函数： import React, { useState, useEffect } from 'react'; function FriendStatus(props) { const [isOnline, setIsOnline] = useState(null); useEffect(() => { function handleStatusChange(status) { setIsOnline(status.isOnline); } ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange); // 返回一个函数，在销毁这个组件的时候会执行这个返回的函数 return function cleanup() { ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange); }; }); if (isOnline === null) { return 'Loading...'; } return isOnline ? 'Online' : 'Offline'; } 注意，React 会在组件每一次新的渲染之前清除掉之前的 effect ，不是只有最终组件销毁的时候才执行一次，关于为什么需要在每一次更新都调用一次 effects，参考官方文档.useEffect还接收第二个参数，第二个参数为一个数组，只有数组里面的变量有变化，React 才会去执行上面的 effects，否则不会去执行，这是一种优化的操作 useEffect(() => { document.title = `You clicked ${count} times`; }, [count]); 在上面这个例子中，只有 count 变化了才会去重新执行 effect，一般来说建议把 effect 里面涉及到的变量都加到参数列表里面，如果数组中有多个变量，React将重新运行该 effect，即使其中只有一个与之前的不同。如果想只运行和清除这个 effect 一次，可以传入一个空数组：[]]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html css 使用小技巧（持续更新中）]]></title>
    <url>%2F2019%2F08%2F07%2Fhtml-css-%E4%BD%BF%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言在实际项目的开发中，很多开发者下意识的会把js作为开发大头，css，html仅仅是辅助工具，但是css和html用好了也能在一定的程度上缩减js的代码，下面总结的所有使用的技巧都是我在实际项目开发过程中遇到过的一些比较绕的问题，一开始是想用js来解决，但是后面想到了用css解决的办法，觉得还有点用处，即在这里分享，知道的大佬们看看就行，别喷（怂）。 img { width: 600px; display: block; margin: 0 auto; } input与label实现充满父容器宽度可点击多选单选框最近在做一个在线练习的平台，包括编程题的练习和选择题的练习，用到的技术栈是React+Next.js，其中要实现的一个功能是选择题（包括单选和多选）选中的时候加一个背景颜色，就是下面这种效果：最开始我的解决办法是设定一个isClciked变量，然后通过它的值true或者是false来给被点击的元素添加一个active类，通过这个类来改变被点击元素的背景颜色，然后再次点击的时候再去掉这个类，但是这样做有几个问题： 就我目前来看，单独的一个点击变量应该是只适用于单选，如果是多选的话一个变量显然是不行的 因为我用的是React，给元素添加类势必要操作DOM，但既然React是数据驱动的框架，所以我还是不太想操作DOM 后面针对单选题的话我又想到一种解决办法：因为我的四个选项是遍历出来的，每一个都有一个index，然后我在state里面设置了一个currentIndex变量，然后点击一个框的时候通过setState把currentIndex改成点击的index，这样我在再循环出来的每一个DOM结构上面都添加一个判断：当currentIndex === index的时候改变其样式。但是这种解决办法我只是解决了单选，多选还是没办法。这里面一个问题就是因为我想实现一个框内任意地方都可以点击，从而在点击的时候改变样式，而不是像单纯的input单选和多选框那种只能点击那个圆圈或者方框选中，所以我想到了label标签，于是有了下面这种最终的实现办法，先把代码贴出来：我是这样子实现的：因为label的for属性（在React里面是htmlFor）可以扩大input的点击区域，所以由label来做这一个占满父容器宽度的选择框，父容器的大小完全有label撑开，同时给input设置一个position: absolute; opacity: 0这样不影响label的布局同时还看不到，然后因为我的数据里面是type为 1 代表单选，2 代表多选，所以通过type={type === 1 ? ‘radio’ : ‘checkbox’}来设置input的类型，然后通过input的:checked伪类来使input被选中的时候改变label的背景色，注意这里面label要放在input后面，这样兄弟选择器才可以选到被点击的input的兄弟label元素。这样子的话单选多选就都实现了，而且没有用到js，总的来说还是对这个方法蛮满意的。]]></content>
      <tags>
        <tag>html css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[部署vue项目到服务器上]]></title>
    <url>%2F2019%2F08%2F05%2F%E9%83%A8%E7%BD%B2vue%E9%A1%B9%E7%9B%AE%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%2F</url>
    <content type="text"><![CDATA[前言这几天在阿里云上买了一个轻量级服务器，想着用来在上面部署一下，学习一下这方面的知识，从昨天开始到现在写了一个简单的vue的登录页面并将其放到了服务器上面，后端服务是自己用node写的，下面是总结的一些步骤。 正文我是用vue写了一个简单的登录页面部署在了自己在阿里云买的服务器上项目地址：https://github.com/BinghuiXie/node-exercise-vue.git具体操作如下：首先创建一个vue的项目，为了方便我就没有自己配环境，而是使用了官方的脚手架vue-cli，具体搭建步骤如下： 安装vue-cli：npm install -g @vue/cli 创建一个vue的项目：vue create vue-node-deploy-demo（vue-node-deploy-demo是项目名称） vue-cli会自动帮我们搭建好一个vue的项目，其中各种配置我就直接走了默认的配置，搭建好以后在命令行中执行cd vue-node-deploy-demo，然后执行npm run serve，项目运行起来以后就可以在浏览器中输入localhost:8080看到这个项目默认的样子了，接下来我们要将这个项目放到服务器上（因为前面给出项目地址我就不贴代码在这边了）。打开xshell（如果没有可以去官网下载），连接服务器，我的是用ssh连接的。连接成功以后，首先我们需要运行sudo apt-get update(apt-get 是 Ubuntu的包管理工具，就像是npm一样，PS：如果你是使用root权限登录的话，可以不加sudo，因为我是用root权限的，所以后面的命令我也就都不加sudo了)更新这个包管理工具。接下来需要把vue的项目上传到 github ，方便后面我们 clone 到服务器上面。上传到github以后，我们继续回到xshell操作，首先需要在服务器上安装nginx，运行apt-get install nginx。因为我使用的是vue-vli3，需要node8或者以上的版本，所以还需要再服务器上安装node，但是如果直接运行apt-get install node安装的不会是最新的node版本，如果需要安装最新版node，需要这么来操作：首先运行：curl -sL https://deb.nodesource.com/setup_10.x | sudo bash然后执行：apt-get install -y node安装好以后运行一下 node -v npm -v 可以看到版本的话（我安装的是最新的10以上的LTS版本）就说明成功了。接下来我们再浏览器中输入服务器的ip地址，打开应该可以看到一个nginx的欢迎页面，这个页面是哪里来的，其实就在我们服务器上，在xshell中执行 cd /var/www/html ls 在这个文件夹下面我们可以看到有一个index.nginx-debian.html文件打开来看一下这个文件 cat index.nginx-debian.html 得到了一堆html的代码，仔细看一下发现就是当我们访问ip地址的时候返回的html页面的代码。 在该文件夹下面新建一个vue的文件夹用来存放用于部署的vue的项目 mkdir vue 然后进去： cd vue因为之前我已经讲测试用的vue的项目放到了github上面所以可以在服务器这边从github上clone下来，在该文件夹下执行 git clone https://github.com/BinghuiXie/node-exercise-vue.git app (将线上项目克隆下来到一个叫app的文件夹下面) 然后可以运行ll命令看一下，就可以看到app文件夹已经在里面了接下来 cd 进 app 里面 cd app 现在这个项目直接执行npm run serve还没办法跑起来，因为在本地上传github的时候node_modules放在了.gitignore里面不会跟着传到线上，所以我们需要先安装一下依赖，执行： npm install 安装完成以后再次运行npm run serve，项目启动成功，此时我们就可以通过服务器ip地址:8080在线上进行访问了。接下来我们需要修改一下nginx配置 cd /etx/nginx/sites-available 这个里面有一个default文件，这个就是默认的nginx配置文件，我们用vim对他进行一些修改，执行 vi default 其中你可以看到一行： root /var/www/html这就是我们为什么访问ip地址的时候看到的是nginx的欢迎页面了，所以我们只需要把它改成vue项目的地址即可： 修改 root /var/www/html 为： root var/www/html/vue/app/dist dist文件夹是打包好的vue的项目，需要在 var/www/html/vue/app 下运行一下 npm run build即可。修改完default文件后，保存退出。修改完nginx配置文件以后，需要看一下nginx是否能正常运行，执行命令 nginx -t 如果出来下面这一段描述，就说明没问题修改完nginx配置文件以后需要重启一下nginx，运行 service nginx restart // 每次修改完nginx配置文件都要运行一下 接下来再去访问 ip地址，就可以成功的看到我们的vue的项目了！ 接下来还有一些问题，当我去访问这个ip地址下面的任何一个路径的时候，例如: ip地址/abc，就会返回一个404页面，但是我想让它不管在什么路由下都返回这个vue的项目页面，所以cd 到nginx的配置文件中，添加一行代码： // nginx default server_name _ ; // 在server_name _; 后面添加这一段代码 error_page 404 /; 然后保存退出重启nginx，再去访问就没有任何问题了，不管在哪一个路径下，看到的都是这个vue的项目而不是404的页面了。现在我在本地对这个vue的项目进行了一些修改，那怎么反映到服务器上对应的项目呢？首先需要推到线上，执行 // 本地的 vue 项目中执行 git add . git commit -m &quot;...&quot; git push 然后再服务器上对应的目录下(/var/www/html/vue/app)执行 git pull 代码更新以后需要重新打包，所以重新运行 npm run build 再次访问，就可以看到更新后的页面啦！！ 部署过程中遇到的问题以及解决办法服务器上执行clone报错原因：服务器没有和github连接解决办法：在服务器上生成一个ssh key，然后把它添加到github上面就可以了。具体操作： cd /root/.ssh ssh-keygen // 生成一个ssh key，然后一路回车 cat id_rsa.pub // 得到ssh key 进入github的vue的项目中，打开Settings标签页，点击左侧导航栏的deploy keys选项，然后add deploy key，把刚刚生成的ssh key添加进去就好了。都弄完以后cd 到原来的路径，再clone一下就好了 cd /var/www/html/vue git clone https://github.com/BinghuiXie/node-exercise-vue.git app 项目启动以后在浏览器输入 ip地址:8080打不开项目原因：阿里云那边服务器端口默认只开一个80，我们需要在防火墙那边也打开8080端口解决办法：登录阿里云，点击轻量级应用服务器点进去，在左侧导航栏中选择安全-防火墙-添加规则在弹框中端口范围输入8080，其余默认，点击确定再次打开项目地址，就可以访问到了 服务器上执行npm install报错原因： 我的报错原因是因为node的版本不对解决办法：卸载node重新安装最新版本具体操作：运行 apt-get remove nodejs apt-get remove npm 接下来到 /etc/apt/sources.list.d 目录下，删除任何一个你看到的node list cd /etc/apt/sources.list.d rm -r node-list 然后运行 apt-get update which node 看看哪里还有node，都删了，然后重新安装，运行 curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.5/install.sh | bash 打开一个新的终端，运行 nvm ls 然后安装最新版本的node nvm install v10.16.1 然后查看一下node的版本，安装成功，这样再去执行npm install就没有问题了。]]></content>
      <tags>
        <tag>server， node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一次面试总结]]></title>
    <url>%2F2019%2F06%2F06%2F%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言前段时间打着暑期实习的想法投了一些公司，只接到了途牛的回复，抱着试一试的心态就去了，从开始到结束总共大概被怼了一个多小时，差点心态崩了，面试后也把问到的问题都罗列了出来，放在这里总结一下。 正文自我介绍什么的不说了，直接先罗列一下被问到的知识点： Q: 个人所理解的前端 Q: vue，react，jQuery的区别 Q: 谈一下MVC与MVVM的区别 Q: vue底层是如何实现数据的双向绑定的 Q: 在vue中，兄弟组件，父子组件之间如何传值 Q: 谈一下vuex Q: 说一下vue有哪些生命周期函数，如果要进行ajax请求，那么该放在哪一个钩子里 Q: setState Q: css 中的display: none与visibility: hidden 的区别 Q: 简单的谈一下css的动画(transition与animation) Q: 了解过meta标签吗？有什么用处 Q: rem和px的区别 Q: 针对iPhone 4/5/6三种设备，如何利用一套布局方案做到适配 Q: 如果用px实现移动端布局该怎么做 Q: 说一下你所理解的用户体验 Q: 如何减少首页白屏的时间 Q: 为什么script引入的js文件是一个加载完并且解析完才执行下一个而css文件是同时加载，加载完再解析 Q: ES6 let，const， var 的区别 Q: ES6 箭头函数 Q: ES6的模块化 Q: jQuery中的ajax的参数有哪些 Q: 什么是回调地狱？如何解决？如何解决Promise调用链过长的问题 Q: GET 和 POST 的区别 Q: 说出你知道的几种跨域方式 Q: jsonp 有什么缺点 Q: 有没有自己启动过一个服务 Q: 有没有用过gulp 看到这里可以先暂停一下，想一想上面的问题，如果都能完美的打出来那就没什么问题了，如果有的会有卡壳，就再往下看。 Q: 个人所理解的前端我认为的前端就是和用户浏览，参观相关的所有东西都可以被放进前端的范畴，包括页面的展示，和用户的交互行为，以及用户体验等等 Q: vue，react，jQuery的区别我的回答主要是从设计模式提的区别，jQuery是一种MVC设计模式的框架，与vue和react相比，jQuery还是需要大量的操作DOM来达到改变视图的目的，而vue和react是面向视图层的框架，注重的是数据，只要数据发生了变化，页面就会响应式的变化。vue和react的区别临时答了一个数据绑定方式，vue是双向绑定，react是单项绑定数据流。查了一下，补充一下回答：vue和react都支持服务端优化（SSR），都利用了虚拟DOM，都是组件化开发的思想 Q: 谈一下MVC与MVVM的区别Q: vue底层是如何实现数据的双向绑定的Q: 在vue中，兄弟组件，父子组件之间如何传值Q: 谈一下vuexA: vuex是vue是的一个状态管理的框架，vuex的出现使组件之间的通信变得非常方便，vuex形象的可以理解为在所有组件的最上层一个公共区域用于存储数据，同时该数据被几个组件所共有，当一个组件中修改了这个数据，通过派发action再commit mutations就可以更新state里面的数据，从而实现对所有依赖这个数据的页面的视图更新。 Q: 说一下vue有哪些生命周期函数，如果要进行ajax请求，那么该放在哪一个钩子里创建阶段：beforeCreate / Create挂载阶段：beforeMount / Mounted数据更新时会触发这两个钩子函数：beforeUpdate / updated组件销毁时会触发：beforeDestroy / destroyed ajax Q: setStateQ: css 中的display: none与visibility: hidden 的区别Q: 简单的谈一下css的动画(transition与animation)Q: 了解过meta标签吗？有什么用处Q: rem和px的区别Q: 针对iPhone 4/5/6三种设备，如何利用一套布局方案做到适配Q: 如果用px实现移动端布局该怎么做Q: 说一下你所理解的用户体验Q: 如何减少首页白屏的时间Q: 为什么script引入的js文件是一个加载完并且解析完才执行下一个而css文件是同时加载，加载完再解析Q: ES6 let，const， var 的区别Q: ES6 箭头函数Q: ES6的模块化Q: jQuery中的ajax的参数有哪些Q: 什么是回调地狱？如何解决？如何解决Promise调用链过长的问题Q: GET 和 POST 的区别Q: 说出你知道的几种跨域方式Q: jsonp 有什么缺点Q: 有没有自己启动过一个服务Q: 有没有用过gulp]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS几种常见的居中方法以及他们的优缺点]]></title>
    <url>%2F2019%2F05%2F03%2FCSS%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B1%85%E4%B8%AD%E6%96%B9%E6%B3%95%E4%BB%A5%E5%8F%8A%E4%BB%96%E4%BB%AC%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[第二次小程序项目报错总结]]></title>
    <url>%2F2019%2F04%2F28%2F%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%A1%B9%E7%9B%AE%E6%8A%A5%E9%94%99%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言第一次写小程序的项目的时候没有总结报错，这次第二次写的时候遇到了一些已经遇到过的报错然而还是花了很长时间才解决，所以还是想着留一个地方记录下来吧。 正文1.Maximum call stack size exceeded;我在父组件里面调用了一个子组件，子组件里面有一个轮播图，是借助了小程序的swiper组件实现的，大致的代码如下：父组件：子组件：然后就给我报了这个错：我在网上搜了很多，大多都是递归调用组件而导致的错误，说白了就是组件名字的重复。在我的代码中，利用到了i&gt;swiper组件，而子组件的name是叫做Swiper，正式由于这个原因所以会报错，我把子组件名字改成SwiperComponent就没问题了 2.axios异步获取数据用来渲染页面axios获取数据是异步的，这就意味着用axios发出请求去拿数据渲染页面的时候，数据可能还没有拿到，所以页面渲染不出来就会报错。针对这样子有一种解决办法就是借助state和computed属性。当利用axios发出请求后，直接派发action，然后触发mutations，同时传入获取到的数据作为入参，修改state里面对应的数据 // component.vue &lt;template&gt;&lt;/template&gt; &lt;script&gt; import axios from &#39;axios&#39; export default { name: &quot;ComponentName&quot;, data () { return { item: [] } } beforeMount () { axios.get(&#39;url&#39;) .then(res =&gt; { this.item = res.data; // 直接触发 dispatch，获取到的数据作为入参传过去 this.$store.commit(&#39;functionName&#39;, this.item) }) } } &lt;/script&gt; &lt;style&gt;&lt;/style&gt; // store/state.js export defult{ dataArray: [] } // store/mutations.js export default { // 参数 state 接受 state里面的所有数据， data 是传过来的数据 functionName (state, data) { // 修改 state 里面的数据 state.dataArray = data; } } // 在需要用到该数据的组件里使用 &lt;template&gt;&lt;/template&gt; &lt;script&gt; export default { name: &quot;...&quot;, data () { return { ... } } computed: { data () { return this.$store.state.dataArray } } } &lt;/script&gt; 经过这样子操作一下，异步获取的数据会被存放到state里面，而另一个组件在使用state里面的这个数据的时候，如果这个数据还没有获取到，那就是空，页面上没有什么要显示的东西，当数据拿到以后，state里面的数据也会更新，因为另一个组件是在computed属性里面使用的这个数据，所以当这个数据变化的时候，页面就hi更新，这样就解决了数据获取不到，使用的时候是undefined报错的事情了。]]></content>
      <tags>
        <tag>mpvue， 小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vertical-align深入理解]]></title>
    <url>%2F2019%2F04%2F17%2Fvertical-align%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[vertical-align这个属性算是比较常用的一个，一般来说常用的就是把它的值取为middle，但是就像float那样，不去深入理解一个属性就去大量的使用很容易出现莫名其妙的“问题”，所以还是有必要对其进行深究的。首先提出一个问题，看一下这段代码： &lt;div class=&quot;container&quot;&gt; &lt;span&gt;文字&lt;/span&gt; &lt;/div&gt; .container{ margin-top: 100px; line-height: 32px; background-color: #FFA500; } .container &gt; span{ font-size: 24px; } container容器的高度是多少？答案可能出乎大多数人的意料，我在Chrome和Opera里面查看元素的高度是35px，FireFox是34.5px，反正都不是32px，这个就是因为vertical-align作用的结果。 vertical-align作用前提深入vertical-align第一步先从它的作用范围看起，并不是所有的元素设置了vertical-align都会起作用的，而是只有内联元素和display值为table-cell的元素，也就是说，vertical-align只能作用在外部盒子为inline的元素和display值为table-cell的元素上，也就是inline,inline-block,inline-table，和table-cell的元素上。除此之外，因为float和绝对定位会使元素块状化，所以在浮动元素和绝对定位元素上使用vertical-align也是毫无效果的。 vertical-align和line-height之间的关系前面那个行高与最终高度不相同的例子，在这节就可以解释了。为了解释清楚这个点，我们需要脑补一些东西进去，一个是空白节点，前面的文章说过每一个内联元素都会产生一个行框盒子，而每一个行框盒子前面都会有一个空白节点，它的宽度是 0 ，但是它影响却是不小，这里我们把一个小写字母 x 放到span前面作为空白节点的形象化代表，同时为了方便理解，在span内部的文字后面也加一个小写字母 x 。也就是下面这个样子 &lt;div class=&quot;container&quot;&gt; x&lt;span&gt;文字x&lt;/span&gt; &lt;/div&gt; OK。现在分析一下，充当空白节点的形象化代表的 x 的字体大小是默认的字体大小，也就是14px，而span里面的 x 的字体大小时24px。字体越大，对应的基线(baseline)就会往下移，这样的话，前面 x 和后面 x 的基线实际上不是在一个位置的，而是后面字体较大的那部分对应的基线靠下一点，然而，因为文字默认都是基线对齐，所以此时基线不在一条水平线上的情况是不允许的，所以此时文字会上下平移以使基线对齐。由于受到line-height是32px的影响，前面代表空白节点的字符 x 和后面的span的高度都是32px，此时平移了以后，就会在下面多出一块，这样就导致了最终的高度不是32px而是比32px大的原因了。用一张图来解释：(忽略中间那个加载。。。)那么，知道了为什么实际高度大于所给高度，就可以针对去解决了，实际上还是这个空白节点影响的，所以第一种解决办法是可以直接父元素加一个font-size: 24px，让空白节点和后面span里面的字号一样大小。第二种办法：因为文字默认是基线对齐，才会出现字号不一样的时候基线平移，所以可以通过vertical-align改一下对齐方式，比如说top或者bottom就行了。（给子元素span加vertical-align）。 图片底部间隙问题知道了字号以及对齐方式导致的高度问题的原理以及解决办法，再来看一个更常见一些的一个问题： &lt;div class=&quot;box&quot;&gt; &lt;img src=&quot;https://biaoqingba.cn/wp-content/uploads/2018/03/9ab1c5b036bac03-240x180.gif&quot; alt=&quot;&quot;&gt; &lt;/div&gt; .box{ outline: 1px solid #000000; text-align: center; background-color: #FFA500; } 浏览器看到的效果如下：图片下边沿和父元素下边线之间有一点距离，为什么？导致这个现象的就是这三个玩意：空白节点，line-height还有vertical-align。还是把空白节点看车一个 x ，这样的话就相当于图片前面多了一个字符，因为字符是默认以基线对齐，而替换元素默认是下边沿对齐，也就是图片的下边沿和 x 的基线是对齐的，但是从上面那个例子可以看出， x 的基线下面是还有一段高度的（x基线往下产生的行高，或者说半行距），正是这段高度撑开了父容器，使得图片和容器底部岔开了一小点距离。有图看的更明白系列~~~知道了原理，再消除就简单了。 1、我们知道内联元素前面才会存在空白节点，所以第一个方法就是把图片元素块状化也就是加一个display:block。 2、从上图中可以看出，顶开父容器的那一小段距离其实是半行距使然，既然是半行距的锅，就是说明line-height比font-size大，所以只需要给line-height设置一个足够小的值，比如说 0 ，就可以了（在父容器上面设置）。 3、间隙产生的一个原因就是基线对齐，所以只需要更改vertical-align的值即可，middle，top，bottom都是可以的。vertical-align导致margin失效margin在一定情景下是会失效的，vertical-align的默认值baseline就会导致margin取负值的时候“失效”，来看下面这个例子： &lt;div class=&quot;box&quot;&gt; &lt;img src=&quot;puui.qpic.cn/qqvideo_ori/0/a0774w0rp4u_496_280/0&quot; alt=&quot;&quot;&gt; &lt;/div&gt; .box &gt; img{ height: 96px; margin-top: -200px; } 给img设置了负的上外边距为200px，远超图片自身的高度，理论上来说，设置上外边距负值元素会向上平移，而因为负边距的绝对值大于自身高度，应该是平移出去父元素才对，但是实际效果是这样子的：而且，就算给margin-top设置成-9999px，图片也不会向上平移，而是还是这个样子的，就好像margin-top“失效了”。其原理是这样子的：图片的前面有一个空白节点，而在CSS世界中，非主动触发位移的内联元素是不可能跑到计算容器之外的，导致图片被空白节点的vertical-align:baseline给限制死了，我们用一个字符 x 代替空白节点，看的清楚一点因为字符 x 下边缘和图片下边缘是对齐的，而且字符 x 因为是非主动定位，它是不可能超出父容器的范围的，所以既然 x 的位置没办法变化，那图片的下边缘是和 x 的下边沿（基线对齐的），所以再怎么给图片设置负的上外边距都不可能使图片平移出父容器，看起来就像是margin失效了！ inline-block和baselinevertical-align属性的默认值是baseline，对于字符来说就是小写字母 x 的下边缘，对于图片等替换元素来说就是替换元素的下边缘，但是如果是inline-block元素，就复杂的多了，具体有两种方式： 1、如果一个inline-block元素的子元素不是内联元素(里面没有内联元素)，或者这个inline-block元素的overflow属性不是visible，那这个inline-block元素的基线就是它的margin的底边缘。 2、如果不满足是上面的条件，也就是元素下面有内联元素或者overflow属性是visible，那么基线就是inline-block元素里面最后一行内联元素的基线。 辅助一个例子来理解： &lt;div class=&quot;container&quot;&gt; &lt;span class=&quot;inline-block-element&quot;&gt;这个inline-block元素里面有文字也就是内联元素，它的基线就是最后一行内联元素的基线。x&lt;/span&gt; &lt;span class=&quot;inline-block-element&quot;&gt;&lt;/span&gt; &lt;/div&gt; .inline-block-element{ display: inline-block; width: 200px; height: 200px; background-color: #4D77C6; } 两个span，第一个span里面有内联元素，第二个没有，根据规则，有内联元素的inline-block元素的基线是其最后一行内联元素的下边缘，没有内联元素的inline-block元素的基线是其magin下边缘，如果没有magin，基线位置就是边框最下缘，如果没有边框就是padding最下边，以此类推。。。所以最终的效果就是：这样就不难理解为什么是这样子对齐了。 番外篇：背景小图标和文字对齐问题一个小的背景图标，后面跟上一个描述性的文字，是前端开发中经常会碰到的，而这个图标和文字居中对齐，就是这种应用中一个比较头疼的问题，这里用之前写的line-height辅助其他属性来解决一下。思路：一个放置图标的inline-block元素，它的基线取决于内部是否有内联元素和overflow属性的取值，那么如果这个放置图标的inline-block元素的基线和文字的基线对齐，同时二者的高度由一致，那么就会自动的形成垂直居中效果。根据这个思路，有三个要点需要注意： (1) 图标高度和行高都是相等的(因为字符占据的高度实际上是由line-height决定的) (2) 图标标签里面永远有一个字符。这个字符的作用是为了保持基线的位置，不是为了显示，所以可以利用伪元素before或者after生成一个空格字符 (3) 图标元素不使用overflow: hidden，这样也是为了保证基线不是元素下边缘。 所以解决办法如下： .box { /*保证行高是20px，这样子元素字符就会继承这20px*/ line-height: 20px; } .icon { display: inline-block; width:20px; /*图标高度和字符高度相同*/ height:20px; white-space: nowrap; } .icon:before { /* 生成一个空格字符保证基线的统一 */ content:&#39;\3000&#39;; } .icon-delete { background: url(./delete2.png) no-repeat center; } .large { font-size: 20px; } &lt;div class=&quot;box&quot;&gt; &lt;h4&gt;1. 标签里面有“删除”文本&lt;/h4&gt; &lt;p&gt;&lt;i class=&quot;icon icon-delete&quot;&gt;&lt;/i&gt;随便什么文字&lt;/p&gt; &lt;h4&gt;2. 字号变大&lt;/h4&gt; &lt;p class=&quot;large&quot;&gt; &lt;i class=&quot;icon icon-delete&quot;&gt;&lt;/i&gt;删除 &lt;/p&gt; &lt;p class=&quot;large&quot;&gt; &lt;i class=&quot;icon icon-delete&quot;&gt;&lt;/i&gt;随便什么文字 &lt;/p&gt; &lt;/div&gt; 总结总之，对于内联元素，一定要考虑到空白节点和vertical-align默认以基线对齐的影响。最后实现一个水平垂直居中弹框 &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;dialog&quot;&gt; &lt;div class=&quot;content&quot;&gt; 内容 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; .container{ position: fixed; top: 0; right: 0; left: 0; bottom: 0; background-color: rgba(0, 0, 0, .5); text-align: center; font-size: 0; } .container:after{ content: &#39;&#39;; display: inline-block; height: 100%; vertical-align: middle; } .dialog{ display: inline-block; background-color: #ffffff; border-radius: 8px; width: 300px; height: 200px; vertical-align: middle; text-align: left; font-size: 14px; padding: 24px; box-sizing: border-box; } 效果如图：解释如下：container容器固定定位，格式化高度占满全屏，text-align: center;可以让inline-block元素居中显示，设置字体大小为 0 ，这样的话用来代替空白节点的字符 x 的中心位置就是container容器的上边缘（字体大小为 0 时，基线和中线就会重合，而中线位置就是 x 的中心位置）。理解after伪元素就是一个空白节点，此时这个节点宽度为0，高度为100%，给这个伪元素设置了vertical-align: middle;，此时伪元素的中线和 x 的中线对齐。如果中心点位置不动，这个伪元素应该会有一半的位置在container容器外面，但是在CSS中是默认左上方排列对齐的，所以，伪元素和原本在容器上边缘的 x 的中心点就一起向下移动了半个容器的高度，也就是此时 x 的中心点就在container容器的中线处。弹框元素dialog也设置了vertical-align: middle;，此时就会和 x 的中心点对齐，所以就实现了垂直居中的效果。]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css世界的各种盒子]]></title>
    <url>%2F2019%2F04%2F15%2Fcss%E4%B8%96%E7%95%8C%E7%9A%84%E5%90%84%E7%A7%8D%E7%9B%92%E5%AD%90%2F</url>
    <content type="text"><![CDATA[CSS盒子模型HTML所有的元素都可以看做一个一个的盒子，HTML标签的嵌套可以看做是一个一个盒子的嵌套，这些嵌套的盒子就是所谓的盒模型。 关于IE盒模型的说法在前几年，前端开发人员比较头疼的一点就是多个浏览器直接差异的适配，尤其是IE浏览器，这是个让很多前端开发人员头疼的事情，IE浏览器在很多细节上都有自己独特的实现，在盒模型上也不例外，但是，现在IE浏览器已经被微软弃用了(万岁！)，所以这篇文章就不讨论IE浏览器的盒子模型了，而是去讨论一下主流的W3C标准的盒子模型。 W3C标准盒模型这是一种W3C制定的标准的盒子模型，也是普遍能被开发者所接受的一种主流盒模型。在Chrome浏览器中，按一下F12打开控制台，会看到这么一个图对于有经验的开发者来说，这张图早就已经看见了无数遍了，但是这里还要啰嗦一下，方便后文的展开： margin区域：外边距区域，透明部分 border局域：元素的边框 padding区域：元素的内边距，一般来说是透明的 content区域：内容区域 那么了解这些盒子有什么用处的？其中一个就是可以帮助我们更好的设置元素的宽高 元素宽高作用细节以元素的宽度举例，width属性设置是作用在内在盒子上的，这个内在盒子（下面会有具体对内在盒子的说明），和上面说道的几个区域又密切相关，总体来说，它被分为四种盒子，即内容盒子(content box)，内边距盒子(padding box)，边框盒子(border box)，外边距盒子(margin box)，如果对这几个英文单词有点印象那你可能是想到了box-sizing的常用的几个取值content-box，border-box，同样有padding-box以及margin-box。那么，width默认情况下是作用在了内容盒子也就是content box上面，此时对应的box-sizing的取值就是content-box，也是box-sizing的默认值，举例来说 div{ width: 100px; height: 100px; background-color: #FF0000; } 这个红色的方块我就不截图了，主要来看此时的盒子情况此时中间蓝色的区域也就是内容区域的宽高就是我们设置的width和height的值，默认情况下div的padding，margin，border都是0，也就是此时这个div总的宽度就是width设置的100px。此时盒子的大小就是内容区域的大小。现在试着给盒子加上padding和border div{ width: 100px; height: 100px; background-color: #FF0000; padding: 20px; border: 20px solid; } 可以看到现在这个div的宽高就是180px，也就是 divWidth = border-left + padding-left + padding-right + border-right（记得此时的box-sizing还是默认值content-box）,可以看到的是，padding和border的加入增大了元素的宽度和高度。然后再添加一下margin可以看出，增加外边距没有改变这个div的大小，只是顶开了下面的元素。综上，当box-sizing默认值是content-box的时候，给一个块级元素设置宽高，此时的width和height只是作用在内容区域，元素的padding和border还是会增加元素的大小，这么说吧，可以总结出这么一个公式：元素的实际宽度 realWidth = padding + border + width(这里的width是我们设置的width属性的值)。 换一个box-sizing值再来看上面一直是在box-sizing默认值是content-box的时候得出的结论，前文说道box-sizing有四种取值，那么我们来看看在其他三种取值下会有一种什么样子的不同 margin-box和padding-box把这两个属性放在一起写是因为目前的浏览器都不支持这两个属性（甚至我的webstorm都不认识margin-box，他只是存在于理论中的），设置了这两个属性实际的效果和默认值的效果是一样的，当然理论上不一样，但是我们总要基于实践嘛，浏览器不支持你分析的再好还不是没啥作用，所以就不详细讨论这两个值了。 border-boxborder-box需要拿来仔细说一说，前文写到在默认情况下width属性是直接作用在内容区域的，再给元素添加内边距和边框都会增加元素的大小。那么当我们更改box-sizing属性的值为border-box，其实改变的就是width的作用的盒子，也就是说，应用了border-box以后，width是直接作用在了边框盒子上面，我们来看例子 div{ width: 100px; height: 100px; background-color: #FF0000; padding: 20px; border: 20px solid; } .content-box{ box-sizing: content-box; margin-bottom: 20px; } .border-box{ box-sizing: border-box; } 两个盒子，width值都设置了100px，不同的只是box-sizing的作用不同，那么显示的效果如下：我们设置了border-box的那个盒子的宽度就是100px，而那个默认的盒子是180px也就是内边距 + 边框 + 内容区域。看到这里应该能猜出来了，此时的元素的实际宽度就是我们设置的width宽度，也就是说此时：realWidth === width = borderWidth + paddingWidth + contentWidth，用一张图更好的说明一下：这张图比较清晰的显示了当box-sizing属性的值为border-box的时候，宽度是作用在border上面的也就是border + padding + content，而当box-sizing属性的值为content-box的时候，width是作用在content两端的，所以最终显示的两个元素的大小不一样 其他的盒模型标记盒子啥是标记盒子(marker box)？我们知道HTML的ul，li，ol默认都会在前面有一个圆点或者是标号，那这个圆点或者标号是哪里来的？这是因为ul，li，ol他们的display声明是list-item，这个list-item的设置会给元素提供一个额外的盒子去存放那个点或者标号，这个盒子就是标记盒子。 display:inline-block我们知道，单纯的块级元素是一行一个块级元素，而且可以设置宽高，内联元素是排列在一行，不可以设置宽高，但是给一个元素设置了display:inline-block后，它既能在一行排列，也能设置宽高，为什么？？这就涉及到了外在盒子和内在盒子，外在盒子负责元素是可以在一行显示还是换行显示，内在盒子负责宽高，内容显示什么的，又叫容器盒子，所以，设置了display:inline-block的元素就可以既在一行显示，又设置宽高了。 内联元素的盒模型首先明确一点，内联元素指的是外在盒子是inline的盒子，它和display:inline的盒子是不一样的，而是范围更大。明确了这一点后，我们再来看内联的盒模型，从一段代码来进入对这些盒子的认识 &lt;p&gt;这是一行普通的文字，这里有一个 &lt;em&gt;em&lt;/em&gt;标签&lt;/p&gt; 这一行代码里面有很多盒子，一一列举如下： 内容区域(content area)。内容区域是指一种围绕文字看不见的盒子，方便理解就可以认为是我们鼠标选中文字的时候，那个蓝色的背景所选中的地方 实际上，内容区域并没有明确的定义，所以将其理解为中文字符占据1em的高度的区域(em-box)也是可以的，内容区域的大小与font-size大小相关。 内联盒子(inline box)。内联盒子，其实就是元素的外在盒子，用来决定元素是内联还是块级元素，该盒子又可以分为“内联盒子”和“匿名内联盒子”，比如说这段代码：&lt;p&gt; 这是一行普通的文字，这里有一个 &lt;em&gt;em&lt;/em&gt; 标签 &lt;/p&gt; 在这个里面，文字em是由标签em所包裹，则这盒子属于“内联盒子”，总的来说，如果一段文字被内联标签（比如em，i，span等）所包围，他就是一个内联盒子，如果一行文字没有被包裹，则属于匿名内联盒子，也就是上面代码中的 “这是一行普通的文字，这里有一个 ” 与 “标签” 这两段文字。有一点需要注意一下：并不是所有的匿名盒子都是匿名内联盒子，也会有匿名块级盒子，比如说下面这个例子：&lt;p&gt; 这是一行普通的文字，这里有一个 &lt;div&gt;em&lt;/div&gt; 标签 &lt;/p&gt; 此时这两段光秃秃的文字就是被内联块级盒子所包裹了，具体区分的话就需要看前后的标签是内联还是块级，当然，显示的效果也是不一样的，第一段代码中的三段文字是在一行显示，这就是匿名内联盒子的特性，第二段代码是三段文字三行，这就是匿名块级盒子所包裹时显示的效果。 行框盒子(line box)。每一行就是一个行框盒子，每一个行框盒子是由一个个的内联盒子组成，如图下面实现所包围的部分 包含块(containing block)。这个盒子由一个个的行框盒子组成，包含块是这个元素最近的祖先块元素（如果这个元素的position属性是static或者relative） 结语以上就是暂时总结的CSS世界各种盒子，除了这些盒子以外，还有很多种盒子，等我看完，再回来补充~]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解line-height]]></title>
    <url>%2F2019%2F04%2F14%2F%E7%90%86%E8%A7%A3line-height%2F</url>
    <content type="text"><![CDATA[前言我得记下来，要不我就忘了。。。本篇文章的内容参考自张鑫旭大神的《CSS世界》 目录1.可替换元素和非可替换元素2.非替换纯内联元素与line-height3.行距和半行距4.替换元素和块级元素与line-height5.line-height与垂直居中6.line-height的各类属性值7.总结 正文 替换元素和非替换元素这个概念，取自MDN 可替换元素（replaced element）的展现效果不是由 CSS 来控制的。这些元素是一种外部对象，它们外观的渲染，是独立于 CSS 的。简单来说，它们的内容不受当前文档的样式的影响。CSS 可以影响可替换元素的位置，但不会影响到可替换元素自身的内容。某些可替换元素，例如 元素，可能具有自己的样式表，但它们不会继承父文档的样式。 MDN上说的有一点抽象，用人话来说，可替换元素就是可以通过更改标签的属性值来更改呈现的内容的元素就叫做可替换元素，比如说img标签，当把img标签的src属性换掉以后，显示的图片也会变，这就是替换元素。常见的替换元素有img，object，video，iframe，textarea，input等所有的替换元素都是内联水平元素，也就是替换元素和替换元素，替换元素和文字都是可以在一行内显示的。替换元素的特性之一就是尺寸由内部元素决定，且无论其 display 属性值是 inline 还是 block。这个特性很有意思，对于非替换元素，如果其 display 属性值为 block，则会具有流动性，宽度由外部尺寸决定，但是替换元素的宽度却不受 display 水平影响。 非替换纯内联元素与line-height对于非替换元素的纯内联元素(比如说 span)，它的可视高度完全由line-height决定，padding，border等对可视高度是没有影响的。对于这种文本这样的纯内联元素，line-height就是高度计算的基石，也就是指定了行框盒子的基础高度 行距和半行距对于块级元素和替换元素的line-height的讨论，先要从行距和半行距开始说起。我们已经知道基线这个概念是字母x的下边沿所对的那条线，那么两条基线之间的距离就是行距。有这么一个计算公式：行距 = 行高 - em-box，半行距 = 行距 / 2这里的em-box是一个盒子，看它的名字就可以知道，这个盒子是和单位em相关的，而我们又知道1em就是当前字体font-size的大小，也就是说，影响em-box大小的因素，只有一个font-size，所以有时为了理解的方便也可以吧上面的公式写为：行距 = 行高(line-height) - font-size但是这个em-box是一个虚无缥缈的东西，我们看不见它，有的时候就会把它和其他的区域相混淆，我们尊崇眼见为实，我们相信眼睛看到的东西，但是很多时候，我们也会被肉眼所看到的东西所迷惑。很多人容易把文字图形区域看作是em-box的范围，但实际上这个是不对的，比如说，英文字母 p 或者 g ，它们的“尾巴”是在em-box之外的，对于一些汉字，很多字体图形高度实际上是小于em-box的高度的。那我们怎么去找到这个em-box呢？因为只有找到它才能准确的去计算行距和半行距，这里需要利用一下内容区域，在之前一篇文章中，提到内容区域可以看作为鼠标选中文字时显示的蓝色背景区域，但是内容区域是受到font-size和font-family双重影响的，em-box只是受font-size影响，那么只有在字体是宋体的时候，内容区域和em-box才是等同的，所以我们根据这个就可以看出来半行距了 .test{ font-family: 宋体; font-size: 24px; line-height: 36px; background-color: yellow; padding-left: 12px; } span{ background-color: #cccccc; } &lt;div class=&quot;test&quot;&gt; &lt;span&gt;sphinx&lt;/span&gt; &lt;/div&gt; 这样的话，中间灰色区域就是内容区域同时也是em-box的区域，上下两个被红框框起来的地方就是半行距。那么，理解了行距和半行距之后，我们来讨论一下，如何通过line-height来实现文字的排版？很多前端开发者都遇到过这样子的情况，两行文字之间具体太小了，希望调大一下，这是很显然我们会调大line-height的值来让两行文字的间距变大，但是具体作用细节呢？比如说line-height的值为2，那么此时半行距的大小就是一半文字的大小，这样两行文字的两个半行距加起来（上面的文字的下半行距和下面文字的上半行距）就是一个文字的大小，这样两行文字之间相距的就是一个文字尺寸的大小，如果line-height是1，那么半行距就是0,，也就是两行文字会紧挨在一起 &lt;div style=&quot;background-color: #FFA500&quot;&gt; &lt;div&gt;&lt;span style=&quot;line-height: 2;outline: 1px solid #000000&quot;&gt;一行文字&lt;/span&gt;&lt;/div&gt; &lt;div&gt;&lt;span style=&quot;line-height: 2;outline: 1px solid #000000&quot;&gt;一行文字&lt;/span&gt;&lt;/div&gt; &lt;/div&gt; &lt;br&gt;&lt;br&gt; &lt;div style=&quot;background-color: #FFA500&quot;&gt; &lt;div&gt;&lt;span style=&quot;line-height: 1;outline: 1px solid #000000&quot;&gt;一行文字&lt;/span&gt;&lt;/div&gt; &lt;div&gt;&lt;span style=&quot;line-height: 1;outline: 1px solid #000000&quot;&gt;一行文字&lt;/span&gt;&lt;/div&gt; &lt;/div&gt; 如图 替换元素和块级元素与line-height前面一小节说道了非替换纯内联元素与line-height之间的关系，这节总结一下替换元素和块级元素与line-height之间的关系 line-height与替换元素常见的替换元素比如说img，input，textarea等，我们又知道替换元素的特性之一就是尺寸由内部元素决定，且无论其 display 属性值是 inline 还是 block，也就是说，替换元素设置了block，并不会具有流动性去宽度填满父容器，而是内部元素有多大，显示出来就是多大，那么这里line-height是否可以影响img（替换元素）的高度吗？其实是不可以的 .box{ background-color: #FFA500; } &lt;div class=&quot;box&quot;&gt; &lt;img src=&quot;...&quot; alt=&quot;&quot;&gt; &lt;/div&gt; 根据上面这段代码，当给img增加line-height的时候，其父元素的黄色背景没有任何变化当给父元素增加line-height的时候，可以看见的是父元素的黄色背景区域有变化，变化的原因如下：图片是一个内联元素，会构成一个行框盒子，在HTML5文档模式下面，每一个行框盒子前面都会有一个宽度为0的空白节点，实际上父元素背景区域的变化是因为line-height影响的这个空白节点的高度，而不是影响了img的高度，所以这也侧面说明了line-height对替换元素的高度是没有影响的，再强调一下，替换元素的尺寸是由其内部元素所决定的（默认情况下，如果不去设置宽高的话，这个默认尺寸为固有尺寸，也就是替换元素的“初始尺寸”），所以line-height不会影响其高度。既然line-height不会影响替换元素的高度，那么当非替换内联元素与内联替换元素同时存在的时候，高度的表现又是怎么样的呢？因为非替换元素和内联替换元素都属于内联元素，在一行的时候会构成一个行框盒子，此时的line-height是决定这个行框盒子的最小高度，因为替换元素的高度不受line-height所影响 line-height与块级元素对于块级元素，line-height是不会对其产生影响的，平常通过改变一个块级元素的line-height，块级元素高度的变化实际上是通过改变块级元素内部的内联元素的高度而实现的，来看下面这个例子： &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; .box{ line-height: 250px; background-color: #FFA500; } 这个里面给一个空的块级元素设置了line-height为250px，同时加了一个背景色，但是浏览器上显示的却是一片空白，这说明line-height对块级元素的高度是没有影响的。 &lt;div class=&quot;box&quot;&gt; &lt;span&gt;啦啦啦啦啦&lt;/span&gt; &lt;/div&gt; .box{ background-color: #FFA500; } .box span{ line-height: 2; } 在块级元素内部嵌套一个内联元素，并给它设置line-height，浏览器的效果如下：此时，内部的内联元素添加了line-height后，父容器的背景部分扩大了，结合上面的例子可以知道，此时是内联元素的高度被增加了，所以才会导致父元素也被撑开了。 line-height与垂直居中单行文本垂直居中一段文字没有在一个容器中垂直居中显示，怎么办？相信很多人都知道：把line-height和height设置成同样的大小就行，那么就要问，为什么这么做能实现垂直居中？其实，上面的说法是有一些不严谨的，不是需要把line-height和height设置为一样大小，而是只需要设置line-height就可以了，来看下面的例子 &lt;div class=&quot;content&quot;&gt; 单行文字垂直居中(height: 36px; line-height: 36px;) &lt;/div&gt; &lt;div class=&quot;text&quot;&gt; 单行文字垂直居中(line-height: 36px;) &lt;/div&gt; .content{ outline: 1px solid #000000; height: 36px; line-height: 36px; } .text{ outline: 1px solid #000000; line-height: 36px; } 可以看到，下面的一行文字，没有设置块级元素的高度，单独的设置了行高，文字仍然会垂直居中。这个是因为，前面说到了半行距，因为行距在一段文字上下等分形成半行距，所以就会形成垂直的效果。还要注意一个细节，因为font-family的不同，不同的字体设置line-height的时候不会完美的达到垂直居中效果，一般来说宋体是会规规整整的垂直居中的，其他的一些字体比如说微软雅黑，会稍微向下偏移一些，但是因为一般情况下使用的字号比较小，所以偏移量不是特别大，肉眼看上去几乎就是垂直了，所以line-height实现单行文本垂直居中往往是“近似垂直居中”。 多行文本垂直居中多行文本的垂直居中需要借用到另一个属性vertical-align的帮助： &lt;div class=&quot;multiple&quot;&gt; &lt;div class=&quot;item&quot;&gt;文字文字文字文字文字文字文字文字文字文字文字文字文字&lt;/div&gt; &lt;/div&gt; .multiple{ width: 200px; background-color: #FFA500; line-height: 120px; } .item{ display: inline-block; line-height: 20px; margin: 0 20px; vertical-align: middle; } 现在是多行文本垂直局中了，这段代码的含义如下：首先给内部的div设置display属性值为inline-block的目的是让这个div变成一个外部盒子是内联盒子的元素，这样，因为外部盒子是内联盒子，于是就会产生一个行框盒子和宽度为0的空白节点（每一个行款盒子都会附带一个空白节点），这样父元素的120px的行高就能作用在这个空白节点上从而利用这个空白节点撑开父元素。其次，因为内联元素默认是基线对齐的，所以此时设置vertical-align的值为middle就可以实现多行文本的垂直了。注意，其实这里的垂直也是“近似垂直”，这个“近似”是由vertical-align引起的，后面我会接着记一篇关于vertical-align的笔记来详细的说一下原因。 line-height的各类属性值line-height有几种常用的取值 normal 默认值，normal是一个变量，不同的字体(font-family)对应不同的normal值，只要字体相同，那么normal解析出来的line-height的值在不同浏览器下基本都是一样的。 数值 数字，比如line-height: 1.5，最终计算值就是当前元素的font-size与line-height的相乘，比如说font-size是14px，那么line-height就是 14 * 1.5 = 21px 百分比 百分比值，比如line-height: 150%，最终计算的值也是当前元素的字体大小与当前line-height相乘，也就是 14 * 150% = 21px 长度值 带有单位的值，比如说line-height是21px或者1.5em，em我们都知道是一个与字体大小相关的单位，比如说字体大小是14px，那么line-height就是 14 * 1.5 = 21px 那么都是字体的1.5倍，上面三个有什么区别呢？来看一段代码 &lt;div class=&quot;number&quot;&gt; &lt;h1&gt;标题&lt;/h1&gt; &lt;p&gt;文字&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;percent&quot;&gt; &lt;h1&gt;标题&lt;/h1&gt; &lt;p&gt;文字&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;length&quot;&gt; &lt;h1&gt;标题&lt;/h1&gt; &lt;p&gt;文字&lt;/p&gt; &lt;/div&gt; .number{ line-height: 1.5; } .percent{ line-height: 150%; } .length{ line-height: 1.5em; } 可以看出，设定了line-height为数值的标题和文字排版很舒服，而设置了百分比和em的文字都挤在了一起，这是因为如果使用数字作为取值，那么子元素的line-height继承的值就是这个数字（例子中是1.5），另外两种继承的是父元素的line-height计算后的结果（例子中就是1.5 * 14px = 21px），而因为h1的字体大小是默认的两倍在这里就是28px，而继承的行高是21px，所以半行距即使-3.5px，所以文字会重叠在一起。个人比较喜欢使用数值作为line-height的取值，这里只是稍作了解。 总结说了这么多，最后再看一个例子，以验证是否理解了line-height &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;box1&quot;&gt; &lt;span&gt;文字文字文字文&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;box2&quot;&gt; &lt;span&gt;文字文字文字文&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; .container{ display: flex; } .container &gt; div{ margin: 0 12px; background-color: #FFA500; width: 200px; } .box1{ line-height: 96px; } .box1 &gt; span{ line-height: 20px; } .box2{ line-height: 20px; } .box2 &gt; span{ line-height: 96px; } 这两个div，.box1和.box2的高度分别是多少？想一下再看下面的答案 答案：都是96px眼见为实为什么？我们在最后分析一遍，先看.box1这个盒子，它是父容器设置了96px的line-height，子元素内联元素span设置了20px的line-height，之前的一篇文章之前的一篇文章有说到，内联元素会有一个行框盒子，而每一个行框盒子都会在其前面有一个空白节点，这个节点的宽度为0，就像是一个 0 宽度的字符，此时父元素的line-height正是作用在了这个空白节点上，使得父元素的高度被撑开，子元素虽然说设置了line-height为20px，但是远小于96px，所以不会对父元素的高度产生影响。同理，第二个.box2这个盒子，我们知道给块级元素设置line-height是没有用的，高度的变化全是靠着line-height影响其内联的子元素的行高，从而影响父元素的高度，那么这里面，父元素只是设置了20px的行高，如果子元素不设置96px的话，那无疑就是20px的高度了，但是子元素，这个非替换内联元素设置了96px的行高，就会把父元素的高度撑开为96px，这也就是为什么第二个盒子的高度也是96px的原因。总结一下，就是父元素的高度最终都是由line-height大的那个值决定的。 结语加油！]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习心得]]></title>
    <url>%2F2019%2F02%2F21%2FJavaScript%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[前言超长文预警！！！！！这段时间一直在看JavaScript的闭包，原型，原型链这些问题，结果越看越多，一个接着一个，一大堆东西进到了脑子里，为了不让自己忘记，所以写这篇文章来整理一下，包括JavaScript的原型（prototype），原型链（Prototype Chain），词法作用域（静态作用域（lexical context）），执行环境(执行上下文(execution context))，变量对象(variable object)，活动对象（Active Object），作用域链（scope chain），闭包（Closure），this这些。这些东西看似独立，实际上都是一环扣一环，理解了一个才能辅助理解下一个，都看得差不多了，闭包也不再是什么问题了。 目录1.JavaScript的原型2.JavaScript的原型链3.JavaScript的词法作用域(静态作用域)4.JavaScript的执行上下文栈5.JavaScript的变量对象与活动对象6.JavaScript的作用域链7.JavaScript的this指针8.JavaScript的闭包 正文 JavaScript的原型在JavaScript中，每一个函数都有一个属性叫做prototype属性，JavaScript高级程序设计是这么样去解释该属性的。 这个属性是一个指针，指向一个对象，这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。如果按照字面意思来理解，那么 prototype就是通过调用构造函数而创建的那个对象实例的原型对象。 这句话在没有真正理解原型和prototype之前是不好理解的，不过先不着急，先把这句话放着，看完这一小节在回来看这句话就会理解了。 至于原型的作用，MDN中给出一句话 对象以其原型为模板、从原型继承方法和属性。 这句话仔细读的话是能看出很多东西的，想要理解这句话的含义，我们就要深入去理解prototype，首先从一段代码开始： // 构造函数 function Person() { } // prototype 是函数才会有的属性 Person.prototype.name = &quot;Tiki-Taka&quot;; // 实例化 let person1 = new Person(); let person2 = new Person(); console.log(person1.name); // Tiki-Taka console.log(person2.name); // Tiki-Taka 在这段代码里面，Person是一个简单的构造函数，此时构造函数里面没有任何属性和方法，现在通过prototype给构造函数添加一个name属性，然后创建两个实例，person1和person2，通过实例来对name属性进行调用，发现打印出来的都是通过prototype定义的Tiki-Taka，这说明我们通过构造函数的prototype来定义的属性是可以继承到实例上并且被实例所引用的，同样再来看看通过prototype定义方法 // 构造函数 function Person() { } // prototype 是函数才会有的属性 Person.prototype.showName = function () { console.log(this.name); } // 实例化 let person1 = new Person(); let person2 = new Person(); person1.showName(); // Tiki-Taka person2.showName(); // Tiki-Taka 同样，实例中也会得到在原型中定义的方法通过这两个例子就可以更好的理解上面的那句话了：对象以其原型为模板、从原型继承方法和属性。，也就是说，当我们通过原型定义了方法和属性的时候，实例化的对象就可以继承到这些属性和方法。我们现在已经知道原型和实例之间有一定的关系，那原型，实例，构造函数三者之间有什么相互的关系呢？从上例的代码来说，构造函数即为Person()，原型也就是Person.prototype，它是一个对象，这二者之间可以说是通过prototype这个属性联系起来的，他们之间的关系可以用下图来表示从上面的例子中我们知道实例可以从原型Object.prototype中继承属性和方法，那么从实例到原型之间又有什么关系呢？我们需要了解另一个属性 proto ，通过该属性可以将原型和实例联系起来还是先看一下高程的说法(我可真是喜欢引用高程的话啊)，其实已经说得很明白了 。当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象。ECMA-262 第 5 版中管这个指针叫[[Prototype]]。虽然在脚本中没有标准的方式访问[[Prototype]]，但Firefox、Safari 和Chrome在每个对象上都支持一个属性proto；而在其他实现中，这个属性对脚本则是完全不可见的。不过，要明确的真正重要的一点就是，这个连接存在于实例与构造函数的原型对象之间，而不是存在于实例与构造函数之间 在JavaScript中提供了一个方法isPrototypeOf，可以通过该方法来确定对象之间是否存在这种关系。从本质上讲，如果proto指向调用 isPrototypeOf()方法的对象（Person.prototype），那么这个方法就返回 true， console.log(Person.prototype.isPrototypeOf(person1)); // true 说了半天，总结一下，就是实例上有一个属性proto指向了该实例的原型(对象)用一张图来表示关系：用代码也可以啃清晰地看出这种关系 // 构造函数 function Person() { } // 实例化 let person1 = new Person(); console.log(person1.__proto__ === Person.prototype); // true // 打印出来为 true ，说明了实例(对象)可以通过 __proto__ 指向原型 当我们在浏览器里面打印原型的时候，会看到其中还有一个constructor属性，通过打印Person.prototype.constructor，可以发现得到的结果是Person () {}，这说明了原型中的constructor属性是指向构造函数的，代码也帮我们证明了这一点 console.log(Person.prototype.constructo === Person); // true 这样我们就可以进一步完善三者的关系图这边要注意一点，实例本身是不具有constructor属性的，当你在控制台中输入person.constructor的时候到此为止，三者之间的关系就还算清楚了，但是这还是不够，我们接着往下看在前两个例子中，我们看到实例从原型那里继承过来的属性和方法是一模一样的，就像是复制了一遍，但你仔细看一看代码，我在创建了实例以后是直接去使用了person1.name的，但是你去打印一下person1，发现里面并没有name属性，那怎么还会能得到结果呢？person1的打印结果 当解释器读到一个对象的某一个属性/方法的时候，它会去执行一次搜索，去找这个属性/方法。搜索首先是从实例开始的，如果在实例中找到了目标（属性/方法），就返回该属性的值，同时停止搜索。如果没找到，则会去该实例对应的原型里面去找，如果在原型对象中找到了这个属性，则返回该属性的值。如果还没找到，就再去上一级找（这个上一级是啥我们一会再说），再找不到，就返回undefined，如果找到了就返回这个属性的值。所以我们才会在多个实例里面都得到同样的结果，因为他们都是搜索到同一个原型后返回的值。当然我们在不同的实例之间想让他们的同一个属性之间拥有不同的值，那么我们就需要通过实例来更改特定属性的值，比如说： var person1 = new Person(); var person2 = new Person(); person1.name = &quot;Greg&quot;; console.log(person1.name); // Greg console.log(person2.name); // Tiki-Taka 这是不是说person1更改了原型中的name属性的值呢？其实不是的，因为我们打印的person2的name的值还是Tiki-Taka，这就说明，通过实例修改对应属性的值，起到的作用只是覆盖原型中同名属性的值，而不是修改原型中同名属性的值，因为解释器在搜索的时候已经在第一次搜索就在实例中拿到了结果，所以搜索停止，不会再向上找了，同时，JavaScript里面提供了hasOwnProperty()方法（从Object继承来的），该方法可以检测一个属性是存在于实例中，还是存在于原型中，只有在给定属性存在于对象实例中时，才会返回true。还是通过看例子比较清楚： function Person () {} Person.prototype.name = &#39;Tiki-Taka&#39; var person1 = new Person() console.log(person1.hasOwnProperty(&#39;name&#39;)); // false （说明来自原型(对象)） person1.name = &#39;Greg&#39; console.log(person1.hasOwnProperty(&#39;name&#39;)); // true （说明来自实例） 到此为止，原型的东西就说的差不多了，最开头引用的高程的话应该也明白了，这里再总结一下：每一个函数都有一个prototype属性，这个属性是一个指针，指向一个对象，这个对象我们一般叫做原型（对象），因为它可以让所有通过调用对应的构造函数而创建的实例去共享它所含有的属性和方法，在实例中有一个proto属性（JavaScript中万物皆对象，所有都含有这个proto属性），它是指向原型（对象）的，原型（对象）本身还含有一个constructor属性，可以通过该属性访问到对应的构造函数。但是在实例中是不存在constructor属性的，在控制台打印person，可以看到的是里面没有constructor属性，只有一个proto属性，但是打印person.constructor会得到Person () {}，这是因为当读取不到person.constructor时，会从它的原型里面去找constructor属性，而原型的constructor属性正好是指向构造函数的，所以才会有Person () {}的结果。 JavaScript的原型链在明白了JavaScript原型之后，原型链的理解就变得简单一些了，先看一张图在OO语言中，继承是一个令人津津乐道的概念，OO语言实现继承通过两种方式：接口继承和实现继承（这里不讨论），但是在ECMAScript标准中，不支持上述的继承方式，所以在JavaScript中实现继承靠的就是原型链。关于原型链我看了很多资料，网上的说的是proto属性的连线，这当然是没有问题的，但是看JavaScript高级程序设计中说 每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。那么，假如我们让原型对象等于另一个类型的实例，结果会怎么样呢？显然，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条。这就是所谓原型链的基本概念 注意上面的引用中的重点就是：原型对象等于另一个类型的实例，这一开始读起来会有一种感觉和网上说的不一样（反正我是有这种感觉），但是仔细思考一下，发现其实是一样的叙述。先按照高程中的说法来捋一下，按照高程的说法，原型作为另一个构造函数的实例，这样一层一层下去就构成了原型链，我们通过代码可以看得更清楚： /* 第一代闪电侠 */ function JayGarric() { this.disc = &#39;first generation of Flash&#39;; this.experience = 100; this.speed = &#39;one mile in a second&#39;; this.JayAge = 60 } JayGarric.prototype.getJayAge = function () { return this.JayAge } console.log(JayGarric.prototype); function BarryAllen() { this.disc = &#39;second generation of Flash&#39;; this.experience = 80; this.speed = &#39;one point five mile in a second&#39;; this.BarryAge = 25 } BarryAllen.prototype.getBarryAge = function () { return this.BarryAge } /* 二代闪电侠继承一代闪电侠 */ /* 实现原型链的代码： 将 BarryAllen 的原型作为 JayGarric 的 实例 */ BarryAllen.prototype = new JayGarric(); BarryAllen.prototype.increaseExperience = function () { return this.experience * 2; } console.log(BarryAllen.prototype); var red_streak = new BarryAllen(); console.log(red_streak); console.log(red_streak.getJayAge()); // 60 console.log(red_streak.increaseExperience()); // 160 在DC宇宙世界中，第一代闪电侠是 Jay Garric ，第二代闪电侠是更为人所熟知的 Barry Allen ，为了看起来不那么枯燥，我让二代闪电侠继承一代闪电侠，从技术层面来讲就是 BarryAllen 继承了 JayGarric ，这个继承时通过创建 JayGarric 的实例，并将它赋值给 BarryAllen 的原型(BarryAllen.prototype)。下图是二者的实例以及构造函数和原型之间的关系从图中我们可以看出，在 BarryAllen 继承了 JayGarric 之后，其原型中已经有了所有在 JayGarric 中定义的属性和方法（注意不是在 JayGarric 的原型中定义的，而是在构造函数中定义的属性和方法都继承到了 BarryAllen.prototype 中）,且因为将 BarryAllen 的原型作为了 JayGarric 的实例，所以在 BarryAllen 的原型中会有一个proto指针指向 JayGarric 的原型也就是JayGarric.prototype，而通过 BarryAllen 创建的实例red_streak中同样会有一个proto指针指向 BarryAllen.prototype ，这样通过proto指针连起来的这一条链就是原型链，在本例的原型链中，red_streak是链头，而链尾不是JayGarric.prototype，上层还有一个Object.prototype(因为JayGarric本身也是从Object中继承过来的)，最终原型链往上延伸直到null，更新一张原型链图如下：总结一下，原型链其实就是通过proto指针将具有继承关系的原型连接起来，最终到null的一个链条，原型链的作用，本质上是扩展了前面提到过的搜索机制，举个例子：当我去调用red_streak.getJayAge()的时候，会经历以下步骤： 1.在实例中搜索 2.搜索BarryAllen.prototype 3. 搜索JayGarric.prototype 最后一步，在JayGarric.prototype找到该方法，并返回对应的值。 JavaScript的词法作用域(静态作用域)作用域共有两种主要的工作模型，第一种是比较普遍的，被大多数编程语言所采用的的静态作用域（词法作用域（lexical Scope））另一种叫做动态作用域（Dynamic Scope），在去深入词法作用域之前，先深入一下作用域的概念 作用域 引擎的另一位好朋友，负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。 在你所不知道的JavaScript中的这段话可以说是通过一句话交代明白了什么是作用域和作用域的作用了，即作用域首先是辅助引擎的，其次，他规定了如何去根据名称在与当前执行代码相关的作用域中去查找变量（标识符），说白了就是如何查找变量的一套规则，看下面这段代码 var global = &#39;global&#39;; console.log(global); // global 这段代码实在是简单的不能再简单了，打印出global肯定没问题，但我想通过这两行代码说明一下作用域的查找到底是怎么一个意思。我们看，当遇到了var global，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为 global，然后，该赋值的时候，引擎会在当前作用域中查找名为global的变量，找到了，赋值2，打印，结束了。 再看一段代码： var global = &#39;global&#39;; function foo() { console.log(global); // global } foo(); 我们跳过编译器那段，直接从引擎开始，当调用foo()函数的时候，要去打印global这个变量，然后引擎就问作用域说你给我在foo()这个作用域（函数作用域）中找一下这个global这个变量，作用域说没有，引擎就到外面（全局作用域）去找，这回找到了，所以能打印出来global。 说了这些，意在帮助理解作用域这个查找的概念，这个理解之后，词法作用域也就不是那么难理解了 词法作用域 上面花了很多篇幅去解释查找的意思，其实词法作用域和动态作用域的区别就在于查找的路径不一样，词法作用域是当你写代码的时候，这块代码的作用域就确定了，动态作用域是你调用代码的时候才确定的，因为这个的区别，导致查找的起点，路径也有做不同，同样是看一个例子var global = &#39;global&#39;; function global_context_01() { console.log(global); } function global_context_02() { var global = &#39;fake global&#39;; global_context_01(); } global_context_02(); // global 这段代码从词法作用域的角度分析：调用global_context_02()，进入该函数，调用global_context_01()，需要打印global，那么引擎就去找该变量，在global_context_01()内部没有找到，此时因为是词法作用域，所以会从global_context_01()被书写的位置向上开始找，这样就进入到了全局作用域里面找到了对应的变量并打印出来了它的值。如果是动态作用域，当在global_context_01()内部没有找到时，会从调用该函数的地方去找，也就是到了global_context_02()这个函数作用域里面，找到了global的值是fake global，会打印fake global。 JavaScript的执行上下文栈执行环境(execution context)（执行上下文）是JavaScript中最为重要的一个概念，通过深入理解执行环境，就会理解为什么一些函数和变量在他们声明之前就能使用以及他们的值到底是怎么被定义的。 什么是执行环境？当执行一段代码的时候，JavaScript解释器会去做一个工作，即创建一个执行环境，每一个执行环境中包含了三个重要的属性：变量对象（Variable object，VO），作用域链（Scope Chain）和this(下面几节会有)。在一段程序中，我们可能写了很多个函数，因此也会创建很多个执行环境，如此多的执行环境的管理需要通过执行上下文栈（Execution Context Stack）。 执行上下文栈 众所周知，JavaScript是单线程语言，这就意味着每次JavaScript解释器只能处理一件事情，当它在处理当前这件事情的时候，其他的事情就会被放在执行上下文栈中等候。具体的出栈入栈顺序如下：当浏览器加载script的时候，首先就会遇到全局代码，于是创建一个全局执行环境压入栈中，这个全局执行环境也会始终在栈的最底部，只有当整个程序结束的时候才会弹出。在你的全局代码中你调用了一个函数，也就是执行该函数，此时创建一个新的执行环境并将其压入栈中，如果在这个函数中调用了另一个函数，同样会创建一个新的执行环境并将其放到栈中…浏览器会始终去执行栈顶的执行环境，执行完当前环境后将其弹出栈，再去执行下一个执行环境，直到回到全局执行环境，用一张图表示的更为清晰 到目前为止，我们知道了执行代码的时候会创建执行上下文并通过执行上下文栈来管理，在JavaScript解释器中，每次调用一个执行上下文（执行环境）时会分为两个步骤进行 1.进入执行环境（当调用函数的时候，但在其执行其中任何代码之前的时候进行这个步骤） 创建作用域链 创建变量，函数和arguments属性 决定 的指向 2.执行 执行代码（为变量和函数分配值、引用并执行代码），执行过程中涉及到变量对象，活动对象，作用域链的变化，这就需要接着往下看了 JavaScript的变量对象与活动对象在一个程序中，我们定义函数和变量，加入逻辑，然后成功构建出一个完整的程序，那解释器是怎么找到我们定义的函数和变量呢，当我们去引用对象的时候又会发生什么呢？其实，变量/函数是和执行环境密切相关的，而且执行环境应该知道那些变量和函数都储存在哪里和怎么去调用它们，就是通过变量对象将二者联系起来的。变量对象是一个与执行环境相关的特殊的对象，其中储存了变量声明，函数声明，和函数形参，是执行环境中的一个重要的属性，但是我们编写的代码是无法访问到变量对象的，它纯粹是一个实现机制。因为有两种执行上下文（全局执行上下文和函数执行上下文），所以变量对象也有全局执行上下文的变量对象和函数执行上下文的变量对象。 全局执行上下文中的变量对象首先了解一下什么是全局对象：全局对象是在进入任何执行环境前就被创建的一个对象，全局对象中的属性可以在程序的任何位置去访问，只有当程序结束的时候，全局对象才会被销毁。全局对象不是任何对象的属性，所以它没有名称。当程序开始运行的时候，全局对象会由一些属性比如说Math，String，Date，parseInt等等，同时也会被能作为全局对象自身引用的其他对象进行初始化，比如说在客户端JavaScript中，就是window对象，而且window对象作为全局对象的引用也是指向全局对象的。说白了就是window对象就像是全局对象的一个分身，同时这个“分身”也存在于全局对象自身中，就像下面这个样子： globalObject = { Math: &lt;...&gt;, String: &lt;...&gt;, ... ... window: globalObject } 在全局环境中定义一些函数，或者变量（只有var定义的变量，let和const定义的全局变量不会作为全局对象的属性出现），都会默认作为全局对象的属性或者方法，可以通过全局对象来访问到，比如说下面这个例子初始化的全局对象会自带一些默认的属性和方法（上面举的例子），同时因为运行在浏览器端的JavaScript程序，所以window全局对象提供了与当前窗口、页面有关的诸多属性与方法。当定义了一个变量a的时候，打开window对象就会发现定义的a已经在里面了同样，也可以通过window.a去访问该变量，但是在访问全局定义的属性或者方法的时候一般会省略前缀也就是window，直接使用a即可调用该变量，这是因为前面也说过全局对象不能直接通过名称来访问，但是可以通过全局的this访问到它，也可以通过对自身的递归引用，比如说通过window，所以，下面这些都是等价的： String(10); // &lt;==&gt; global.String(10); window.a = 10; // === global.window.a = 10 === global.a = 10 this.b = 5; // === global.b = 5 到这里说了好多关于全局对象的就是想说明：在全局上下文中，变量对象就是全局对象，VO(global context) === globalObject，说明这个的原因在于，之前说到我们编写的代码是没有能力访问到变量对象的，那在全局环境中，因为变量对象就是全局对象，所以当定义了一个变量后，就有能力间接的去通过全局对象的属性来引用这个变量： var a = new String(&#39;test&#39;); alert(a); // 直接, 可以在变量对象中找到: &quot;test&quot; alert(window[&#39;a&#39;]); // 间接 通过全局对象 global === VO(全局环境下的变量对象): &quot;test&quot; alert(a === this.a); // true var aKey = &#39;a&#39;; alert(window[aKey]); // 间接, 通过另一个动态属性的名称来引用: &quot;test&quot; 函数上下文中的变量对象在函数上下文中，变量对象是无法被直接访问到的，此时它变成了活动对象（Activation Object，AO）。也就是说：在函数上下文中，变量对象和活动对象是一个东西！！在函数上下文中，变量对象和活动对象是一个东西！！在函数上下文中，变量对象和活动对象是一个东西！！ VO(function Context) === AO 在执行上下文一节，提到了JavaScript解释器调用执行环境的时候分为两个步骤，第一步是进入执行上下文，在进入的同时，活动对象会被创建，这样就能访问到了。进入的同时，活动对象被值为Arguments对象的arguments属性所初始化 AO={ arguments: &lt;Arguments Object&gt; } 提一嘴Arguments对象：Arguments对象是活动对象的一个属性，里面有这些东西： 1.真正调用该函数传过来的参数的值和其对应的下标（从左到右） 2.callee： 函数的引用 3.length: 实际传过来的参数的数量Arguments不是一个数组，是一个对象，但是可以通过下标去拿到传入参数的值，他也可以被转为数组，我们来看：foo()函数有三个入参a，b，c，但是调用的时候真正传入的只有两个值，可以看到，打印出的Arguments对象中包含了两个入参的下标和对应的值以及函数的引用(callee)和实际入参的数量（是2不是3）在这张图中，利用typeof运算符课可以清晰的看出Arguments是对象，也可以通过下标来获得入参的值，但它不是数组，没有push，pop等方法。接下来看一段代码： function foo(a, b, c) { console.log(arguments.length); //2 console.log(arguments.callee === foo); // true console.log(a === arguments[0]); //true a = 30; console.log(a); // 30 console.log(arguments[0]); // 30 console.log(arguments[2]); //undefined: 这里想输出参数c的值，但是因为没传，所以是undefined c = 100; console.log(arguments[2]); //undefined // 可以看出，arguments[2]和 c 二者之间没有任何关系 // (在比较老的Google版本里面有一个bug，arguments[2]和c仍然是有关系的) } foo(15, &#39;Tiki-Taka&#39;); 对Arguments对象的介绍就大概到这里，前面说过，执行上下文时会有两个阶段，一个是进入执行上下文，一个是执行代码，那么每个阶段具体分析一下： 进入执行上下文在进入执行上下文阶段，变量对象由下列属性构成： 函数的形参（如果是函数上下文） 对于实际传过来的参数，其名字和对应的值被创建 对于没有被传参的形参，只会有其名字和其值为undefined被创建 函数声明 由名称和对应值组成的一个变量对象被创建 如果变量对象中已经存在同名的属性，则将其替换 变量声明 一个变量名称和其值（undefined）组成变量对象的一个属性被创建 如果该变量名称和之前声明的函数或者函数的形参的名称相同，则会忽略这个变量 看一个例子： function foo (x, y) { var z = 1; function bar (); var _x = function _bar () {}; } foo(2); 在进入执行上下文阶段，此时的活动对象是： AO(foo) = { arguments: { 0: 2, callee: f foo() {} length: 1 }, x: 2, y: undefined, z: undefined, bar: &lt;reference to function declaration to &#39;bar&#39;&gt; _x: undefined } 这步以后，进入了执行代码阶段。 代码执行阶段进入到代码执行阶段时，此时的活动对象中已经有了该执行上下文中的所有属性（当然他们有的值还是undefined）,在这个阶段，会顺序执行代码，同时根据变量的值修改属性的值，从上面那个例子来看，在执行代码阶段，此时的AO是这样的： AO(foo) = { arguments: { 0: 2, callee: f foo() {} length: 1 }, x: 2, y: undefined, z: 1, bar: &lt;reference to function declaration to &#39;bar&#39;&gt; _x: function _bar () {} } // 因为参数y根本没有进行传值，所以它的值还是undefined 再看一个例子： console.log(foo); // foo(){} var foo = 10; console.log(foo); // 10 foo = 20; function foo(){} console.log(foo); // 20 解释一下：进入执行上下文的时候，首先会处理函数声明，再处理变量声明，而且如果变量的声明与函数声明或函数形参同名的话，是不会去干扰原声明的： 1. AO = {} // 处理函数声明 2. AO = { foo: reference to FunctionDeclaration foo } // 处理变量声明 3. AO = { foo: the value is not disturbed, still function } 然后在函数执行的时候，foo会被赋值为10和20最后再看一个例子： if (true) { var a = 1; } else { var b = 1; } console.log(a); // 1 console.log(b)l // undefined 打印b为undefined是因为a，b都会在变量对象中，打印b的时候，引擎去变量对象中找b能找到，只不过因为else一块的代码始终没有执行，所以就没有为b赋值的一步，所以打印的是undefined。 JavaScript的作用域链在变量对象一节中，我们已经知道了执行上下文中的数据（变量声明，函数声明，函数参数）都会作为变量对象的属性被储存起来，同样我们也知道在进入执行上下文的阶段时，变相对象刽被初始化，然后在代码执行阶段进行数据的更新（赋值什么的），这一节在变量对象的基础上，我们来好好说一下执行上下文的第二个属性：作用域链。因为我们已经知道每一个执行环境都有一个对应的变量对象（对于全局对象来说就是他自己，对于函数上下文来说就是活动对象），作用域链其实就是所有内部执行环境的一个链表，它被用来做变量查找，先看一个例子： var a = 1; function foo () { var b = 2; function bar () { console.log(a + b); } return bar; } foo()(); // 3 在这个例子中，bar的作用域链包括AO(bar),AO(foo),VO(global context)。当然，这只是作用域链的简单理解，深入理解作用域链，先从它的定义开始 作用域链是一条变量对象的链，它和执行上下文有关，用于在处理标识符时候进行变量查询。 对于函数上下文来说，作用域链会在函数被调用的时候被创建，其由活动对象和函数内部的[[Scope]]属性组成比如说上例中的执行上下文，它所包含一下内容： executionContext = { VO: {...} // 或者是AO this: &lt;...&gt; ScopeChain: { ... } } 上面的ScopeChain包含了以下内容： ScopeChain = AO + [[Scope]] 下面将要介绍的 AO+[[Scope]]以及标识符的处理方式，都和函数的生命周期有关。 函数生命周期函数声明周期被定义为两个阶段：创建阶段和激活阶段 创建阶段我们知道，函数声明会在进入执行环境阶段被放到变量(活动)对象中，我们来看一个在全局环境中定义的函数和变量的例子： var a = 1; function foo () { var b = 2; console.log(a + b); } foo(); // 3 打印出的结果是我们所预料到的3，但是这个3的背后其实还有很多门道：我们知道变量b是在foo函数的活动对象中，而变量a因为不在函数foo的上下文中，而在全局的上下文中，所以a在全局的变量对象中，不在函数foo的活动对象中，也就是说foo的变量对象中目前只有一个变量声明就是b，那foo函数是如何访问到a变量的呢？一个比较合理的假设是函数应该有权限能访问到更高一层的变量对象。实际上就是这个样子的，就是通过函数的内部属性[[Scope]]来实现的这一机制的。 [[Scope]]是一个储存了所有上层变量对象的分层链，它存在于当前执行环境中，并在函数创建的时候，保存在函数中 这里要注意的一点是：[[Scope]]属性是在函数创建的时候就被保存到函数当中的，是静态的，并且一经保存后再也不变，也就是说就算一个函数永远没有被调用到，[[Scope]]属性也是会存在于函数中的，同样也要注意的是。[[Scope]]和作用域链Scope Chain的区别是前者是函数的属性，后者是上下文的属性，在上面那个例子中，函数foo的[[Scope]]属性是下面这样的： foo.[[Scope]] = { globalContext.VO// === global Object } 在这之后调用函数，就会进入到函数的上下文，此时就会创建活动对象并会确定Scope Chain和this的值。下面来详细看一下： 函数调用（激活）之前说了，进入执行上下文后，作用域链会变成下面这个样子： Scope(Scope Chain) = AO/VO + [[Scope]] 因为[[Scope]]储存了上层的所有变量对象，我们可以把它当做一个数组来理解更方便，然后创建作用域链的时候，新加进来的本上下文的AO/VO会作为作用域链这个数组的第一个元素： // 可以把[[Scope]]看做一个数组，此时只有一个元素 foo.[[Scope]] = [VO(globalContext)] // 进入执行上下文后，Scope(Scope Chain)会当前VO/AO作为第一个元素放到数组里去 Scope = [AO(foo,functionContext), VO(globalContext)] 这一个特性对于标识符的处理是非常重要的： 标识符处理其实就是决定变量（或者是函数声明）是属于作用域链中的哪一个变量对象的过程 标识符处理过程包括了对应变量名的属性查询，比如：在作用域链中会进行一系列的变量对象的搜索，从作用域链的最底层环境一直到最上层的执行环境。因此，查询变量的时候会从最底层的变量对象开始查，查不到就会向上一层继续查，直到查到全局执行上下文。如果有两个名字相同的变量存在于不同的上下文中，则底层的会被优先找到看一个例子： var a = 1; function foo () { var b = 2; function bar () { var c = 3; console.log(a + b + c); } bar(); } foo(); // 6 我们来分析一下，首先遇到全局代码，会创建一个全局上下文： globalContext = { x: 10 foo: &lt;reference to function&gt; } 然后创建foo函数的时候，该函数的[[Scope]]属性是： foo.[[Scope]] = { globalContext.VO } 然后调用foo函数，进入函数执行上下文，此时对应的执行环境栈、foo函数的上下文和其作用域链分别是 // Execution Context Stack ExecutionContextStack = [ fooContext globalContext ] // function execution context fooContext = { AO = { b: undefined, bar: &lt;reference to function&gt;, } ScopeChain: &lt;...&gt; this: &lt;...&gt; } // foo 上下文的作用域链是： ScopeChain = [ fooContext.AO, globalContext.VO ] 然后创建bar函数，其[[Scope]]属性为： bar.[[Scope]] = { fooContext.AO, globalContext.VO } 然后调用bar函数，此时的执行上下文栈、bar函数上下文和其作用域链分别是： // Execution Context Stack ExecutionContextStack = [ barContext fooContext globalContext ] // &lt;i&gt;bar&lt;/i&gt;函数上下文 barContext = { AO = { c: undefined }, ScopeChain: &lt;...&gt; this: &lt;...&gt; } // 作用域链 barContext.Scope(Scope Chain) = [ barContext.AO fooContext.AO, globalContext.VO ] 执行各个上下文中的代码阶段，为变量赋值什么的就不说了，这里着重说一下查找过程： 首先从barContext.AO中查找三个变量的值，只找到了c 其次从fooContext.AO中查找剩余两个变量的值，找到了b 最后从globalContext.VO中查找最后一个变量的值，找到了a JavaScript的this指针 JavaScript的闭包在ECMAScript中，闭包是和函数的[[Scope]]属性有直接的关系的，从上面的作用域链一节已经知道，[[Scope]]属性在函数创建的时候就被保存到函数中，一直到这个函数对象被销毁才会消失，实际上，闭包就是一个函数代码和其[[Scope]]属性的结合]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[相对路径和绝对路径]]></title>
    <url>%2F2018%2F11%2F27%2F%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E5%92%8C%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[前言一直以来，写代码的时候碰到路径的问题都是靠编译器来提示，瞎猫碰死耗子，没报错就行，直到现在才最终下决心整理一下关于相对路径和绝对路径的知识，当然关于这个网上也有很多其他大牛们的解答，我只是觉得自己写的可以让自己加深理解，所以才会去写这个文章 正文在我进行前端开发的过程中，经常性的会在某一个文件里面去引入另一个文件，这个时候就需要一些路径的知识了，当然我使用的是webstorm，它可以直接帮我生成文件的路径，很方便，但是作为一个知识点的补充，还是去了解了一下。 相对路径先来说一下相对路径，绝对路径放到后面再说先来看一张图片这个是我新建的一些乱七八糟的文件夹和文件，用于做这次的说明，为了看的清楚一点，我把这个画成一个树形结构其中标为红色的是待会会用到的，我们来做下面几个简单的操作 1.在 index.css 文件里面通过background-image属性引入 指环王1.jpg 2.在 相对路径与绝对路径.html 中引入 指环王1.jpg 3.在 相对路径与绝对路径.html 中引入 icon文件夹下的 thubnail.jpg 4.在 相对路径与绝对路径.html 中引入 index.css文件 相对路径，就是自己目前的位置相对于目标文件的位置之间的一个关系（联系），通过这个联系我们能把两个文件关联起来，那么关键就是怎么去找这个联系，对于初学者，这个需要慢慢来例如：我们进行第四条，引入一个index.css文件，先来分析一下：目标文件是index.css，要把它引入相对路径与绝对路径.html文件中，那么我们先看一下文件的结构，发现index.css在与相对路径与绝对路径.html文件同级的 style文件夹下，所以我们要先找到 style 文件夹，在找到下面的index.css就可以了按照我们找的顺序，写出相对路径： 1.找到同一级的style文件夹：style/ 2.找到style文件夹下的index.css：style/index.css 这就是最终的相对路径，现在我们把它引入html文件中即可 &lt;link rel=&quot;stylesheet&quot; href=&quot;style/index.css&quot;&gt; 上面这个例子只是最简单的说了一下相对路径怎么写，再来看一个复杂一点的：在 相对路径与绝对路径.html 中引入 icon文件夹下的 thubnail.jpg还是一步一步来，因为icon文件夹下的thubnail.jpg在与相对路径与绝对路径.html同级的images文件夹下，所以先找到images文件夹，再找到icon文件夹，最后找到thubnail.jpg，然后写出相对路径 1.找到images文件夹: images/ 2.找到icon文件夹: images/icon/ 3.找到thubnail.jpg: images/icon/thubnail.jpg 最后通过img标签把我们找到的图片放到html文件下: &lt;img src=&quot;images/logo/thubnail.jpg&quot;/&gt; 难度逐渐上升：在 相对路径与绝对路径.html 中引入 指环王1.jpg我们看到，这个指环王1.jpg（目标文件）在第二周授课文件夹下的images文件夹下，第二周授课文件夹又和相对路径与绝对路径文件夹是同级的，然后起始文件（相对路径与绝对路径.html）在它下面，所以我们就要先找到相对路径与绝对路径.html的父文件夹也就是相对路径与绝对路径这个文件夹，再找到同级的第二周授课文件夹，在向下去找直到找到目标文件 1.找到父文件夹（相对路径与绝对路径）：../ 2.找到与父文件夹同级的文件夹：../第二周授课 3.找到下面的images文件夹：../第二周授课/images 4.找到目标文件：../第二周授课/images/指环王1.jpg 最后放入html文件中 &lt;img src=&quot;../第二周授课/images/指环王1.jpg&quot;/&gt; 这里面出现了一个新的东西“../”，他的意思是“上一级目录”，也就是在例子中，../就代表了相对路径与绝对路径这个文件夹关于这个上一级目录，再来看一个例子：在 index.css 文件里面通过background-image属性引入 指环王1.jpg我们观察最上面的那个树形的结构图，可以很清楚的看到，index.css要向上找两次，找到相对路径与绝对路径这个文件夹，再去找到同级的第二次授课文件夹，在向下就可以找到目标图片了，所以： 1.找到上一级文件夹style: ../ 2.再找上一文件夹“相对路径与绝对路径”：../../ 3.找到同级文件夹“第二周授课”：../../第二周授课 4.向下找到子文件夹images：../../第二周授课/images 5.找到目标图片：../../第二周授课/images/指环王1.jpg 所以最终的路径就是：../../第二周授课/images/指环王1.jpg，我们用background-image属性引入： background: url(../../第二周授课/images/指环王1.jpg); 到这里差不多对相对路径应该就会认识到蛮多的了，关于相对路径，还有几个符号也要注意一下-&gt;“./” 代表当前目录，我们上面第二个例子原来是这样的images/icon/thubnail.jpg，其实他也可以写成./images/icon/thubnail.jpg这样，二者效果完全一样 绝对路径绝对路径很好理解，它是指目录下的绝对位置，直接到达目标位置，通常是从盘符开始的路径。比如说：”C:\blog\source_posts\相对路径和绝对路径\thubnail.jpg”这个就是绝对路径，超链接下的文件位置也属于绝对路径：http://www.e3i5.net/img/photo.jpg 。一般来说我们都用的是相对路径来引入一些资源什么的，因为使用绝对路径会有一定的风险： 有时候编好的页面，在自己的计算机上浏览一切正常，但是上传到Web服务器上浏览就很有可能不会显示图片了。因为静态HTML页面需要上传到网站，而在网站的应用中，通常我们使用”/“来表示根目录，/img/icon.jpg就表示photo.jpg文件在这个网站的根目录上的img目录里。但是要知道，这里所指的根目录并不是你的网站的根目录，而是你的网站所在的Web服务器的根目录。因为上传到Web服务器上时，可能整个网站并没有放在Web服务器的D盘， 有可能是F盘或H盘。即使放在Web服务器的D盘里，Web服务器的E盘里也不一定会存在“D:/wamp/www/img”这个目录，因此在浏览网页时是不会显示图片的。]]></content>
  </entry>
  <entry>
    <title><![CDATA[那些你不得不知道的前端常识（1）--404]]></title>
    <url>%2F2018%2F10%2F31%2F%E9%82%A3%E4%BA%9B%E4%BD%A0%E4%B8%8D%E5%BE%97%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%AF%86%EF%BC%881%EF%BC%89-404%2F</url>
    <content type="text"><![CDATA[前言今天我们来说一下 404 这个家伙相信只要上过网的人，都见过类似的界面，当熟悉的404一次次的映入我们的眼帘，我们的第一反应或许是把这个界面关掉，而不会去了解一下为什么会导致404，毕竟，知道原因以后，就算是用来装13，也是不错的选择啊ps：叶子超帅，不接受反驳！（小声） 正文404出现的原因当访问一个网页跳出404页面时，往往意味着我们访问的URL出了问题，问题的原因可能有以下几种 1.原始的URL已经失效，可能是网站的管理员修改了URL 2.网页中的一些文件更改了路径（改变了位置）或者改了名称也会导致URL失效 3.输入了错误的地址，找不到对应的文件，自然会404 什么是URL上文中我们提到的几种原因中，都离不开URL，那么什么是URL？URL是Uniform Resource Locator的缩写，翻译过来就是统一资源定位符，互联网上的每一个文件（图片啊，视频啊等等）都会有一个唯一的URL，那显然，我们只要知道了该文件所对应的URL，就可以在互联网上找到这个对应的文件了。这就像在一个小区里，每一户人家都对应了唯一的一个地址（xxx栋x单元xx楼xx户），只要有了地址，我们就可以正确的找到我们的目标。那么可想而知，当指向这个文件的URL除了问题，你还能找到这个文件或者说这个网站吗？可想而知，是不能的，那么在这种情况下，就会出现 404 的情况了。 对URL清楚的认识经过上面的解释，我们对URL也会有一个大概的认识了，但是，我们不推荐“只知其表，不知其理”这种做法，所以还需要进一步深挖一下URL。高能预警！！最无聊的部分来啦细看上面这张图，我们可以看到几个熟悉的字眼:http，www，甚至有的小伙伴对html也不眼生。其实这个普通的链接，就是一个URL，那么它大概可以分为以下几个部分： 1.protocol（协议）：协议定义因特网服务的类型，也就是前面的http，现在最常见的还有https，也就是http协议，https协议 2.hostname（主机名）：定义域主机，我们只需要知道，http的默认主机是www就可以了 3.domain（域名）：定义因特网域名（取个名字），比如说我们常见的baidu.com，上面的runoob.com，这就是域名 4.port（端口号）：定义主机端口号（http的默认端口号是 80 ），范围是0 ~ 65535（emmmmm，可以简单的理解为，门牌号…） 5.path（路径）：定义服务器上的路径（图片中的/html，说明html-tutorial.html这个文件是在/html文件夹下面）（如果省略，则文档必须位于网站的根目录中） 6.filename（文件名称）：定义文档/资源的名称，比如说上图中的html-tutorial.html，告诉我们这是一个html文件，html是文件后缀，告诉文件类型的，比如说图片常见的就是jpg，png，gif 以上的结构加起来，就大概组成了一个URL，也就是 —- 网址链接（大白话）最终，我们得到通式（高数既视感…）：protocol://host.domain:port/path/filename 404 再走一波高能预警2.0，无聊.jpg 当我们在网址输入框中写入一个链接，按下回车的时候，我们（用户）发起了一个请求，服务器在接收到请求后，会返回一个表示该请求的状态的数字代码，叫做http状态码（或者说http响应码），一共有几十种响应码，每一种都有它特定的含义，404 也是http响应码家族中的一员，它代表的意思是服务器无法根据客户端的请求找到资源（网页），简单的来说，就是找不到，这就是 404 的含义 结语毕竟涉及到URL，http响应码，甚至还牵扯到协议的东西，不可能在一篇文章中写明白，只能写一个大概，为了写的清楚易懂，有很多定义性的东西并没有放上来，所以也不排除文章中有描述不准确的地方，如说想深入了解，可以移步度娘，她啥都知道]]></content>
      <tags>
        <tag>那些你不得不知道的前端常识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[番外篇--浏览器页面渲染机制]]></title>
    <url>%2F2018%2F10%2F31%2F%E7%95%AA%E5%A4%96%E7%AF%87-%E6%B5%8F%E8%A7%88%E5%99%A8%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[前言打开一个网页，等待它跳出我们所期待看到的页面，这已经是几乎所有人生活中的常态，当然也包括我，但是在接触前端之前，我不知道也不会去想到这个从输入一个网址到弹出界面的过程是什么样子的，如果那时有人这么问我（如果有人这么无聊的话ヾ(｡ꏿ﹏ꏿ)ﾉﾞ），什么是浏览器页面渲染机制？后来在学习前端的过程中，慢慢的接触了一些这方面的东西。也就有了这篇文章，作为一个理（工）科男，这里就不废话了，直接开始正文内容吧。 正文]]></content>
  </entry>
  <entry>
    <title><![CDATA[CSS布局--position篇]]></title>
    <url>%2F2018%2F10%2F27%2FCSS%E5%B8%83%E5%B1%80-position%E7%AF%87%2F</url>
    <content type="text"><![CDATA[前言此篇文章为自己总结的CSS布局之三–position定位布局，主要用到position的三个取值：relative，absolute，fixed，我也是查了好多资料以后才下决心写这篇文章的，而且因为position定位涉及到的东西太多，所以不可能全部写到，只是写一些定位，布局，一些例子，如有错误，还请大手子指正 目录1.定位的目的与意义2.定位的类型3.包含块的概念4.偏移属性5.宽度和高度6.绝对定位7.z-index8.固定定位9.小结 正文 1.定位的目的与意义定位的原理其实蛮简单的，在上一次已经有说过float了，那么脱离文档流这个概念也不会陌生了，这样也会对这次定位的理解有帮助。利用定位，可以准确地定义元素框相对于其正常位置应该出现在哪里，或者相对于父元素，另一个元素甚至浏览器窗口本身。通过对定位的使用，我们可以实现一些细小的定位布局，相对在把握大方向的flex布局与float布局，显得更为灵活，当然，想流畅的使用定位来布局，就需要深入的对这些属性有一个理解，这也是这篇文章的目的，带着大家初步的认识一下定位的各个属性以及它们的特点。 2.定位的类型通过使用position属性，可以选择 4 种常见的，不同类型的定位 取值 是否默认值 应用范围 继承性 计算值 static 是 所有元素 无 根据实际情况而定 relative 否 所有元素 无 根据实际情况而定 absolute 否 所有元素 无 根据实际情况而定 fixed 否 所有元素 无 根据实际情况而定 先来看一下四个取值的含义 static元素框正常生成。块级元素生成一个矩形框，作为文档流的一部分，行内元素则会创建一个或多个行框，置于其父元素中。（默认值）relative元素框偏移某个距离。元素仍保持其未定位前的形状，它原本所占的空间仍保留。absolute元素框从文档流完全删除，并相对于其包含块定位。包含块可能是文档中的另一个元素或者是初始包含块。元素原先在正常文档流中所占的空间会关闭，就好像元素原来不存在一样。元素定位后生成一个块级框，而不论原来它在正常流中生成何种类型的框。fixed元素框的表现类似于将 position 设置为 absolute，不过其包含块是视窗本身。 3.包含块的概念 4.偏移属性 5.宽度和高度 6.绝对定位 7.z-index 8.固定定位 9.小结]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS布局--display:inline-block篇]]></title>
    <url>%2F2018%2F10%2F27%2FCSS%E5%B8%83%E5%B1%80-display-inline-block%E7%AF%87%2F</url>
    <content type="text"><![CDATA[前言最近因为要讲一些CSS布局的课，所以专门讲CSS的几种布局方法总结整理出来写到了博客上，本篇文章是CSS布局(一)–display:inline-block篇，后面还有CSS布局–float篇，CSS布局–position篇以及CSS布局–flex篇，至于table布局，主要是自己用的也不多，就不在这里班门弄斧了。 目录1.块级元素和行内元素2.CSS display属性3.display:inline-block布局4.幽灵空白节点5.莫名其妙的错位6.总结 块级元素和内联元素因为display”inline-block涉及到了inline和block，那么块级元素和内联元素我们就不得不来说一下了。我们先说，常见的块级元素有div，li，table，p，ul，ol等，常见的内联元素有span，em，i，我们先从一个例子入手，看一下两种元素的区别html代码: &lt;div class=&quot;parent&quot;&gt; &lt;div&gt;常见块级元素--div&lt;/div&gt; &lt;p&gt;常见块级元素--p&lt;/p&gt; &lt;h1&gt;常见块级元素--h1(h1~h6)&lt;/h1&gt; &lt;ul&gt; &lt;li style=&quot;width: 150px;height: 150px&quot;&gt;块级元素可以设置宽高 &lt;br&gt;width:150px height:150px&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;parent&quot;&gt; &lt;a href=&quot;&quot;&gt;常见的内联元素--a&lt;/a&gt; &lt;span&gt;常见的内联元素--span&lt;/span&gt; &lt;em&gt;常见的内联元素--em&lt;/em&gt; &lt;i style=&quot;width: 200px;height: 250px&quot;&gt;内联元素不可以设置宽高 width: 200px;height: 250px&lt;/i&gt; &lt;/div&gt; css代码： .parent{ width: 100%; height: 400px; border: 2px solid #000; box-sizing: border-box; margin: 15px 0; } .parent:nth-of-type(1) div{ background-color: #856404; margin-left: 15px; margin-bottom: 15px; margin-right: 15px; margin-top: 15px; padding-left: 15px; padding-bottom: 15px; padding-right: 15px; padding-top: 15px; } .parent:nth-of-type(1) p{ background-color: #00A000; } .parent:nth-of-type(1) h1{ background-color: #c10802; } .parent:nth-of-type(1) li{ background-color: #3b5998; } .parent:nth-of-type(2) a{ background-color: #856404; } .parent:nth-of-type(2) span{ background-color: #00A000; margin-left: 15px; margin-bottom: 15px; margin-right: 15px; margin-top: 15px; padding-left: 15px; padding-bottom: 15px; padding-right: 15px; padding-top: 15px; } .parent:nth-of-type(2) em{ background-color: #c10802; } .parent:nth-of-type(2) i{ background-color: #3b5998; } 效果图如下：块级元素：行内元素我们可以看出，块级元素默认会占满父元素的宽度（在本例中因为设置了父元素的宽度为100%也就是浏览器的宽度，所以子元素会占满浏览器一整行的宽度），而且与内容的宽度无关，也就是说，就算块级元素内容的宽度不足浏览器一整行的宽度，块级元素仍然会占满浏览器一整行的宽度，除此之外，我们看到块级元素还可以设置宽度和高度，此时内容如果在容器宽度内一行放不下的时候会换行，我们还可以看到对行内元素设置margin和padding，四个方向left，eight，bottom，top都会起作用。内联元素，从例子中我们可以看出，内联元素的宽度是内容的宽度，而且不会默认占满父容器的一整行，而且当给内联元素设置宽度个高度时不会有效果，还有我们可以发现，给内联元素设置边距margin和padding的时候，对于margin，只有margin-left和margin-right起到了作用，而margin-top和margin-bottom没有起到作用，padding在四个方向均有效果。所以总结一下块级元素和内联元素的区别 块级元素会独占一行，在内容不满父元素宽度的情况下，块级元素的宽度默认会是父级元素的宽度 内联元素默认情况下的宽度就是内容的宽度，每一个内联元素会首先在一行内排列，直到内容的宽度超过父容器的宽度时才会换行 块级元素可以设置宽高 内联元素不可以设置宽高 块级元素的margin和padding在四个方向上都会起作用 内联元素的margin在上下两个方向无效，padding在四个方向上都会起作用（IE,Chrome，Firefox下均成立）CSS display属性上文中我们总结了行内元素和内联元素的区别，这节我们在写一下内联元素与块级元素之间的转换，通过display的几个属性。display属性我们常用的几个值有display:inline，display:block与display:inline-block。我们在一般情况下可以通过display:block将内联元素变为块级元素，比如说:span{ display:block; } 这样设置以后，原本为内联元素的span就拥有了块级元素的特性。同样，我们也可以通过display:inline将块级元素转化为行内元素，比如说div{ display:inline; } 这样设置以后div就变为了一个内联元素，拥有内联元素的特性。既然display:block属性可以将内联元素变块级元素，那么是不是display:block就与块级元素等价了呢？其实并不是的，我们常见的几个块级元素比如li，table都是块级元素，但是我们查看这几个元素对应的源码会发现: li{ display:list-item; } table{ display:table; } 也就是说，“块级元素”与display为block的元素并不是一个概念，当然，其他常见的块级元素比如div，p等，都会有一个display:block添加在其样式中，在实际的开发中，我们常用的就是display:block，偶尔也会使用display:table，至于display:list-item，因为我们都知道li标签下会有一个圆点样式，当然我们也可以加一句list-style”none”用来去除圆点样式，只不过这样会有一点代码冗杂的问题，不如直接使用display:block简单。display:inline-block属性，单单从字面意思上就可以看出，使用display:inline-block声明过后的元素，即会具有块级元素的性质，也会具有内联元素的性质，可以说是将二者的优点结合了一下，在下面一节详细讲一下display:inline-block属性。 display:inline-block布局上面说道，设置了display:inline-block以后的元素会同时具有块级元素和内联元素的性质，那么我们先来看看设置了display:inline-block后会有哪些变化吧：html代码 &lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; css代码 div{ width: 1200px; border: 1px solid #000; background-color: #f0f0ff; height: 300px; margin: 0 auto; } ul,li{ /*清除圆点样式*/ list-style: none; } li{ width: 240px; height: 240px; background-color: #00A000; display: inline-block; padding: 15px; } 最终效果：通过这张图片，我们可以总结以下几点关于设置了display:inline-block后的元素的特性： 在不超过父元素宽度的前提下，所有元素会排列在一行 可以设置宽高 margin和padding的四个方向都会起作用 黑白通吃，可以在其内部放块级元素（block），也可以将其放在内联元素（inline）下面这里提出一个问题：有没有想过为什么这样设置就可以是元素既有块级元素的特性，也有行内元素的特性？关于这个问题的解答，在我的另外一篇文章中，我会有写，不过希望大家能先思考一下。幽灵空白节点现在看起来，设置了display:inline-block以后，元素具有了块级元素和内联元素的优点，那这样设置会不会有什么潜在的bug呢？细心地小伙伴可能已经发现了一个问题：就是我们上一张图片显示的每一个设置了display:inline-block的li之间，都会有一个“空格”，这个空格为什么会出现？它的存在有什么不好的效果吗？我们一一来看。“空格”出现的原因：仔细看代码会发现，每写完一个li，会加一个回车，正是这个回车，这个回车在渲染的时候会被渲染为一个空白符（如果有多个回车则会被合并为一个空白符），那么这个空白符就是导致li元素之间“空格”的“元凶”。既然知道了空白符是如何出现的，那么我们也就有了消除空白符的方法，我在这里介绍4种，感兴趣的朋友可以了解一下1.闭合标签与开启标签放在同一行既然我们说道空白符是由于换行引起的，那么我们自然就会想到，不换行，不久解决了吗？例如下面这样子 &lt;ul&gt; &lt;li&gt; &lt;p&gt;...&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;...&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; 将开始标签与关闭标签放在同一行，那么这样子，空白符就不见了但是这样写，无疑会使代码的可读性很不好，所以尽管可以，但是我们不推荐使用，尤其是在开发项目的时候。 2.letter-spacing前面我们说到，这个“空格”其实是一个空白符，本质上也是一个字符，只不过我们看不见而已，那么既然是字符，当然就可以用处理字符的方法来对其进行修整了，所以我们用到了letter-spacing属性，通过为letter-spacing属性设置负值，使文字水平方向重叠，自然就可以消除空白符了。 ul{ letter-spacing:-5px; } 我们为父容器设置letter-spacing值为 -5 px（空白符的宽度为 5 px），达到了预期的效果。 3.font-size:0同样，针对字符，我们也可以通过设置字体大小来将其消除 ul{ font-size: 0; } 效果与letter-spacing属性设置为-5px一样 4.margin-right因为每一个li的右边都存在一个空白符，所以我们也可以通过设置右外边距为负值来达到消除空白符的效果 li{ /*通过外右边距 去掉空白符的方法*/ margin-right: -5px; } 效果与上面的方法一样，就不再放图片了。 莫名其妙的错位当我们给每一个li里面都加了文字以后，结果却出现了错位？？？？我们先来看一下出现问题时候的样子出现问题的原因是：此时的li默认垂直对齐方式是vertical-align:baseline。什么？不明白什么意思？请看我的另一篇文章：关于css baseline的那些事 总结本文旨在说明一下display:inline-block在布局中的使用，实际上，display:inline-block还有许多幕后的内容没有说到，有关display:inline-block的其他内容，我会以后慢慢更，只希望大家在看完这篇文章后对使用display:inline-block用来布局有所了解即可，and本文若有错误观点，欢迎指正~]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS布局--float篇]]></title>
    <url>%2F2018%2F10%2F27%2FCSS%E5%B8%83%E5%B1%80-float%E7%AF%87%2F</url>
    <content type="text"><![CDATA[前言CSS中的难点之一就是CSS布局了，常见的CSS布局有几种，无非就是通过float属性，display:inline-block属性，position属性，flex布局以及通过table元素来进行布局等，这其中，table布局相对较为古老，而且有许多问题，比如说我们通过table元素的布局是在html中进行的，相对来说与CSS关系不大，这样读起来很让人抓狂。float浮动布局和position属性的布局又存在很多问题，如果对属性的理解不够深入，在使用这些属性进行布局的时候就会经常出现一些莫名其妙的效果让人云里雾里。至于flex布局，是近几年新出的一个CSS布局的方法，相对来说简单易行一些，当然对我们前端开发者来讲，起码的几种CSS布局都最好要掌握一些，所以这篇博文主要讲一下float这个属性，即如何用float来对网页内的元素进行布局，其余的position属性以及flex属性，在我的另外两篇博文中会有详细介绍。 目录1.一个概念2.用float实现简单的布局3.一些意料之外的结果4.float的前生5.揭开float的真面目6.遏制浮动–清除浮动7.浮动实现CSS常见布局018.浮动实现CSS常见布局02本篇博客是看过了许多大牛们的博客之后自己总结出来的，为了深入理解float自己也写了不少demo，所有的代码都可以在我的github上找到，下面附上我的github地址以及一些大牛们对float的回答(1)张鑫旭 CSS float浮动的深入研究、详解及拓展(一)(2)张鑫旭 CSS float浮动的深入研究、详解及拓展(二)(3)我的github地址 1.一个概念在正式说float属性之前，我们先来看一个概念，理解了这个概念以后，对后文的float属性的理解也会有所帮助。 普通流什么是普通流？以下内容引自w3school CSS 有三种基本的定位机制：普通流、浮动和绝对定位。除非专门指定，否则所有框都在普通流中定位。也就是说，普通流中的元素的位置由元素在 (X)HTML 中的位置决定。块级框从上到下一个接一个地排列，框之间的垂直距离是由框的垂直外边距计算出来。 在w3c的描述中，我们知道普通流就是默认情况下html中标签（元素）的排列方式，比如说块级元素就是一行一个，一个块级元素占满一行（从上到下），内联元素就是会占满一整行以后才会换行（从左到右）。如此就是普通流，理解起来应该没有问题，我们一般情况下默认所有的html元素都会在普通流中排列。 2.用float实现简单的布局在正式深入理解float之前，我们先来看看用float可以实现怎样的布局这里有简单的四个div，在没有添加float之前，由于块级元素的特性，他们是按照下面的这种样子排列的现在添加一个左浮动再来看看右浮动通过这个简单的例子我们可以看出来，使用float属性可以达到让元素在同一行排列的效果，而且不同于display:inline-block，元素之间不会出现由于换行而导致的空白符占位情况。所以从目前来看，可以说，float在一定程度上是优于display:inline-block的 3.一些意料之外的结果我们再来看一个例子，还是那几个div，只不过这次我将原先给父容器设置的高度拿掉，让父容器自适应高度，也就是说，子元素一共多高，父元素就多高，同时给父容器加上下两个颜色不同的边框然后我们给子元素添加float:left，即左浮动我们可以看到，父容器的上下两个边框挨在了一起。再来添加一下右浮动看一下同样的情况再次出现了，那么为什么会导致这种情况的出现？这就需要我们去深入的对float理解一下了。 4.float的前生CSS里面的float属性，说起来已经是一个拥有很大年龄的属性了，说不定比在看这篇文章的人还要大那么一点点（？）因为我们在开发中会经常用到float属性来为布局提供方便，所以可能会有大部分的新手开发人员就会认为float属性就是为布局而量身定做的，如果你是这样想的，那么很不好意思，这并不是float的初衷，float真正的作用，是为了实现文字环绕效果。对你没看错，就是为了用它来实现 word 文档里面那种文字环绕图片的效果，我们可以来看一个例子所以说，float最初的作用就是用来实现文字环绕的效果，但是在后来慢慢发现这家伙可以用来布局，于是就精彩了，float广泛的被用于各种布局中，随之而来的也是各种各样的问题，所以说，想要用好float，就要去解决这些问题。 5.揭开float的部分真面目 在第三节的例子中可以看到，当给子元素添加了float:left或者float:right以后，父容器的上下两个边框挨到了一起，这说明父容器的高度没有了，因为只有当父容器的高度消失以后，上下的边框才会挨在一起。因为我们给父容器设置的是自适应高度也就是父容器的高度其实就是子元素的高度加在一起以后被“撑开”的，既然父容器的高度消失了，那么我们有理由认为，子元素的高度也消失了 但是我们在浏览器上面是能看到子元素的，那这个和子元素高度的推论不久冲突了吗？实际上，这个就和之前写的普通流挂钩了，前面说过在一般情况下html中的元素都是在普通流中排列的，那么float正是这个不一般的存在，设置了float属性的元素会脱离文档流，因为我们正常计算高度都是基于普通流来计算的，那么当元素脱离普通流以后，它的高度自然就“不存在”了，这也是为什么添加了float属性以后父容器的高度会消失了，我们把这种情况叫做“高度塌陷”。 总结来讲，设置了float浮动的元素会脱离正常文档流，导致父元素高度塌陷。 6.遏制浮动–清除浮动正所谓一物降一物，既然知道了利用浮动会导致父容器高度塌陷，那么也一定有一些办法来解决这个问题，这就是常说的 —- 闭合浮动（清除浮动）最常用的消除浮动的方法就是使用clear属性定义：clear 属性规定元素的哪一侧之前不允许出现其他浮动元素。可能的取值 值 描述 left 在左侧不允许浮动元素 right 在右侧不允许浮动元素。 both 在左右两侧均不允许浮动元素。 none 默认值。允许浮动元素出现在两侧。 inherit 规定应该从父元素继承 clear 属性的值。 我们最常用的就是clear:both，因为可以设置clear:left与clear:right的地方均可以用clear:both直接代替，所以说clear:left与clear:right这两个声明基本上就没有什么使用的价值了。我们看一个添加了clear:both后的效果如图，我们给第二个li设置了clear:both以后，整体分为了两行，可能有的小伙伴会疑惑啊，设置了clear:both不是两边都不允许有浮动元素吗，为什么不是三行而是两行呢？这就是clear属性的一个特性了，clear属性是让自身不能和前面的浮动元素相邻，注意是前面的！！也就是说，clear对后面的浮动元素充耳不闻，因此才是两行而不是三行。当然，我们清楚浮动的主要目的是让父容器的高度“变回来”，不想看到它高度塌陷，所以我们只需要给父容器加一个clear:both即可如图所示，父容器的高度“回来了”！除了使用clear以外，再推荐一种方法，就是创建BFC我们创建BFC的一个方法就是添加overflow:hidden，当我们给父容器加上overflow:hidden时，我们可以看一下效果同样达到了清除父容器高度的效果 7.浮动实现CSS常见布局01第一个是常见的两栏自适应布局，即两个容器，左边固定宽度，右边宽度自适应 8.浮动实现CSS常见布局02圣杯布局]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS flex布局学习]]></title>
    <url>%2F2018%2F10%2F13%2FCSS-flex%E5%B8%83%E5%B1%80%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[前言flex的出现使css的布局大大简化，例如两栏自适应等常见CSS布局通过使用flex布局能非常方便的达到，然而在网上常见的flex布局的教程中，许多属性的深层意思都没有提及，例如flex-grow与flex-shrink属性，正好这段时间我也开始在学flex布局，而且我这个人一向的习惯就是新学的东西一定要有笔记，以前用那些办公软件记笔记，结果有一次都丢了，自那以后搭建起了博客，一些笔记就都放在了博客上面，所以今天传上来这个flex布局的笔记，希望大家看过后能有所收货。ps：以下所有内容是我在看完菜鸟教程以及阮一峰老师的博客后所写，链接给大家。 目录1.什么是flex布局2.flex布局中一些相关的概念3.指定flex布局4.容器属性：flex-direction5.容器属性：flex-wrap6.容器属性：flex-flow7.容器属性：justify-content8.容器属性：align-items9.容器属性：align-content10.项目属性：order11.项目属性：flex-grow12.项目属性：flex-shrink13.项目属性：flex-basis14.项目属性：flex15.项目属性：align-self内容比较多，我自己一次也写不完，慢慢来吧~ 1.什么是flex布局我们都知道，CSS的布局是一个难点，先不说flex，常见的CSS布局比如说有两栏自适应，两翼齐飞布局什么的，其实说白了只要涉及到元素的位置的安排，都算是布局，那在flex之前我们常用的手段有float，position，table等，但是这些属性本身不是为布局而生的，就比如说float，它本质就是实现一个文字环绕效果，但是用这些属性吧，你要是理解的不够深入，还会出现各种各样的坑，比如说一会脱离文档流啦（float，position的absolute和fixed），position的定位原点什么的，会导致网页布局乱七八糟。那么flex布局，flex是flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。目前，flex布局已经得到所有浏览器的支持，这意味着，现在可以放心的使用这项技术 2.flex布局中一些相关的概念这节介绍一些flex布局中的一些定义，一些概念性的东西我们把设置为flex布局的容器叫做flex容器，简称“容器”，该容器的所有的子元素会自动成为该容器的成员，称为flex项目，简称“项目”。容器默认存在两根轴，一个是水平的主轴（main axis）（如图），还有一个是垂直的交叉轴（cross axis）。主轴开始的位置叫做main start，结束位置叫做main end；交叉轴开始的位置叫做cross start，结束的位置叫做cross end。容器的子元素也就是项目默认沿着主轴排列，单个项目占据的主轴空间叫做main size，占据的交叉空间叫做cross size。 3.指定flex布局上面说过，设置了flex布局的容器叫做flex容器，我们可以通过display属性将该容器声明为一个flex布局的容器: .container{ display:flex; } 行内元素也可以设置flex布局 .container{ display:inline-flex; } 注意一个问题，容器设置为flex布局以后，其子元素的float，clear以及vertical-align都会失效 4.容器属性：flex-direction注：从下面开始，凡是标注了“容器属性”后面的所有属性都是设置在容器也就是父元素身上的。标注了“项目属性”的所有属性都是设置在子元素上面的flex-direction决定主轴（水平）的方向（即项目(子元素)的排列方向）flex-direction有四种取值(1)row（默认值）：主轴在水平方向，起点在左端(2)row-reverse：主轴在水平方向，起点在右端(3)column：主轴在垂直方向，起点在上端(4)column-reverse：主轴在垂直方向，起点在下端从例子中能更好的学习理解，所以我做了下面的demo效果如下： 5.容器属性：flex-wrap默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。分情况讨论，当flex-direction的值为row时，如果不设置flex-wrap属性，即取默认值的时候，所有项目会默认从左到右排列在一行，如果所有项目的宽度加起来超过父容器的宽度，则会压缩项目的宽度。如图所示在代码中我默认设置了每一个项目的宽度都是150px，然而可以发现，12个150px加起来12×150=1800px已经超过了父容器的宽度，然而此时并没有换行，而是压缩了子元素的宽度，使其不足150px设置flex-wrap:wrap时，在父容器放不下所有项目时，会换到下一行排列，多余的不足一个项目宽度的地方会空出来，不会填满设置flex-wrap:wrap-reverse的时候，会从最下面开始排列，排列不下了在往上一行放，以此类推当flex-direction的值设置为column时，如果flex-wrap取默认值也就是no-wrap，则会按顺序以一列的形式从上到下排列，如果flex-wrap设置了wrap，则会现在一列里面排列，如果高度超出父容器的高度，则会换到第二列，以此类推，直到排列完（不会被父容器宽度所限制）例如： flex-direcrtion:column,flex-wrap:wrap flex-direcrtion:column,flex-wrap:wrap-reverse其余flex-direction的值与此相似 6.容器属性：flex-flowflex-flow是flex-direction属性和flex-wrap属性的简写，格式如下：flex-flow: ||具体内容见上面，这里不详细介绍 7.容器属性：justify-contentjustify-content属性定义了项目在主轴上的对齐方式。justify-content有六种取值(1)justify-content:flex-start(左对齐)(2)justify-content:flex-end(右对齐)(3)justify-content:center(水平居中)(4)justify-content:space-around（每个项目两侧的间隔相等，这样项目之间的间隔比项目与边框的间隔大一倍)(5)justify-content:space-between(两端对齐)(6)justify-content:space-evenly（项目与项目，项目与边界的间隔都相等 ）注：以上所有排列都是在父容器设置了flex-direction:row的前提下，其余的自己可以动手试一下 8.容器属性：align-itemsalign-items属性定义项目在交叉轴（竖直方向）上如何对齐。align-items有5种取值(1)align-items:flex-startalign-items:flex-start定义项目从交叉轴的起点开始对齐(2)align-items:flex-endalign-items:flex-end定义项目从交叉轴的末端开始对齐(3)align-items:centeralign-items:center定义从交叉线的中点开始对齐（垂直居中）(4)align-items:baselinealign-items:baseline定义从第一行文字的基线开始对齐(5)align-items:stretchalign-items:stretch定义：如果项目未设置高度或设为auto，将占满整个容器的高度 9.容器属性：align-contentalign-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。那怎么样才能有多个轴线呢？其实，只需要让项目换行显示就可以，所以我们需要设置flex-direction属性的值为wrap或者wrap-reverse（例子中使用的是wrap），也就是当所有项目一行放不下的时候，项目会换行显示，这样子就会有多个轴线了。该属性有7个取值(1)align-content:flex-startalign-content:flex-start定义项目与交叉轴的起点对齐(2)align-content:flex-endalign-content:flex-end定义项目与交叉轴的终点对齐(3)align-content:centeralign-content:center定义项目与交叉轴的中点对齐(4)align-content:space-betweenalign-content:space-between定义项目与交叉轴两端对齐，轴线之间的间隔平均分布。(5)align-content:space-aroundalign-content:space-around定义项目之间每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。(6)align-content:space-evenlyalign-content:space-evenly定义所有间距都相等(7)align-content:stretchalign-content:stretch定义轴线占满整个交叉轴，项目不设置高度或者高度为auto 10.项目属性：order注：以下所有属性都是设置在子元素上面的order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 11.项目属性：flex-growflex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大关于这个属性以及下面的flex-shrink属性，在菜鸟教程和阮一峰老师的博客中并没有详细的对此进行解释，只是有上面的一句话，所以我把我自己的理解以及计算方式整理在下面，以供参考首先，flex-grow属性决定了在所有项目的排列方向上还有剩余的空间时，如何分配这些剩余的空间，其值为一个权重，默认是0，也就是不扩张，父元素剩余的空间会按照这个权重来进行分配。先来看一个demo父容器的宽度设置为1000px，5个项目（子元素）的宽高均为40px。现在是我们没有设置flex-grow熟悉的时候，也就是该属性的值默认为0的时候，此时所有项目默认不扩张，按照自身的宽高进行排列，可以看出，父元素上还有如下几个属性，使项目能垂直居中排列 display: flex; flex-wrap: wrap; align-items: center; justify-content: center; 我们现在给标号为1的项目加上属性flex-grow:1，先看看是什么效果可以看出，标号为1的项目占满了剩下的所有宽度，把其余几个项目都挤到了右边再来看几个例子①给标号为1的项目设置flex-grow:1，给标号为2的项目设置flex-grow:2可以看出，2项目的宽度接近1项目宽度的两倍，父元素排列方向上的宽度被占满②给5个项目的flex-grow属性分别设置为1到5 .items1{ flex-grow: 1; } .items2{ flex-grow: 2; } .items3{ flex-grow: 3; } .items4{ flex-grow: 4; } .items5{ flex-grow: 5; } 可以看出，5个项目的宽度相对于第一个项目的宽度依次扩大了其序号所对应的倍数上面两个例子对应的所有项目的flex-grow属性之和都大于1，我们来看一个不大于1的例子③所有项目的flex-grow属性对应的值之和小于1 .items1{ flex-grow: 0.1; } .items2{ flex-grow: .1; } .items3{ flex-grow: .05; } .items4{ flex-grow: .2; } .items5{ flex-grow: .15; } 可以看出，扩大后他们并没有占满父元素所有的剩余空间 总结从上面的例子中，我们可以看出，flex-grow属性之和大于1和小于1显示的效果是不一样的，那么我们分开来讨论一下他的计算方式Ⅰ.当flex-grow属性之和大于1时，五个项目的宽度都是40px，那么剩余空间为1000-5*40 = 800px。五个项目的flex-grow属性为1,2,3,4,5，合起来是sum = 15，所以5个项目分配到的多余的空间为 800 * 1 / 15 = 53.3333333px 800 * 2 / 15 = 106.66666667px 800 * 3 / 15 = 160px 800 * 4 / 15 = 213.333333px 800 * 5 / 15 = 266.666667px 那么这5个项目最终扩张以后的宽度为93.33333333px，146.6666667px，200px，253.333333px，306.6666667px（在40px的基础上加上扩展的宽度）看一下项目的宽度和我们计算的所差无几，说明这样算是正确的我们还可以发现一点，flex-grow属性值为2的项目最终的宽度并不是flex-grow属性值为1的项目的最终宽度的2倍，而是扩展的（变化的）宽度为2倍！！！！！！Ⅱ.当flex-grow属性之和小于1时，五个项目的宽度都是40px，同样剩余空间为1000-5*40 = 800px。五个项目的flex-grow属性值为0.1，0.05,0.2，0.15,0.3，合起来是sum = 0.8 &lt; 1。同样，剩余800px的空间当所有元素的flex-grow属性之和小于1的时候，上面式子中的sum将会使用 1 来参与计算，而不论它们的和是多少，也就是说，这个 0.8 没有什么作用，此时的sum默认按照 1 来计算。那么五个项目扩展的宽度为 800 * 0.1 / 1 = 80px 800 * 0.05 / 1 = 40px 800 * 0.2 / 1 = 160px 800 * 0.15 / 1 = 120px 800 * 0.3 / 1 = 240px 所以最终 5 个项目的宽度分别为 120px，80px，200px，160px，280px可以发现，800px - 80px - 40px - 160px - 120px - 240px = 160px，也就是说，还剩下160px的宽度没有被占满同样我们可以在浏览器里面查看各个项目的宽度与我们计算的一毛一样，完美~ 12.项目属性：flex-shrink上面的flex-grow属性会在父元素有多余的空间的使用通过子元素的扩张来占满这些剩余空间，那么同样就会有在父容器空间不够时将子元素收缩以来适应父元素的空间的属性了，也就是flex-shrink属性flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。那么就像上面flex-grow属性一样，flex-shrink属性也有自己的计算方式，以此来计算子元素该如何收缩。同样，我们先来看flex-grow属性值适合大于1的情况①flex-grow属性值之和大于1我们设父容器的宽度为1000px，5个项目的宽度均为300px，这样多出来的宽度就是300 5 - 1000 = 500px,5个项目flex-shrink属性的值依次为1,2,3,4,5。那么这多出的500px将会由5个项目分别收缩一定的比例来消化。项目收缩的计算公式：超出的总宽度 收缩因子 / 收缩权重 项目宽度收缩因子即为flex-shrink属性的值收缩权重的计算公式：项目宽度 对应的收缩因子所以本例中的权重为：300 1 + 300 2 + 300 3 + 300 4 + 300 * 5 = 4500px所以我们计算每个项目的收缩量如下： 500 1 / 4500 300 = 33.3333333px 500 2 / 4500 300 = 66.6666667px 500 3 / 4500 300 = 100px 500 4 / 4500 300 = 133.333333px 500 5 / 4500 300 = 166.666667px 收缩后每个项目的宽度为 266.66667px，233.33333px，200px，166.666667px，133.333333px我们看一下浏览器显示的宽度以验证我们的结果②flex-grow属性值之和小于1当flex-grow属性值之和小于1时，并不会完美的收缩到正好占满所有的空间而没有溢出，就像flex-grow属性的所有值之和小于1一样，也会按照和sum为1来进行收缩现在设flex-grow属性值分别为0.05,0.1,0.15,0.2,0.25,权重为：300 (0.05 + 0.1 + 0.15 + 0.2 + 0.25) = 225px那么 5 个项目收缩的总和是(0.05 + 0.1 + 0.15 + 0.2 + 0.25) 500px 也就是375px，也就是说，最终收缩完，项目综合还是会超出父容器125px的宽度每个项目收缩的空间为 300 0.05 375 / 225 = 25px 300 0.1 375 / 225 = 50px 300 0.15 375 / 225 = 75px 300 0.2 375 / 225 = 100px 300 0.25 375 / 225 = 125px 所以收缩后的每个项目的宽度为 275px，250px，225px，200px，175px收缩后的宽度之和为：275 + 250 + 225 + 200 + 175 = 1125px，正好多出125px。浏览器里面显示如下：可以看出，最终所有项目的和的宽度还是超过父元素的宽度的 13.项目属性：flex-basisflex-basis属性用于设置或检索弹性盒伸缩基准值。什么意思，就是说flex-basis属性用于设置项目的基准宽度（width），与width属性有异曲同工之妙，但是与width属性又有很大不同。我们都知道，如果没有给一个容器设置宽度的话，那么容器的宽度就是内容（content）的宽度，而flex-basis属性设置后的宽度会覆盖width属性所设置的宽度，也就是说，三者的优先级是这样的 content &lt; width &lt; flex-basis 总的来说就是 如果没有设置flex-basis属性，那么flex-basis的大小就是项目的width属性大小 如果没有设置width属性，那么flex-basis的大小就是项目的内容（content）宽度大小 下面我们来看一些生动的例子我们将容器的宽度设置为1000px，为了方便查看我们令其局中显示(margin: 0 auto;) .wrapper{ width: 1000px; border: 1px solid #000; box-sizing: border-box; margin: 0 auto; background-color: #CCCCCC; height: 400px; display: flex; flex-direction: row; flex-wrap: nowrap; } 给容器下面的每一个项目都设置宽度(width)为100px，flex-basis的值为150px，然后查看浏览器宽度为150px，①说明flex-basis属性会覆盖width属性的取值flex-basis属性也会被max-width属性与min-width属性所限制，我们看例子 .items{ width: 100px; flex-basis: 150px; /*flex-grow: 1;*/ min-width: 250px; height: 250px; background-color: #00A000; border: 1px solid #000000; box-sizing: border-box; } 在上面的代码中，设置了项目的flex-basis属性值为150px，然而设置了min-width属性的值为250px，也就是说，如果min-width属性占了上风，四个项目会正好填满父容器，那是不是这样子呢？很明显，这次是min-width属性占了上风，那么同样，我们在设置了max-width属性后，同样会限制flex-basis属性，如果flex-basis属性的值超过了设定的max-width属性的之后，那么最终显示的会使max-width属性所设定的值。那么当我们设置的所有项目的flex-basis属性值之和大于父容器的宽度后，那么此时起作用的将会是flex-shrink属性了，同样，当项目flex-basis属性值之和达不到父容器的宽度时，我们也可以使用flex-grow属性使其扩展到占满父元素，有关这两个属性已经在上面有详解，这里就不再细说了。 14.项目属性：flexflex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。flex属性因为是三种属性的简写，而flex-grow与flex-shrink是起完全相反的作用的两个属性，所以当然要分情况讨论当这两个属性在不同的项目与容器宽度之比下起到的作用，举个栗子如果父容器的宽度小于项目宽度（此时的宽度使用到的flex-basis属性设置的）之和，那么flex-shrink属性就会起作用，具体计算方式见上如果父容器的宽度大于项目宽度（此时的宽度使用到的flex-basis属性设置的）之和，那么flex-grow属性就会起作用，具体计算方式见上 15.项目属性：align-selfalign-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretchalign-self属性的取值有auto，flex-start，flex-end，center，baseline，stretch，每一个值的意思就是上面所说到的意思我们可以通过看一个例子演示来形象的理解该属性的效果其中，在父容器中设置了justify-content:center与align-items:center使所有项目居中显示，然后给第二个项目设置了align-self:flex-start使其从顶端开始排列，给第三个项目设置了align-self:flex-end使其从底端开始排列，同时覆盖了原来的align-items的效果。]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bootstrap学习笔记]]></title>
    <url>%2F2018%2F08%2F29%2Fbootstrap%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言前几天为了写一个响应式开发的项目，于是学习了bootstrap这个框架，个人认为，bootstrap最强大的地方就在于它的布局，也就是栅格系统，所以在这里也贴出自己学习bootstrap时整理的笔记，着重会讲到bootstrap的栅格系统以及自己踩过的坑等等。注意，复制本文的代码并使用时，里面库的引入需要将路径改为自己的bootstrap路径 正文将要叙述的东西罗列了一下，大概有下面几点1.什么是响应式布局2.媒体查询3.bootstrap的下载与使用4.bootstrap基本模板5.bootstrap中container类–第1个类6.bootstrap中container-fluid类–第2个类7.bootstrap的栅格系统8.bootstrap响应式工具(响应式工具类)9.bootstrap导航条10.bootstrap的collapse(折叠)组件11.bootstrap轮播图12.bootstrap中的Affix(吸顶)组件13.总结：bootstrap常用类ps:上面只是介绍了bootstrap中很少的一部分，更多有关bootstrap内容请移步bootstrap官方中文文档 1.什么是响应式布局前面提到过，用到bootstrap的目的是用来做一个响应式的项目。那么，什么是响应式开发呢？百度百科给出的响应式布局的概念如下： 响应式布局是Ethan Marcotte在2010年5月份提出的一个概念，简而言之，就是一个网站能够兼容多个终端——而不是为每个终端做一个特定的版本。这个概念是为解决移动互联网浏览而诞生的。 响应式布局可以为不同终端的用户提供更加舒适的界面和更好的用户体验，而且随着目前大屏幕移动设备的普及，用“大势所趋”来形容也不为过。随着越来越多的设计师采用这个技术，我们不仅看到很多的创新，还看到了一些成形的模式。 不出意料，百科里面给出的定义不去仔细研读的话好像是不怎么看得懂，下面我给翻译一下：什么叫做一个网站能够兼容多个终端，我们来看两张图（给个面子，忽略排版问题）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们只看数字的部分，左面这张图是屏幕宽度1270px时候显示的样子，可以看出是一行有三个数字，右面这张是屏幕宽度为375px时候的显示效果，可以看出现在是一行一个数字，而不是一行三个数字了。所以，什么是一个网站能够兼容多个终端，我自己的理解是这样的：一个网站（网页），在不同浏览的屏幕宽度下显示的效果不同，达到了只需要写一个网站，就可以在电脑屏幕，平板屏幕，手机屏幕等多种设备（终端）上均能正常的浏览，而不是单独的针对电脑屏幕写一个网站，针对平板的屏幕大小再写一个网站，很大程度上简化了工作量。至于定义后面的针对移动互联网浏览而诞生的这点，涉及到了移动端的知识，后见会讲。好了，到这里应该会理解了什么是响应式，那么如何来实现响应式呢？这就用到了媒体查询。 2.媒体查询读到这里我们应该已经了解了什么是响应式开发，而媒体查询就是用来实现响应式开发的一种“工具”，下面我们来介绍通过css的media来实现媒体查询，具体的格式为 @media mediatype and|not|only (media feature) { CSS-Code; } 首先如同声明一个css动画一样，我们用@media声明一个媒体查询，其中mediatype表示媒体查询的类型，这里引用一下菜鸟教程对该参数的解释 值 描述 all 用于所有设备 aural 已废弃。用于语音和声音合成器 braille 已废弃。 应用于盲文触摸式反馈设备 embossed 已废弃。 用于打印的盲人印刷设备 handheld 已废弃。 用于掌上设备或更小的装置，如PDA和小型电话 print 用于打印机和打印预览 projection 已废弃。 用于投影设备 screen 用于电脑屏幕，平板电脑，智能手机等。 speech 应用于屏幕阅读器等发声设备 tty 已废弃。 用于固定的字符网格，如电报、终端设备和对字符有限制的便携设备 tv 已废弃。 用于电视和网络电视 注意对screen即屏幕的查询是我们的重点后面的and|not|only表示查询的条件，一般常用and，注意and后面有一个空格，后面在括号内写入媒体查询起作用时满足的条件，如果想有多个条件(css样式)，可以写成下面这个样子 @media mediatype and (condition1) and (condition2) ... { CSS-Code; } 在大括号内可以写入css代码，以实现媒体查询。在bootstrap官方文档中，将目前市面上主流的屏幕宽度分为四类，分界线为1200px，992px，768px，即1200px以上是大屏，也就是我们电脑或者显示器的屏幕，992px~1200px为中屏，一般是桌面显示器，768px~992px是小屏幕，一般是平板等，再往下小于768px的就是移动端也就是我们的手机了，所以，针对这四种设备写出来的媒体查询是这样子的 /*大屏设备 1200px以上*/ /*满足条件的时候会生效*/ @media screen and (min-width: 1200px){ } /*中屏设备 992px - 1200px*/ @media screen and (min-width: 992px) and (max-width: 1200px){ } /*小屏设备 768px - 992px*/ @media screen and (min-width: 768px) and (max-width: 992px){ } /*超小屏设备 768px以下*/ @media screen and (max-width: 768px){ } /*媒体查询*/ /* 关键字 查询的是screen屏幕 条件以and连接 and后面必须有空格 &quot;()&quot;里面放条件(css样式) @media screen and (min-width: 1200px){ 写css样式 } */ 以上就是媒体查询的基本内容了，下面给出一个实例代码，可以复制下来自己运行观察在不同的屏幕宽度下显示的效果(代码里meta标签里面对viewport的声明会在移动端专题里面讲到)示例代码： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;媒体查询&lt;/title&gt; &lt;style&gt; body{ margin: 0; padding: 0; } .container{ width: 1200px; height: 1200px; margin: 0 auto; background-color:black; } span.container1{ font-size: 50px; font-weight: bold; color: red; display: block; top: 50%; /*一种水平居中和垂直居中的方法*/ position: absolute; right: 50%; transform: translate(50%,50%); /*另一种水平居中的方法 display:block; margin: 0 auto; /**!*/ } /*大屏设备 1200px以上*/ /*满足条件的时候会生效*/ @media screen and (min-width: 1200px){ .container{ width: 1170px; background-color: yellow; } span.container1{ color: green; } } /*中屏设备 992px - 1200px*/ @media screen and (min-width: 992px) and (max-width: 1200px){ .container{ width: 970px; background-color: green; } span.container1{ color: black; } } /*小屏设备 768px - 992px*/ @media screen and (min-width: 768px) and (max-width: 992px){ .container{ width: 750px; background-color: blue; } span.container1{ color: maroon; } } /*超小屏设备 768px以下*/ @media screen and (max-width: 768px){ .container{ background-color: purple; width: 100%; } span.container1{ color: white; } } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;container&quot;&gt;&lt;/div&gt; &lt;span class=&quot;container1&quot;&gt;媒体查询&lt;/span&gt; &lt;/body&gt; &lt;/html&gt; 看完这段代码大家会不会有一个问题：如果每一种设备都需要写一次代码的话那四种设备不是要写四份代码吗？这样如何能体现减少了代码量的地方呢？这个问题，即将在下面的bootstrap使用中得到解决，接着学习第3节吧~ 3.bootstrap的下载与使用前言好了，到这里大家已经知道了什么是响应式布局以及如何利用媒体查询来实现响应式布局了，那么，上面我们也提出过问题：每一种设备（终端）都写一份代码并没有体现出代码量优化的特点。那么从这节开始我会写如何利用bootstrap来完成响应式布局，大大降低你的工作量。本节内容：bootstrap的下载与使用在官网给出的文档中我们可以看到，其给我们提供了三种下载方式，如下：我们需要的就是第一种也就是用于生产环境的bootstrap，点击下载bootstrap，解压，即可得到bootstrap的css，js和fonts字体文件。接下来就是使用bootstrap了 4.bootstrap基本模板想要bootstrap能正常运行，必须需要一个bootstrap的基本模板，说白了就是一个html文件，需要在其中引入特定的内容，否则bootstrap使用的时候不会有任何效果，下面是官方文档给出的bootstrap基本模板 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt; &lt;title&gt;Bootstrap 101 Template&lt;/title&gt; &lt;!-- Bootstrap --&gt; &lt;link href=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;!-- HTML5 shim 和 Respond.js 是为了让 IE8 支持 HTML5 元素和媒体查询（media queries）功能 --&gt; &lt;!-- 警告：通过 file:// 协议（就是直接将 html 页面拖拽到浏览器中）访问页面时 Respond.js 不起作用 --&gt; &lt;!--[if lt IE 9]&gt; &lt;script src=&quot;https://cdn.bootcss.com/html5shiv/3.7.3/html5shiv.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/respond.js/1.4.2/respond.min.js&quot;&gt;&lt;/script&gt; &lt;![endif]--&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;你好，世界！&lt;/h1&gt; &lt;!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) --&gt; &lt;script src=&quot;https://cdn.bootcss.com/jquery/1.12.4/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 --&gt; &lt;script src=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 下面对这段代码进行一下分析和解释 &lt;!--html5文档申明--&gt; &lt;!DOCTYPE html&gt; &lt;!--使用中文简体语言声明--&gt; &lt;html lang=&quot;zh-CN&quot;&gt; &lt;!--台湾--&gt; &lt;!--&lt;html lang=&quot;zh-tw&quot;&gt;--&gt; &lt;head&gt; &lt;!--当前文档的编码声明--&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;!--指明当前IE浏览器按最新的渲染引擎edge来渲染页面--&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;!--视口：视口的宽度和设备一致，默认缩放比是1.0，不允许用户自行缩放--&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, user-scalable = 0&quot;&gt; &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt; &lt;!--页面自上向下解析 优先告诉浏览器用最新的引擎来渲染，并且告诉浏览器这是一个移动端页面--&gt; &lt;title&gt;03 bootstrap基本模板&lt;/title&gt; &lt;!-- Bootstrap --&gt; &lt;!--引入bootstrap的核心样式库--&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../lib/bootstrap-3.3.7-dist/css/bootstrap.min.css&quot;&gt; &lt;!-- HTML5 shiv 和 Respond.js 是为了让 IE8 支持 HTML5 元素和媒体查询（media Queries）功能 --&gt; &lt;!--HTML5 shiv 解决标签兼容问题--&gt; &lt;!--Respond.js 解决媒体查询兼容问题--&gt; &lt;!-- 警告：通过 file:// 协议（就是直接将 html 页面拖拽到浏览器中）访问页面时 Respond.js 不起作用 --&gt; &lt;!--条件注释 IE9以下生效--&gt; &lt;!--[if lt IE 9]&gt; &lt;script src=&quot;../lib/html5shiv-master/dist/html5shiv.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../lib/Respond-master/dest/respond.min.js&quot;&gt;&lt;/script&gt; &lt;![endif]--&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;你好，世界！&lt;/h1&gt; &lt;!--bootstrap是基于jQuery进行开发的--&gt; &lt;!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) --&gt; &lt;script src=&quot;../lib/jQuery library/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; &lt;!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 --&gt; &lt;script src=&quot;../lib/bootstrap-3.3.7-dist/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 5.bootstrap中container类–第1个类在完成bootstrap的模板以后，我们就可以开始利用bootstrap来进行响应式网页的开发了，首先，我们来介绍bootstrap中的一个类–container，也是我们学习bootstrap的第一个类。首先来看一下container类的源代码 .container { padding-right: 15px; padding-left: 15px; margin-right: auto; margin-left: auto; } @media (min-width: 768px) { .container { width: 750px; } } @media (min-width: 992px) { .container { width: 970px; } } @media (min-width: 1200px) { .container { width: 1170px; } } 可以看出，通过媒体查询，以1200px，992px，768px三个分界点使container类在不同屏幕宽度的终端上面分为三种不同的宽度，而container类设置的margin: 0 auto;(等价于margin-right: auto;margin-left: auto;)意味着包含在container类里面的内容可以水平居中显示。注意container类还有左右内边距各15px宽度，这也意味着如果我们不消除内边距，container类里面的内容是不会充满整个屏幕的，下面我们通过媒体查询来使container类里面的内容在不同屏宽下面展示出不同的效果，代码如下： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, user-scalable = 0&quot;&gt; &lt;title&gt;03 bootstrap基本模板&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../lib/bootstrap-3.3.7-dist/css/bootstrap.min.css&quot;&gt; &lt;!--[if lt IE 9]&gt; &lt;script src=&quot;../lib/html5shiv-master/dist/html5shiv.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../lib/Respond-master/dest/respond.min.js&quot;&gt;&lt;/script&gt; &lt;![endif]--&gt; &lt;style&gt; .container{ height: 480px; } /*移动端设备 768px以下 */ @media (max-width: 767px) { .container { width: 480px; background-color: red; } } /*小屏（平板）设备 768px -- 991px */ @media (min-width: 768px) { .container { width: 750px; background-color: yellow; } } /*中屏设备（桌面显示器） 992px -- 1199px*/ @media (min-width: 992px) { .container { width: 970px; background-color: #2b542c; } } /*大屏设备（显示器） 1200px以上*/ @media (min-width: 1200px) { .container { width: 1170px; background-color: purple; } } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!--响应式容器--&gt; &lt;div class=&quot;container&quot;&gt; &lt;/div&gt; &lt;script src=&quot;../lib/jQuery library/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../lib/bootstrap-3.3.7-dist/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 注意默认情况下container类是没有高度的，所以必须为其设置高度或者利用子元素将其高度撑开才能使其可见下面是在不同屏幕宽度下显示的效果首先是大屏设备下(1200px以上)，背景颜色为紫色中屏设备的显示效果（992px~1200px）：小屏设备显示的效果（768px~992px）：然后是移动端设备（超小屏）的显示效果:最后我们再来看一下container类自带的左右15px的内边距 6.bootstrap中container-fluid类–第2个类fluid意思是液体的，流动的，那么在bootstrap里面。如果说container是一个响应式容器的话，那么container-fluid是一个流式容器(ps:流式布局也是移动端常用的一种适配方式，这里不做解释)。它与container类的直观区别可以从下图看出：可以看出container容器是居中显示的，而container-fluid容器是布满了屏幕的宽度，我们再来看container-fluid的代码： .container-fluid { padding-right: 15px; padding-left: 15px; margin-right: auto; margin-left: auto; } 当然这一点也可以从图上直观的看出总结一下，container类和container-fluid类是利用bootstrap时候必须为页面内容和栅格系统包裹的两个容器，其中，因为container类在不同的屏宽下设置了不同的宽度，所以container类用于固定宽度并支持响应式布局的容器。而container-fluid类因为没有设置宽度，但默认为100%，所以说其用于100% 宽度，占据全部视口（viewport）的流式容器。 7.bootstrap的栅格系统前言从这节开始进入到bootstrap的学习当中比较重要的一个环节，毕竟bootstrap的一个亮点就在于它的栅格系统布局方式非常灵活。学会使用bootstrap的栅格系统以后，利用其便能快速的达到一些常见的布局。 正文bootstrap的栅格系统本质上是通过浮动(float属性)与宽度百分比来实现的，同时也能通过调用不同的类来针对不同的屏幕尺寸达到适配，前面也提到过，bootstrap将屏幕尺寸分为四类，分别是超小屏幕&lt;768px，小屏幕 平板&gt;=768px，中等屏幕 桌面显示器&gt;=992px以及大屏幕 大桌面显示器&gt;=1200px(当然如果你对媒体查询以及min-width,max-width等属性非常熟悉的话，也可以定制自己的响应式网站，bootstrap在这方面也能让你自定义 Bootstrap 组件、Less 变量和 jQuery 插件，从而定制一份属于自己的bootstrap版本)，在bootstrap里面，大屏设备简写为lg，中屏设备为md，小屏设备为sm，超小屏设备也就是移动端设备为xs。我们首先来介绍一个类–.row，row是行的意思，先来看一下它的源代码： .row { margin-right: -15px; margin-left: -15px; } 非常简单的两行代码，左右两边各有-15px的外边距。.row类，也就是栅格系统里的“行”必须要包含在.container类或者.container-fluid类里面，它的作用有两个：(1)消除.container类或者.container-fluid类的内边距(2)实现栅格系统布局的基础（有了行才能有列）解释一下(1)：.row类左右各有15px的负边距，所以当将其包含在.container类或者.container-fluid类中的时候，可以去掉.container类或者.container-fluid类的15px的内边距。请看下面实例 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, user-scalable = 0&quot;&gt; &lt;title&gt;03 bootstrap基本模板&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../lib/bootstrap-3.3.7-dist/css/bootstrap.min.css&quot;&gt; &lt;!--[if lt IE 9]&gt; &lt;script src=&quot;../lib/html5shiv-master/dist/html5shiv.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../lib/Respond-master/dest/respond.min.js&quot;&gt;&lt;/script&gt; &lt;![endif]--&gt; &lt;style&gt; .container{ width: 100%; } .container &gt; .row{ height: 200px; background-color: purple; } .container &gt; .div{ height: 200px; background-color: yellow; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;div&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;../lib/jQuery library/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../lib/bootstrap-3.3.7-dist/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 效果：在栅格系统中，所有的内容都放在列(column)中，注意，只有列(column)可以作为行(row)的直接子元素下面我们来介绍栅格系统中列的使用，即.col-xx-xx类(“xx”表示参数)bootstrap.col-xx-xx类：第一个参数（第一个“xx”） 取值 含义 作用范围 lg 大屏(1200px+) 大屏生效 md 中屏(992px~1200px) 中屏及以上生效 sm 小屏(768px~992px) 小屏及以上生效 xs 超小屏(768px以下) 超小屏及以上生效 第二个参数（第二个“xx”）bootstrap默认会把一行分成12等份，也就是一行最多有12列，第二个参数表示的是当前的元素占12等份当中的几份，比如说col-md-4中4就表示在中屏以上的屏宽的时候占12份中的4份，也就是三分之一的宽度范围：1-12下面是代码示例： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, user-scalable = 0&quot;&gt; &lt;title&gt;03 bootstrap基本模板&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../lib/bootstrap-3.3.7-dist/css/bootstrap.min.css&quot;&gt; &lt;!--[if lt IE 9]&gt; &lt;script src=&quot;../lib/html5shiv-master/dist/html5shiv.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../lib/Respond-master/dest/respond.min.js&quot;&gt;&lt;/script&gt; &lt;![endif]--&gt; &lt;style&gt; body{ background-color: #bce8f1; } .container &gt; .row{ height: 80px; background-color: yellow; } .first-row &gt; div{ margin-top: 15px; height: 50px; border: 1px solid #ffffff; background-color: black; box-sizing: border-box; line-height: 50px; text-align: center; font-size: 1.5vw; color: white; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;first-row&quot;&gt; &lt;div class=&quot;col-lg-2&quot;&gt;2份&lt;/div&gt; &lt;div class=&quot;col-lg-6&quot;&gt;6份&lt;/div&gt; &lt;div class=&quot;col-lg-1&quot;&gt;1份&lt;/div&gt; &lt;div class=&quot;col-lg-3&quot;&gt;3份&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;second-row&quot;&gt;&lt;/div&gt; &lt;div class=&quot;third-row&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;../lib/jQuery library/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../lib/bootstrap-3.3.7-dist/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 效果如下：可以很清楚的看到一行被分成为12份。且2+6+1+3 == 12，当然，如果和大于12，那么多余的列便会被挤下来，到下面一行 &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;first-row&quot;&gt; &lt;div class=&quot;col-lg-2&quot;&gt;2份&lt;/div&gt; &lt;div class=&quot;col-lg-6&quot;&gt;6份&lt;/div&gt; &lt;div class=&quot;col-lg-1&quot;&gt;1份&lt;/div&gt; &lt;div class=&quot;col-lg-4&quot;&gt;4份&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;second-row&quot;&gt;&lt;/div&gt; &lt;div class=&quot;third-row&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 上面只是在调用了.col-lg-xx相关类，也就是说上面的示例代码只能在大屏下才有效果，放到其余三类尺寸的屏幕下只会默认占满整行，就像下面这样当我们进行完上面的简单的使用栅格系统布局之后，bootstrap还为我们提供了其他的辅助布局的类操作，具体见下表(引自bootstrap官方文档)：槽宽(gutter)即为列与列之间的间隔，通过为列设置padding属性来实现。从表中我们看到，bootstrap还为我们提供了几种实现更为复杂的布局的方式：(1)列嵌套(2)列偏移(offsets)(3)列排序下面来逐条介绍:(1)列嵌套顾名思义，列嵌套就是列与列之间的嵌套，也就是我们可以在一列中再放置12份内容，具体做法：可以通过添加一个新的.row元素和一系列.col-xx-xx元素到已经存在的.col-xx-xx元素内。我们拿实例来说话，代码如下： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, user-scalable = 0&quot;&gt; &lt;title&gt;03 bootstrap基本模板&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../lib/bootstrap-3.3.7-dist/css/bootstrap.min.css&quot;&gt; &lt;!--[if lt IE 9]&gt; &lt;script src=&quot;../lib/html5shiv-master/dist/html5shiv.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../lib/Respond-master/dest/respond.min.js&quot;&gt;&lt;/script&gt; &lt;![endif]--&gt; &lt;style&gt; body{ background-color: #bce8f1; } .container &gt; .row{ height: 80px; background-color: yellow; } .first-row &gt; div{ margin-top: 15px; height: 50px; border: 1px solid #ffffff; background-color: black; box-sizing: border-box; line-height: 50px; text-align: center; font-size: 1.5vw; color: white; } .first-row &gt; div .row{ height: 30px; margin-top: 10px; font-size: 1vw; font-weight: 900; } .first-row &gt; div .row div{ border: 1px solid #ffffff; background-color: purple; box-sizing: border-box; line-height: 30px; text-align: center; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;first-row&quot;&gt; &lt;div class=&quot;col-lg-2&quot;&gt;2份&lt;/div&gt; &lt;div class=&quot;col-lg-6&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-lg-7&quot;&gt;嵌套7份&lt;/div&gt; &lt;div class=&quot;col-lg-2&quot;&gt;嵌套2份&lt;/div&gt; &lt;div class=&quot;col-lg-3&quot;&gt;嵌套3份&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col-lg-1&quot;&gt;1份&lt;/div&gt; &lt;div class=&quot;col-lg-3&quot;&gt;3份&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;second-row&quot;&gt;&lt;/div&gt; &lt;div class=&quot;third-row&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;../lib/jQuery library/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../lib/bootstrap-3.3.7-dist/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 实现的效果如下：同样，我们还可以再在里面嵌套列，但是要注意一点：列必须基于行，所以必须将列元素作为.row类直接子元素才会有作用(2)列偏移(offsets)列偏移的意思是，我们可以通过对特定的类的调用，来达到对某一列在其原来位置的基础上向右偏移特定的距离(注意这里距离只能为整数，范围为1~12)，下面请看例子 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, user-scalable = 0&quot;&gt; &lt;title&gt;03 bootstrap基本模板&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../lib/bootstrap-3.3.7-dist/css/bootstrap.min.css&quot;&gt; &lt;!--[if lt IE 9]&gt; &lt;script src=&quot;../lib/html5shiv-master/dist/html5shiv.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../lib/Respond-master/dest/respond.min.js&quot;&gt;&lt;/script&gt; &lt;![endif]--&gt; &lt;style&gt; body{ background-color: #bce8f1; } .container &gt; .row{ background-color: yellow; } .first-row &gt; div{ margin-top: 15px; height: 50px; border: 1px solid #ffffff; background-color: black; box-sizing: border-box; line-height: 50px; text-align: center; font-size: 1.5vw; color: white; } .first-row &gt; div .row{ height: 30px; margin-top: 10px; font-size: 1vw; font-weight: 900; } .first-row &gt; div .row div{ border: 1px solid #ffffff; background-color: purple; box-sizing: border-box; line-height: 30px; text-align: center; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;first-row&quot; style=&quot;overflow: hidden&quot;&gt; &lt;div class=&quot;col-lg-2&quot;&gt;2份&lt;/div&gt; &lt;div class=&quot;col-lg-6&quot;&gt;6份&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;first-row&quot;&gt; &lt;div class=&quot;col-lg-2&quot;&gt;2份&lt;/div&gt; &lt;div class=&quot;col-lg-6 col-lg-offset-4&quot; id=&quot;lg-offset-6&quot;&gt;6份&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;../lib/jQuery library/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../lib/bootstrap-3.3.7-dist/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 效果如下图：我们从代码里可以看出，.row类下面的两个div的样式几乎一样，所不同的是，第二个div中填加了.col-lg-offset-4类，致使第二个div下面id=”lg-offset-6”的块元素向右平移了4份的距离，直接与右边对齐。本质上，.col-xx-offset-4(“xx”表示屏幕尺寸)是添加了左边距才使得元素能向右偏移，我们从bootstrap的代码中能很清晰的看出这一点 .col-xs-offset-12 { margin-left: 100%; } .col-xs-offset-11 { margin-left: 91.66666667%; } .col-xs-offset-10 { margin-left: 83.33333333%; } .col-xs-offset-9 { margin-left: 75%; } 上面的例子只是给出了在大屏也就是lg的情况下的偏移，其余情况可以自己将代码复制下去进行改动验证。(3)列排序在默认的情况下，列的排序会按照我们代码规定的顺序，写在前面的排在前面，写在后面的排在后面，这里用到上面的例子 &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;first-row&quot;&gt; &lt;div class=&quot;col-lg-2&quot;&gt;2份&lt;/div&gt; &lt;div class=&quot;col-lg-6&quot;&gt;6份&lt;/div&gt; &lt;div class=&quot;col-lg-1&quot;&gt;1份&lt;/div&gt; &lt;div class=&quot;col-lg-4&quot;&gt;4份&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;second-row&quot;&gt;&lt;/div&gt; &lt;div class=&quot;third-row&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 如图和代码所示，列从左到有的顺序默认按照2，6，1，4，这样进行排序，而bootstrap给我们提供了相关类可以改变列与列之间默认的排序方式，即.col-xx-xx-xx类。.col-xx-xx-xx类，第一个参数表示屏幕尺寸，老规矩，有lg，md，sm，xs四种取值，第二个参数代表方向，有push与pull两个取值，其中push(推)，方向向右，pull(拉)，方向为左，第三个参数表示向左拉或者向右推的列数，取值为1~12，下面来举例描述首先代码如下: &lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, user-scalable = 0&quot;&gt; &lt;title&gt;05 栅格系统&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../lib/bootstrap-3.3.7-dist/css/bootstrap.css&quot;&gt; &lt;!--[if lt IE 9]&gt; &lt;script src=&quot;../lib/html5shiv-master/dist/html5shiv.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../lib/Respond-master/dest/respond.min.js&quot;&gt;&lt;/script&gt; &lt;![endif]--&gt; &lt;style&gt; body,h1,h2,h3,h4,h5,h6,p,span{ margin: 0; padding: 0; } .container{ height: 360px; background-color: #bce8f1; } /*只选择某个元素的子元素用 &quot;&gt;&quot; */ .container &gt; .row{ height: 100px; background-color: yellow; } .container &gt; .row &gt; div{ font-size: 1.5vw; color: white; text-align: center; line-height: 50px; height: 50px; border: 1px solid #cccccc; background-color: green; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!--响应式容器--&gt; &lt;div class=&quot;container&quot;&gt; &lt;!--栅格系统--&gt; &lt;div class=&quot;row&quot;&gt; &lt;!--列--&gt; &lt;!--排序前--&gt; &lt;div class=&quot;col-xs-3&quot;&gt;3&lt;/div&gt; &lt;div class=&quot;col-xs-4&quot;&gt;4&lt;/div&gt; &lt;div class=&quot;col-xs-5&quot;&gt;5&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;!--列--&gt; &lt;!--列排序--&gt; &lt;div class=&quot;col-xs-3 col-xs-push-5&quot;&gt;3&lt;/div&gt; &lt;div class=&quot;col-xs-4 col-xs-push-5&quot;&gt;4&lt;/div&gt; &lt;div class=&quot;col-xs-5 col-xs-pull-7&quot;&gt;5&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;../lib/jQuery library/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../lib/bootstrap-3.3.7-dist/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 第一个含有.row类的div没有调用其他类，所以展现出来的效果就是默认的排序3,4,5，而第二个含有.row类的div通过调用.col-xx-push-xx类与.col-xx-pull-xx类实现了5,3,4的排序效果，我们可以来看一下这类类的代码，以更好了解他们的作用 .col-sm-pull-1 { right: 8.33333333%; } .col-sm-pull-0 { right: auto; } .col-sm-push-12 { left: 100%; } 可以看出，实现列排序的本质也是通过对左右边距的距离进行定位，从而达到列向左或者向右平移指定距离的效果，在上面的例子中，3份的div向右平移5个单位，4份的div向右平移4个单位，5份的div向左平移了7个单位，且因为使用了xs，所以在超小屏及以上屏幕尺寸均可以适配这种做法。 8.bootstrap响应式工具(响应式工具类)前言利用bootstrap进行响应式开发是非常方便的，只需要用.container类作为第一级父容器，将其余的北荣均放在.container下面作为其子元素就能达到适配不同终端的要求，当然，想要达到在不同终端下面显示的效果不一样，上面写的内容还并不能做到如此多元化的效果，所以在这节我们将会介绍其他的bootstrap提供的响应式工具(类)，通过调用不同的类来达到在不同终端有不同效果的要求。 正文关于bootstrap响应式工具(类)，我主要记录了两种(1).visible-xx-xx类(2).hidden-xx类分别控制了在不同的屏幕尺寸下的显示和隐藏(1).visible-xx-xx类.visible-xx-xx类，第一个参数同样代表了屏幕的尺寸，有四种取值，lg，md，sm与xs，分别代表了在大屏可见，中等屏幕可见，小屏幕可见以及超小屏幕可见(注意此时每一种尺寸只代表了当前屏幕的尺寸，在其之上的尺寸范围并不适用，也就是说，.visible-xs-xx只代表了能在超小屏幕可见，而不是超小屏幕即以上均可见).visible-xx-xx类，第二个参数有三种取值，分别为block，inline，inline-block，与CSS中的display:block，display:inline，display:inline-block相对应，bootstrap中也给我们列出了.visible-xx-xx类的相关取值，如下图:至于单独的使用.visible-xs、.visible-sm、.visible-md、.visible-lg类也不是不可以，但是从v3.2.0版本开始不建议使用，控制元素的隐藏与显示更加常用.hidden-xx相关类。当然visiblex相关类的取值不止上面这些，有兴趣可以去读一读bootstrap的源码，里面有详细的代码说明。(2).hidden-xx类相对于.visible-xx-xx相关类，.hidden-xx相关类相对来说更加常用而且比较好理解，它一共只用四种取值，分别是.hidden-xs，.hidden-sm，.hidden-md，.hidden-lg，分别代表了在超小屏，小屏，中屏以及大屏隐藏，关于这个我们可以参考bootstrap给出的官方文档OK，介绍完了相关类的取值以及他们的含义，我们来看一下下面这个代码 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, user-scalable = 0&quot;&gt; &lt;title&gt;06 响应式工具&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../lib/bootstrap-3.3.7-dist/css/bootstrap.min.css&quot;&gt; &lt;!--[if lt IE 9]&gt; &lt;script src=&quot;../lib/html5shiv-master/dist/html5shiv.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../lib/Respond-master/dest/respond.min.js&quot;&gt;&lt;/script&gt; &lt;![endif]--&gt; &lt;style&gt; .container{ height: 240px; background-color: #00CCFF; font-size: 2vw; } header{ height: 80px; background-color: purple; text-align: center; color: #ffffff; line-height: 80px; } section{ height: 80px; background-color: yellow; text-align: center; color: #000000; line-height: 80px; } footer{ height: 80px; background-color: #2b542c; text-align: center; color: white; line-height: 80px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 需求： 1.在大屏设备 显示 头 内容 脚 2.在中屏设备 显示 内容 脚 3.在小屏设备 显示 内容 4,在超小屏设备 显示 nothing --&gt; &lt;!--使用 响应式工具类--&gt; &lt;div class=&quot;container&quot;&gt; &lt;!--头 只在大屏的时候显示，中屏，小屏，超小屏均隐藏--&gt; &lt;header class=&quot;hidden-md hidden-sm hidden-xs visible-lg&quot;&gt;头&lt;/header&gt; &lt;!--内容 在超小屏不显示，大屏中屏小屏显示--&gt; &lt;section class=&quot;hidden-xs&quot;&gt;内容&lt;/section&gt; &lt;!--脚 在小屏和超小屏不显示--&gt; &lt;footer class=&quot;hidden-sm hidden-xs&quot;&gt;脚&lt;/footer&gt; &lt;/div&gt; &lt;script src=&quot;../lib/jQuery library/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../lib/bootstrap-3.3.7-dist/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 对应不同屏幕尺寸显示的效果如图:大屏：中屏：小屏：超小屏：同时贴出相关.hidden-xx类代码以供理解 @media (max-width: 767px) { .hidden-xs { display: none !important; } } @media (min-width: 768px) and (max-width: 991px) { .hidden-sm { display: none !important; } } @media (min-width: 992px) and (max-width: 1199px) { .hidden-md { display: none !important; } } @media (min-width: 1200px) { .hidden-lg { display: none !important; } } 9.bootstrap导航条从这里开始，包括下面的内容，基本上就是介绍bootstrap的一些常用组件，首先来看bootstrap的导航条。从bootstrap中拿到它的导航条运用到我们自己设计的网页中，往往导航条的样式并不是bootstrap给出的默认的样式，所以我们需要去读懂导航条部分的代码以便我们能更准确的进行修改以达到我们期望的效果。使用bootstrap提供的导航栏的时候，可以直接使用HTML5nav标签，当然也可以使用div标签，bootstrap官方文档中提示我们使用div标签的时候，需要加上role=”navigation”属性，role属性的作用是为了能使盲人用户知道当前浏览的是什么界面，然而在国内由于这方面还未普及，所以我们也可以不需要role=”navigation”属性，直接使用div标签即可，但为了更加明确，建议使用nav标签。这里我们通过bootstrap给出的样例代码来进行一步步的解释 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-CN&quot;&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, user-scalable = 0&quot;&gt; &lt;title&gt;08 bootstrap导航条&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../lib/bootstrap-3.3.7-dist/css/bootstrap.css&quot;&gt; &lt;!--[if lt IE 9]&gt; &lt;script src=&quot;../lib/html5shiv-master/dist/html5shiv.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../lib/Respond-master/dest/respond.min.js&quot;&gt;&lt;/script&gt; &lt;![endif]--&gt; &lt;/head&gt; &lt;body&gt; &lt;!--导航条 默认样式的导航条 navbar-default --&gt; &lt;nav class=&quot;navbar navbar-default&quot;&gt; &lt;!--响应式容器--&gt; &lt;div class=&quot;container&quot;&gt; &lt;!--商标logo 与 切换按钮 只会在移动端显示(媒体查询) --&gt; &lt;!-- Brand and toggle get grouped for better mobile display --&gt; &lt;div class=&quot;navbar-header&quot;&gt; &lt;!--切换按钮--&gt; &lt;!-- data-toggle=&quot;collapse&quot; 声明折叠组件 data-target=&quot;#bs-example-navbar-collapse-1&quot; 控制id=&quot;bs-example-navbar-collapse-&quot;的元素 屏幕阅读器 辅助性的阅读设备（例如盲人用户） aria-expanded=&quot;false&quot; aria- 都是给屏幕阅读器使用的 &lt;span class=&quot;sr-only&quot;&gt;Toggle navigation&lt;/span&gt; 也和屏幕阅读器有关系 sr-only &lt;==&gt; screen read only 服务盲人用户阅读 role 同样是给屏幕阅读器使用的 用来表明当前元素的功能，作用是什么 --&gt; &lt;button type=&quot;button&quot; class=&quot;navbar-toggle collapsed&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#bs-example-navbar-collapse-1&quot; aria-expanded=&quot;false&quot;&gt; &lt;span class=&quot;sr-only&quot;&gt;Toggle navigation&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;/button&gt; &lt;!--商标logo区域--&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;Brand&lt;/a&gt; &lt;/div&gt; &lt;!-- 切换按钮控制要切换的内容 --&gt; &lt;!-- Collect the nav links, forms, and other content for toggling --&gt; &lt;div class=&quot;collapse navbar-collapse&quot; id=&quot;bs-example-navbar-collapse-1&quot;&gt; &lt;ul class=&quot;nav navbar-nav&quot;&gt; &lt;!--active 当前选中--&gt; &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;Link &lt;span class=&quot;sr-only&quot;&gt;(current)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;!--下拉菜单--&gt; &lt;li class=&quot;dropdown&quot;&gt; &lt;!--data-toggle=&quot;dropdown声明了一个下拉组件 a下面的ul就是被控制的元素（控制其显示与隐藏）--&gt; &lt;a href=&quot;#&quot; class=&quot;dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; role=&quot;button&quot; aria-haspopup=&quot;true&quot; aria-expanded=&quot;false&quot;&gt;Dropdown &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt;&lt;/a&gt; &lt;ul class=&quot;dropdown-menu&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Another action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Something else here&lt;/a&gt;&lt;/li&gt; &lt;li role=&quot;separator&quot; class=&quot;divider&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Separated link&lt;/a&gt;&lt;/li&gt; &lt;li role=&quot;separator&quot; class=&quot;divider&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;One more separated link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;form class=&quot;navbar-form navbar-left&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;Search&quot;&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;Submit&lt;/button&gt; &lt;/form&gt; &lt;ul class=&quot;nav navbar-nav navbar-right&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;dropdown&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; role=&quot;button&quot; aria-haspopup=&quot;true&quot; aria-expanded=&quot;false&quot;&gt;Dropdown &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt;&lt;/a&gt; &lt;ul class=&quot;dropdown-menu&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Another action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Something else here&lt;/a&gt;&lt;/li&gt; &lt;li role=&quot;separator&quot; class=&quot;divider&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Separated link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;!-- /.navbar-collapse --&gt; &lt;/div&gt;&lt;!-- /.container-fluid --&gt; &lt;/nav&gt; &lt;script src=&quot;../lib/jQuery library/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../lib/bootstrap-3.3.7-dist/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 导航条的样子是这样的首先，nav标签作为最上一级父容器，内包含.navbar，.navbar-default两个类，下面是这两个类的代码: .navbar { position: relative; min-height: 50px; margin-bottom: 20px; border: 1px solid transparent; } .navbar-default { background-color: #f8f8f8; border-color: #e7e7e7; } 可以看出只是很简单的设置了位置属性，高度，背景颜色等，其中.navbar-default表示默认样式的导航条。上面我们说过，实现响应式必有要有.container类，所以在nav下面的div调用了.container类让我们知道这是一个响应式的导航条，但是响应式的具体效果在哪，我们还要往下看。.container类下面包含两个子容器div，第一个div生声明了导航栏左边的Brand以及一个响应式的声明，我们改变窗口宽度，会发现缩小到超小屏幕范围后，导航条会消失不见，取而代之的是左上角的menu按钮，点开来看，我们会发现这个正是隐藏的导航条，为什么这样？我们看到第一个div里有navbar-header这个类，我们查看bootstrap关于此类的源代码: @media (min-width: 768px) { .navbar-header { float: left; } } 可以看出，对小屏及以上的设备，会给当行调添加float:left的效果，也就是说会完整的显示出来。那对于小屏以下的设备也就是移动端设备就会隐藏，取而代之的是那个菜单栏的按钮。下面的button里面有两个属性需要我们注意一下，即data-toggle与data-target属性。data-toggle=”collapse”声明了这是一个”collapse”即折叠组件（折叠组件下面会有）data-target=”#bs-example-navbar-collapse-1”则是指明了该折叠组件控制的元素，我们往下看，会在第二个div里面看到id=”bs-example-navbar-collapse-1，也就是说，上面的button是来控制我们下面这个第二个div的。有的小伙伴可能注意到，在我们第一个div下面有这么一句话 &lt;span class=&quot;sr-only&quot;&gt;Toggle navigation&lt;/span&gt; 但是在浏览器里面却找不到这句话在哪里。不用担心，这个.sr-only类是为了给盲人阅读该网页提供的，我们不需要去关注这个，类似这个的还有以.aria-xxx开头以及声明了role属性的均属于这种情况，我们不需要去关注，遇到的话可以直接删除以稍微的减少一下代码量（在代码注释中已经有详细的解释）。后面button区域里面定义了屏幕阅读器（没有什么作用）和移动端导航栏隐藏后显示的切换按钮 &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; 可以看出按钮是由三个span画出来的，bootstrap.css里面对.icon-bar的样式定义如下(注意display:block)： .navbar-toggle .icon-bar { display: block; width: 22px; height: 2px; border-radius: 1px; } 下面的代码与上面的较为类似就不再详述，可以自行去读一读代码并自己去理解。到这里戒指bootstrap的组件就先告一段落，因为bootstrap组件太多，所以只能选择一两个进行详细的解释，其余的我会后期慢慢补充，或者有兴趣的可以自己去bootstrap官网去看文档。 10.bootstrap的collapse(折叠)组件下面我们来介绍bootstrap的一些JavaScript组件，首先是collapse（折叠）组件。collapse插件作用：类似下拉菜单，点击显示，失焦的时候隐藏，可以节省空间的同时起到一定的美观效果下面可以看几个类似的效果：(更多的实例请到bootstrap官方文档中去寻找或者在自己浏览网页的过程中可以注意观察一下)实例代码如下： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, user-scalable = 0&quot;&gt; &lt;title&gt;09 bootstrap中的collapse插件&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../lib/bootstrap-3.3.7-dist/css/bootstrap.min.css&quot;&gt; &lt;!--[if lt IE 9]&gt; &lt;script src=&quot;../lib/html5shiv-master/dist/html5shiv.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../lib/Respond-master/dest/respond.min.js&quot;&gt;&lt;/script&gt; &lt;![endif]--&gt; &lt;/head&gt; &lt;body&gt; &lt;!--需求： 一个按钮（或者说某一个元素）能控制某一块区域的显示和隐藏--&gt; &lt;!-- data-toggle=&quot;collapse（组件）&quot; 声明折叠组件 data-target=&quot;选择器&quot; 设置需要控制的目标元素 通过选择器 对于a标签来说，需要控制的目标元素可以直接写在href属性中 即href=&quot;选择器&quot; --&gt; &lt;button data-toggle=&quot;collapse&quot; data-target=&quot;#target&quot;&gt;按钮&lt;/button&gt; &lt;a href=&quot;#target&quot; data-toggle=&quot;collapse&quot;&gt;链接&lt;/a&gt; &lt;div class=&quot;btn btn-info&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#target&quot;&gt;div按钮&lt;/div&gt; &lt;!--需要控制的区域--&gt; &lt;div id=&quot;target&quot; class=&quot;target&quot;&gt; &lt;p&gt;内容&lt;/p&gt; &lt;p&gt;内容&lt;/p&gt; &lt;p&gt;内容&lt;/p&gt; &lt;p&gt;内容&lt;/p&gt; &lt;p&gt;内容&lt;/p&gt; &lt;p&gt;内容&lt;/p&gt; &lt;p&gt;内容&lt;/p&gt; &lt;p&gt;内容&lt;/p&gt; &lt;p&gt;内容&lt;/p&gt; &lt;p&gt;内容&lt;/p&gt; &lt;p&gt;内容&lt;/p&gt; &lt;p&gt;内容&lt;/p&gt; &lt;p&gt;内容&lt;/p&gt; &lt;p&gt;内容&lt;/p&gt; &lt;p&gt;内容&lt;/p&gt; &lt;p&gt;内容&lt;/p&gt; &lt;p&gt;内容&lt;/p&gt; &lt;p&gt;内容&lt;/p&gt; &lt;/div&gt; &lt;script src=&quot;../lib/jQuery library/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../lib/bootstrap-3.3.7-dist/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 首先我们定义了三个模块，分别是一个button，一个链接a和一个div，三块控制区域都声明了collapse组件即代码中的data-toggle=”collapse”，随后data-target=”#target”声明了需要去控制的内容也就是下面id=”target”的div，其中，a标签通过href=”#target”同样可以实现对目标元素的控制，也就是说有两种方法可以实现拥有对目标div显示与隐藏的控制权，即data-target=””与a标签中的href属性。下面的div即使我们要去控制的元素，也就是说上面三块都可以控制该div的显示与隐藏。总结一下：简单的利用一个折叠组件仅需要以下几个步骤：(1)声明一个折叠组件——data-toggle=”collapse”(2)声明要控制的目标元素——data-target=””或者href=””（代码可以自行复制并运行查看效果，注意需要更改bootstrap相关文件的路径） 11.bootstrap轮播图(Carousel)轮播图是在PC端和移动端都很常见的一个效果，bootstrap为我们提供了一个简单易使用的(Carousel)轮播插件，这样我们就不需要去费力的写原生的轮播图代码了，但是我们还是需要去大概的了解一下bootstrap给出的轮播图代码结构，这样也方便我们以后自己进行去编写。下面是官方文档给出的bootstrap轮播图插件样例 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, user-scalable = 0&quot;&gt; &lt;title&gt;10 bootstrap中的轮播图 carousel&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../lib/bootstrap-3.3.7-dist/css/bootstrap.css&quot;&gt; &lt;!--[if lt IE 9]&gt; &lt;script src=&quot;../lib/html5shiv-master/dist/html5shiv.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../lib/Respond-master/dest/respond.min.js&quot;&gt;&lt;/script&gt; &lt;![endif]--&gt; &lt;body&gt; &lt;!--carousel 这是轮播图模块--&gt; &lt;!--slide 是否有切换时的平移动画--&gt; &lt;!--data-ride=&quot;carousel&quot; 声明是一个轮播图组件--&gt; &lt;div id=&quot;carousel-example-generic&quot; class=&quot;carousel slide&quot; data-ride=&quot;carousel&quot;&gt; &lt;!--指示器 --- 点盒子--&gt; &lt;!-- Indicators --&gt; &lt;ol class=&quot;carousel-indicators&quot;&gt; &lt;!-- data-target=&quot;#carousel-example-generic&quot; 需要控制的id为carousel-example-generic的轮播图 data-slide-to=&quot;0&quot; 控制轮播图中索引为0的图片 active 当前对应索引的点（被选中的图片对应的点） --&gt; &lt;li data-target=&quot;#carousel-example-generic&quot; data-slide-to=&quot;0&quot; class=&quot;active&quot;&gt;&lt;/li&gt; &lt;li data-target=&quot;#carousel-example-generic&quot; data-slide-to=&quot;1&quot;&gt;&lt;/li&gt; &lt;li data-target=&quot;#carousel-example-generic&quot; data-slide-to=&quot;2&quot;&gt;&lt;/li&gt; &lt;li data-target=&quot;#carousel-example-generic&quot; data-slide-to=&quot;3&quot;&gt;&lt;/li&gt; &lt;/ol&gt; &lt;!--图片盒子 滑动容器--&gt; &lt;!-- Wrapper for slides --&gt; &lt;div class=&quot;carousel-inner&quot;&gt; &lt;!--图片 当前默认显示的图片--&gt; &lt;div class=&quot;item active&quot;&gt; &lt;img src=&quot;../images/轮播图3.jpg&quot;/&gt; &lt;!--图片中的文字说明部分--&gt; &lt;div class=&quot;carousel-caption&quot;&gt; ... &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;img src=&quot;../images/轮播图7.jpg&quot;/&gt; &lt;div class=&quot;carousel-caption&quot;&gt; ... &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;img src=&quot;../images/轮播图8.jpg&quot;/&gt; &lt;div class=&quot;carousel-caption&quot;&gt; ... &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;img src=&quot;../images/轮播图9.jpg&quot;/&gt; &lt;div class=&quot;carousel-caption&quot;&gt; ... &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--控制轮播图平移的方向键--&gt; &lt;!-- 左边的是上一张 data-slide=&quot;prev&quot; left 右边的是下一张 data-slide=&quot;next&quot; right --&gt; &lt;!-- Controls --&gt; &lt;a class=&quot;left carousel-control&quot; href=&quot;#carousel-example-generic&quot; data-slide=&quot;prev&quot;&gt; &lt;!--bootstrap向左边的图标--&gt; &lt;span class=&quot;glyphicon glyphicon-chevron-left&quot;&gt;&lt;/span&gt; &lt;/a&gt; &lt;a class=&quot;right carousel-control&quot; href=&quot;#carousel-example-generic&quot; data-slide=&quot;next&quot;&gt; &lt;!--bootstrap向右边的图标--&gt; &lt;span class=&quot;glyphicon glyphicon-chevron-right&quot;&gt;&lt;/span&gt; &lt;/a&gt; &lt;/div&gt; &lt;script src=&quot;../lib/jQuery library/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../lib/bootstrap-3.3.7-dist/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 首先最上级的div中的属性data-ride=”carousel”声明了这是一个轮播图组件。下面的ol声明了点盒子，ol下面的每个li里面都含有data-target=”#carousel-example-generic”表明点盒子是控制的id=”carousel-example-generic”的轮播图，data-slide-to=”1”是表明了当前点盒子控制的图片的索引，class=”active”表明当前显示的图片（当前对应索引的图片，此时索引是0）下面第一个含有class=”carousel-inner”的div定义了一个图片容器，其下面每一个含有.item类的div是每一张图片的容器，里面的img标签定义了图片元素，与它同级的div定义了对每一张图片的描述，具体如下： &lt;div class=&quot;item&quot;&gt; &lt;img src=&quot;...&quot; alt=&quot;...&quot;&gt; &lt;div class=&quot;carousel-caption&quot;&gt; &lt;h3&gt;...&lt;/h3&gt; &lt;p&gt;...&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; 在下面一共有4个div也就是一共有4张图片进行轮播，与这个div同级的两个a标签是定义了往左滑和往右滑的两个箭头，注意a标签里面的href=”#carousel-example-generic”同样声明了需要去控制的轮播图容器，然后data-slide属性规定了滑动的方向，有prev与next两个取值，分别代表了前一张与后一张。a标签里面的span里面的lyphicon-chevron-right和lyphicon-chevron-left是用了bootstrap自己规定的图标，类似于fontawesome。以上就是整个轮播图的结构。 12.bootstrap中的Affix(吸顶)组件 13.总结:bootstrap常用类]]></content>
      <tags>
        <tag>bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于删除节点幕后的事情]]></title>
    <url>%2F2018%2F08%2F29%2F%E5%85%B3%E4%BA%8E%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9%E5%B9%95%E5%90%8E%E7%9A%84%E4%BA%8B%E6%83%85%2F</url>
    <content type="text"><![CDATA[前言这篇文章原来是自己写的第一篇博文，因为格式太难看于是在这里进行了一次重新的修改与发布，至于内容，emmmmmm，有兴趣就看看当做了解就好 正文当时刚学到js，当看到删除节点这节的时候，自己写了一个程序来测试，点击清除节点按钮却发现了出人意料的结果，经过长时间的思考最终参透了其中的奥秘，于是发布上来，下面是代码: &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;content&quot;&gt; &lt;h1&gt;html&lt;/h1&gt; &lt;h1&gt;php&lt;/h1&gt; &lt;h1&gt;javascript&lt;/h1&gt; &lt;h1&gt;jquery&lt;/h1&gt; &lt;h1&gt;java&lt;/h1&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; document.write(content.childNodes.length); function clearText() { var content=document.getElementById(&quot;content&quot;); // 在此完成该函数 for(var i=0;i&lt;content.childNodes.length;i++){ var childNode = content.childNodes[i]; content.removeChild(childNode); } } &lt;/script&gt; &lt;button onclick=&quot;clearText()&quot;&gt;清除节点内容&lt;/button&gt; &lt;/body&gt; &lt;/html&gt; 运行这个程序会发现，第一次点击按钮的时候没有任何反应，第二次点击按钮的时候只剩下了php与jquery两个，再点击按钮php会被删除掉，再点击按钮才会把jQuery删除掉，这是为什么呢？经过仔细观察程序以及了解删除的原理后，得到以下结论，文字比较难叙述，我会尽量往清楚去说明。因为我们使用的是chrome浏览器也就是常说的谷歌浏览器，与IE浏览器不同的是，谷歌，Firefox等浏览器不会忽略空白节点，也就是说会把空白节点当做子节点的一部分，那什么是空白节点呢？我们知道，在HTML代码里在div标签下我们可以看见5个h1标签，也就是元素节点，这是我们可见的，所以我们下意识的就会认为只有5个节点，然而实际上并不是这样，其中还有空白节点的存在，也就是回车，没错，就是你在写代码的时候按下的回车键，那我们来数一数有多少个回车键呢？如图所示我们可以看出其实一共有6个空白节点，所以一共是有11个节点，而不是我们想象的5个。那么问题来了为什么会出现如此怪异的删除效果呢要知道一切现实出来的效果斗鱼我们的代码与变量的变化有关，只要分析清楚了变量的变化，那这个效果就不难理解了，我们来看源代码。源代码的关键地方在content.childNodes.length，我们如果对这条语句进行输出，即“document.write(content.childNodes.length)”会发现得到的结果是11，如果我们形象的表示此时每个节点的排列的话，是这样子的开始循环时，i=0，条件满足，所以删掉第一个空白节点，但此时两个地方发生变化，一个是HTML的标号由于前面的空白节点被删除所以由1变为0，同时length由11变为10，此时i++变为1，因为HTML的标号已经变为0，那么他下面的第二个空白节点的标号就变为1，所以再次循环一次删除的是第二个空白节点而不是HTML，在视觉效果上就相当于没有删除。i++变为2，length变为9，因为删掉了第二个空白节点，所以php现在紧挨着HTML，标号为1（因为HTML的标号为0）此时i=2小于length=9，所以循环继续，此时删除的是标号为2的那个节点也就是php下面的节点—第三个空白节点同理删除后其后面的节点的标号向前进，在视觉效果上仍然没有删除任何东西，而此时length再一次减小，变为8，i变为3，继续循环，javascript此时的标号变为2，第四个空白节点的标号变为3，所以把第四个空白节点删掉，i为4，length为8，此时iquery由于紧挨着javascript，中间的空白节点已经删除，所以它的标号为3，它下面的第五个空白节点的标号为4，所以把第五个空白节点删掉，i=5，length=7，视觉上无变化，再进循环，java的标号已经变为4，它下面的第六个空白节点标号为5，对应i=5，删除掉，此时i=6，length=7，此时后面的没有节点，所以全部是null了，就会退出循环，第一次的点击按钮实际上是删除了所有的空白节点。 第二次点击按钮此时的length已经变为5，因为只剩下了5个元素节点，也就是5个h1标签，标号是0到4，从i=0开始循环，第一次删除掉HTML，剩下4个节点的标号都因此减一，同时length-1变为4，i变为1，再一次进行，删除掉标号由2变为1的javascript，留下了php，javascript后面的jquery和java的标号变为1和2，i变为2，length变为3，循环回来，删除掉标号为2的节点即java，length变为2，i变为3，退出循环，所以第二次点击按钮后剩下的是php和jquery 第三次点击length已经变为2，i从0开始，第一次循环删除掉php，i变为1，length变为1，jquery的标号变为0，不满足循环条件，退出for循环，第三次结束，剩下一个jquery。 第四次点击删除掉jquery，皆大欢喜。好啦，上面就是为什么我们的代码会执行出这样的效果的解释，相信大家只要能看完都能看懂的啦。那么想要一次性的删除怎么做呢？很简单，从后往前循环就好啦。代码改为： for(i=content.childNodes.length-1;i&gt;=0;i--)]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于在Mic theme配置下的一些心得]]></title>
    <url>%2F2018%2F08%2F28%2F%E5%85%B3%E4%BA%8E%E5%9C%A8Mic-theme%E9%85%8D%E7%BD%AE%E4%B8%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[关于在Mic theme配置下的一些心得前言本人是一个前端小白，最近才开始搭建自己的博客并且开始进行配置，也发布一些自己写的小文章，因为开始用到的主题是next，当然next的简洁大方是很受大部分大佬们所喜欢的，但作为一个前端萌新，同时也是电影《指环王》的忠实爱好者，期待一个更加魔幻的主题来作为你自己博客的主界面，在我的不懈努力之下终于找到了Mic_theme这个主题，经过这几天的配置，同时也踩过不少坑，博客已经初具形态，在日后的配置中，会经常更新这篇文章，加入一些自己喜欢的内容和效果。一小点题外话，建议大家用一些专业的文本编辑器，例如我用的是MarkdownPad，或者用WebStorm什么的 正文言归正传,第一次写这篇文章，主要有以下几个内容1.更换背景2.更换intro部分介绍3.更换导航栏样式4.给每一篇文章添加缩略图5.自定义样式6.自定义html文件 以下是详细讲解 1.更换背景更换背景就是说更换在文章“下面”fixed的图片，初期下载下来Mic_theme的时候背景图片是这个我们在从github里面clone下来的 hexo-theme-Mic_theme-&gt;readme.md里面可以看到这样的说法 3.主页背景图片：默认链接是在主站以下目录的 &quot;img/bg.jpg&quot; 就代表&quot;miccall.tech/img/bg.jpg&quot; 暂不支持外链 **backgroundpic :** &quot;img/bg.jpg&quot; 在对应的主题配置文件(Mic_theme里面的主题配置文件)_config.yml可以看到如下的参数配置（我是用webstorm打开的）其中backgroundpic的值是背景图片的链接，图片名是bg.jpg所以在更换背景时，只需要更改链接就可以了，只需要注意一点，图片必须在themes\hexo-theme-Mic_Theme\source\img目录下才可以直接根据图片名添加，否则没有效果ps:获取图片链接的代码在:themes\hexo-theme-Mic_Theme\source\img\head.ejs里面，代码如下 body:before { content: &#39; &#39;; position: fixed; top: 0; background: url(&#39;&lt;%- config.root %&gt;&lt;%- theme.head.backgroundpic%&gt;&#39;) center 0 no-repeat; right: 0; bottom: 0; left: 0; background-size: cover; } 2.更换intro部分介绍首先，默认的intro介绍是这样子的我们想要改成自己的介绍，需要在themes\hexo-theme-Mic_Theme里面的_config.yml主题配置文件里面进行设置，直接在文件里面修改对应的值即可，这个是我自己修改后的介绍 Intro: name: 不会拉小提琴的左脚&lt;sub&gt;的博客&lt;/sub&gt; slogan: &quot;Welcome to my blog page&quot; HeadButton: home page 在_config.yml文件中配置的时候，可以直接通过html的标签来实现文字的一些效果，比如我用到了sub标签，实现了下角标的效果同样，如果有小伙伴好奇这个THIS IS是怎么出现的，可以在themes\hexo-theme-Mic_Theme\layout_partial下面的intro.ejs文件里面找到对应的html代码，并可以做出相应的修改 &lt;div id=&quot;intro&quot;&gt; &lt;h1&gt;You are at&lt;br /&gt; &lt;%- theme.Intro.name %&gt; &lt;/h1&gt; &lt;p&gt; &lt;%- theme.Intro.slogan %&gt; &lt;/p&gt; &lt;ul class=&quot;actions&quot;&gt; &lt;li&gt;&lt;a href=&quot;#header&quot; class=&quot;button icon solo fa-arrow-down scrolly&quot;&gt;Continue&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; 同时对应的css代码全部在themes\hexo-theme-Mic_Theme\source\css下面的mic_main.css中，对应的设置介绍部分的代码93~319行，这里只贴出部分代码以作示例 #intro h1 { margin-top: 6rem; letter-spacing:8px; font-size: 4rem; line-height: 4rem; user-select: none; } #intro p { font-size: 3rem; font-style: italic; margin-top: -0.25rem; text-align: center; user-select: none; } @media screen and (max-width: 500px) { #intro { padding: 3rem 2rem 1rem 2rem ; min-height: 80vh; } #intro h1 { font-size: 5rem; line-height: 1.1; margin-bottom: 7rem; } #intro p { font-size: 1rem; margin-top: 0rem; } #intro .actions { display: none; } } 3.更换导航栏样式默认的导航栏样式如下：如图所示，大致可分为两个部分，左边是个人信息等的导航(当然不止这些，可以自行设置),右边是设置导航栏的图片，默认有github和500px,下面我们来自己进行一下配置首先，我们来看官方的readme.md文档: Home_name: 主页 # 主页名字 is_use_categories : true # 是否启用分类 categories_name: 分类 # 分类名字 is_use_archives : false # 是否启用归档 archives_name: 归档 # 归档名字 icon: # 导航栏上的图标 github: use: true # 是否启用 link: https://github.com/miccall # 点击地址 Twitter: use: false link: Facebook: use: false link: Instagram: use: false link: pages: # 自定义连接页 # link 的参数为相对路径，对应 hexo 目录下的 source 件夹内的相应文件夹 简历: link: &quot;/about/&quot; 团队 : link: &quot;/group/&quot; 图库 : link: &quot;/gallery/&quot; 标签: link: &quot;/tag/&quot; #自定义标签名 # link：“路径” MainFirst: # 导航栏下面的主页 name: Miccall Metro # 大标题名字 description: Welcome to my Blog # 第二标签 描述 pic_url: /img/me.jpg # 图片地址 goto_ulr: &quot;&quot; # 点击跳转 Gallery: # 图库页 title: Mr.metro description: Just another fine responsive 首先，左侧第一个内容主页在Home_name一栏进行设置，名字可以自定义，如改成Home Page第二个分类，是否启用分类is_use_categories默认设置为true，即启用分类，可以修改为false或者删除第三个归档。默认设置为false，同样可以修改参数的值来达到其他的效果，例如，设置为true后默认按时间分类icon设置了右侧的图标样式，图标均取自于fontawesome可以自定义，注意github里面的link要改成自己的github地址MainFisrt定义了位于导航栏下方的自我介绍的内容以及自己的图片，如果不想要，可以在themes\hexo-theme-Mic_Theme\layout_partial里面的mainfirst.ejs文件中设置display:none令其隐藏，具体代码如下: &lt;div id=&quot;main&quot; style=&quot;display: none&quot;&gt; &lt;!-- Main first s--&gt; &lt;article id=&quot;me&quot; class=&quot;panel&quot;&gt; &lt;header style=&quot;color: #000000;&quot;&gt; &lt;h1&gt;&lt;%- theme.MainFirst.name %&gt;&lt;/h1&gt; &lt;p&gt;&lt;%- theme.MainFirst.description %&gt;&lt;/p&gt; &lt;a href=&quot;&lt;%- theme.MainFirst.goto_ulr %&gt;&quot; class=&quot;jumplink pic&quot;&gt; &lt;img src=&quot;&lt;%- theme.MainFirst.pic_url %&gt;&quot; alt=&quot;&quot; /&gt; &lt;/a&gt; &lt;/header&gt; &lt;/article&gt; &lt;!-- Main first e--&gt; &lt;/div&gt; 4.给每一篇文章添加缩略图昨天本来已经写完这部分了，结果没有保存。。。只好重新开始o(╯□╰)o我们在官网给出的样例中可以看到里面的每一篇文章都有一个背景，逼格瞬间上去了有木有啊~（附样例） 然而我们刚配置好的博客打开来看文章背后是一片空白，就像这样子那怎么样才能达到官网样例的效果呢？仔细阅读官网的readme.md文档，发现里面有这样一个参数：thumbnail，后面加的注释意为缩略图 title: # 文章标题 date: 2017/3/27 13:48:25 # 文章发表时间 tags: - 标签1 - 标签2 (可选) categories: Algorithm # 分类 thumbnail: https://xxxxxxxxxx.png # 略缩图 可能我们第一眼看上去并没有看懂这个缩略图的意思，但是通读整篇文档，最有可能的就是这个了，那么我们按照文档里面给出的格式进行配置，因为我这里用到的是MarkdownPad2，可以直击添加图片，但这里注意一点，利用MarkdownPad2上传的图片链接的格式是 ![](https://xxxxxxxxxxxxx.png) 而文档中要求只需要https后面的东西，所以生成链接后直接拿出https://xxxxxxxxx.png部分，添加到文章头部的参数thumbnail后面，然后保存，执行hexo s，再次打开的效果就和例子里面的一样了φ(≧ω≦*)♪，OK大功告成! --- title: 关于在Mic theme配置下的一些心得 date: 2018-08-28 15:21:07 tags: Mic_theme hexo blog thumbnail: https://i.imgur.com/OBxizjH.jpg --- 最终效果如图 5.自定义样式说起来自己的博客肯定希望有点自己的个性，所以免不了就会想着这里改动一下，那里改动一下，然而直接在主题配置文件里修改如果还达不到个人的口味，就会希望一些更直接的修改，所以在这里我介绍一下直接对css文件进行修改的方法，我自己也在这里面改了不少了首先：主css文件在themes\hexo-theme-Mic_Theme\source\css下的mic_main.css文件中，打开来一看，有4000多行，那跑不了了，就是它了，我们只需要找到对应的选择器，即可在里面进行修改，同时该css文件中也加入了响应式的写法，同样可以自己修改，下面是我自己修改的几个例子： 1.导航栏样式的修改在mic_main.css文件1382行左右，可以看到这样一段代码 @media screen and (max-width: 980px) { #nav { display: none; } } 也就是说在屏幕宽度小于等于980px的时候，默认的导航栏样式消失，至于消失的导航栏去了哪，可以在博客界面右上角看到多了一个menu按钮，点开来看导航都在里面，同时在mic_main.css文2012行有如下代码 @media screen and (max-width: 980px) { #navPanelToggle { display: block; } } 意思很简单，就是显示那个menu按钮，这里面我们可以修改一下边界的宽度，因为现在主流的四种设备即为大屏，中屏，小屏，超小屏，其分类的边界为1200px,992px,768px,即1200px以上是大屏，也就是我们电脑或者显示器的屏幕，992px~1200px为中屏，一般是桌面显示器，768px~992px是小屏幕，一般是平板等，再往下小于768px的就是移动端也就是我们的手机了(以上数据来自于bootstrap的媒体查询宽度)，所以如果你觉得980px别扭的话，可以修改为其他值。点开menu菜单，除了几个链接，就是白白的背景，我们可以为背景加上自己喜欢的图片，设置方法:找到mic_main.css文件里面的id=#navPanel（可以在控制台里面直接找到），在其伪类before下添加背景图片的代码(mic_main.css下2053行上下),下面是我修改后的代码 #navPanel:before{ content: &quot;&quot;; background: url(../images/me2.jpg) center no-repeat; position: absolute; width: 100%; height: 100%; background-size: cover; overflow: hidden; top: 0; left: 0; } 再次打开观察效果 酷的一批啊，哈哈（ps:原来的文字是黑色的，大家可以自行修改，为了对比明显，我将其改为了白色）]]></content>
      <tags>
        <tag>Mic_theme hexo blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery鼠标事件总结（持续更新中）]]></title>
    <url>%2F2018%2F08%2F26%2FjQuery%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[jQuery鼠标事件jQuery鼠标事件–鼠标滚轮事件jQuery鼠标滚轮事件一共分为两类： 支持Firefox浏览器 针对火狐浏览器需要对DOMMouseScroll事件进行监听 支持其他浏览器 针对其他浏览器直接添加事件onmousewheel即可 还有一点两类浏览器不同的地方在于：Firefox浏览器在判断鼠标滚轮滚动的方向时与其他浏览器方向相反，其余四类浏览器使用event对象里面的wheelDelta事件来进行对鼠标滚动的判断。它的取值有两个，分别是+120和-120，+120表示滚轮向上滚动，-120表示滚轮向下滚动在Firefox中，使用event对象那个里面的detail事件来判断滚轮滚动的方向，同样取值有两个，分别为+3和-3，与另外四类浏览器不同的是，向上滚的时候detail的值是-3，向下滚是+3 下面请看代码实例–通过滚动鼠标滚轮，可以使输入框内的数字变大变小，同时可以在控制台内输出不同浏览器里面两种事件wheelDelta和detail的值，读者可以亲自验证后加深理解 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;01 鼠标滚轮事件&lt;/title&gt; &lt;style&gt; body{ margin: 0; padding: 0; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;text&quot; value=&quot;1&quot;&gt; &lt;script&gt; window.onload = function (ev) { /*根据浏览器的不同赋不同的值*/ var mouseWheel = navigator.userAgent.indexOf(&#39;Firefox&#39;) &gt;= 0 ? &#39;DOMMouseScroll&#39;: &#39;mouseWheel&#39;; var numVal = document.querySelector(&quot;input&quot;).value; /*打印当前输入框内的value值*/ console.log(numVal); if (document.addEventListener){ /*火狐浏览器*/ /*使用addEventListener监听DOMMouseScroll事件*/ document.addEventListener(&#39;DOMMouseScroll&#39;,function (e) { e = e || window.event; if (e.detail &gt; 0){ /*向下滚*/ console.log(e.detail); numVal--; document.querySelector(&quot;input&quot;).value = numVal; }else if (e.detail &lt; 0){ /*向上滚*/ console.log(e.detail); numVal++; document.querySelector(&quot;input&quot;).value = numVal; } },false); /*其他浏览器*/ /*onmousewheel 直接绑定鼠标滚轮滚动事件*/ window.onmousewheel = function (e) { if (e.wheelDelta){ if (e.wheelDelta &gt; 0){ console.log(e.wheelDelta); // console.log(&quot;上&quot;); numVal++; // console.log(numVal); document.querySelector(&quot;input&quot;).value = numVal; }else if (e.wheelDelta &lt; 0){ console.log(e.wheelDelta); // console.log(&quot;下&quot;); numVal--; // console.log(numVal); document.querySelector(&quot;input&quot;).value = numVal; } } } } } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;]]></content>
      <tags>
        <tag>jQuery mouse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[overflowhidden]]></title>
    <url>%2F2018%2F08%2F26%2Foverflow%20hidden%E7%9A%84%E5%A4%9A%E9%87%8D%E4%BD%9C%E7%94%A8%2F</url>
    <content type="text"><![CDATA[overflow:hidden的多重作用1.第一个当然就是最常见也最常用的溢出隐藏啦OK，首先是没有加overflow:hidden时的效果代码如下： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;镂空测试&lt;/title&gt; &lt;style&gt; body{ margin: 0; padding: 0; } .parentBox{ width: 200px; height: 200px; background-color: yellow; } .childBox{ width: 100px; height: 300px; background-color: #2b542c; z-index: 99; margin-left: 15px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;parentBox&quot;&gt; &lt;div class=&quot;childBox&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 这个效果的形成非常好理解，我们直接看加入overflow:hidden之后的效果部分代码如下（其余部分不变）： .parentBox{ width: 200px; height: 200px; background-color: yellow; overflow: hidden; } 可以看出子元素超出父元素的部分隐藏掉了，这里要注意一点：overflow:hidden一定是设置在父容器上面才能让子容器隐藏！ 2.第二个可能不太常用，那就是清除浮动在css常见的一种高度设置就是用子容器来撑开父容器的高度，这样不用给父容器设置高度，只需要依靠子容器自己的内容，边距等撑开高度，然而，当我们这个子容器设置了浮动属性后，效果就是下面这个样子：代码如下： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;镂空测试&lt;/title&gt; &lt;style&gt; body{ margin: 0; padding: 0; } .parentBox{ padding: 25px; width: 200px; background-color: yellow; } .childBox{ width: 100px; height: 300px; background-color: #2b542c; margin-left: 15px; float: left; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;parentBox&quot;&gt; &lt;div class=&quot;childBox&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 为什么会有这个样子，为什么子容器没有撑开父容器的高度？原因在这里：子容器设置float属性后（这里是float:left），脱离了原本的文档流，可以这么理解，在设置float属性前，子容器与它的父容器是出于同一个平面上的，我们暂且把这个平面叫做文档流，这样因为在同一平面，所以子容器有什么变化都会影响到父容器，所以给子容器设置高度能撑开父容器，而设置了float属性后，子容器脱离原本的文档流，从浏览器里面可以看到子容器是在父容器上面，用“平面”来解释就是子容器到了一个比父容器高那么一点的另一个平面上（实际上并不存在，类比去理解），那么在这个平面上子容器不管进行什么动作都不会影响父容器，也自然不会撑开父容器的高度了（在本例中与float属性有同样效果的还有position:absolute，也就是绝对定位和position:fixed固定定位，他们也会让元素脱离当前的文档流）然而在给父容器设置了overflow:hidden后， .parentBox{ padding: 25px; width: 200px; background-color: yellow; overflow: hidden; } 注意子元素此时是设置的float属性，如果设置了上文说到的position两个属性，那么overflow:hidden不会有效果 3.第三个作用与第二个差不多，也是消除浮动的影响，通过overflow:hidden来实现自适应布局直接代码+效果说话 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;镂空测试&lt;/title&gt; &lt;style&gt; body{ margin: 0; padding: 0; } .contentBox1{ width: 200px; height: 200px; background-color: yellow; float: left; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;contentBox1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;contentBox2&quot;&gt;内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 为什么会有这样的效果？因为float的初衷就是也只是实现文字环绕效果，只不过后来人们用它来布局，慢慢的就舍弃了它的本质了然后我们给第二个div加上overflow:hidden属性 .contentBox2{ overflow: hidden; } 现在的效果：可以看到的是，文字全被“挤到”了右侧，就想是两个div之间插入了一堵无形的墙把两个div给隔开了（这样的结构满足了流式布局的要求，可以作为左侧固定，右侧自适应的一个模板，即两栏自适应）关于overflow:hidden为什么能清除浮动，我会在另一篇博文中详细解释]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
</search>
